<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MASS â€” Albums & Tracks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg:#ffffff; --fg:#1a1a1a; --muted:#6b6b6b; --card:#ffffff; --accent:#8b5cf6; --border:#e5e5e5;
      --cover-size: 140px;
      --overlay: rgba(255,255,255,.85);
      --btn-gradient-start:#8b5cf6;
      --btn-gradient-end:#a78bfa;
      --btn-text:#ffffff;
      --btn-shadow:rgba(139,92,246,0.25);
      --btn-shadow-hover:rgba(139,92,246,0.35);
      --sidebar-bg: #f5f5f7;
      --sidebar-width: 240px;
      --text-secondary: #666666;
      --hover-bg: #f0f0f2;
      --player-height: 80px;
        }
    body.dark-mode {
      --bg:#121212; --fg:#e8e8e8; --muted:#999999; --card:#1a1a1a; --accent:#8b5cf6; --border:#333333;
      --overlay: rgba(0,0,0,.85);
      --btn-gradient-start:#8b5cf6;
      --btn-gradient-end:#a78bfa;
      --btn-text:#ffffff;
      --btn-shadow:rgba(139,92,246,0.25);
      --btn-shadow-hover:rgba(139,92,246,0.35);
      --sidebar-bg: #1a1a1a;
      --text-secondary: #999999;
      --hover-bg: rgba(255,255,255,0.05);
    }
    body.dark-mode header {
      background:linear-gradient(180deg,rgba(0,0,0,0.98),rgba(0,0,0,0.9));
    }
    body.dark-mode .playlist-track:hover {
      background:rgba(255,255,255,0.05);
      border-color:rgba(255,255,255,0.1);
    }
    body.dark-mode .playlist-track.playing {
      background:rgba(98,245,169,0.15);
    }
    body.dark-mode .modal header {
      background:var(--card);
    }
    body.dark-mode .track {
      background:rgba(255,255,255,0.03);
    }
    body.dark-mode .playing {
      background:rgba(98,245,169,0.15);
    }
    body.dark-mode .more-by-artist {
      background:var(--card);
    }
    body.dark-mode .more-by-artist-item:hover {
      background:rgba(255,255,255,0.05);
    }

    /* Sidebar Styles */
    .app-wrapper {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: var(--sidebar-width);
      background: var(--sidebar-bg);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      overflow-y: auto;
      z-index: 100;
      border-right: none;
      padding-bottom: 100px;
    }
    .sidebar-logo {
      padding: 127px 20px 20px;
    }
    .sidebar-logo img {
      max-width: 120px;
      height: auto;
    }
    .sidebar-nav {
      padding: 8px 0;
      flex: 1;
    }
    .nav-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      color: var(--fg);
      text-decoration: none;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }
    .nav-item:hover {
      background: var(--hover-bg);
    }
    .nav-item.active {
      color: var(--fg);
      font-weight: 600;
    }
    .nav-item svg {
      width: 22px;
      height: 22px;
      flex-shrink: 0;
      color: var(--accent);
    }
    .nav-item:hover svg {
      color: var(--accent);
    }
    .nav-item.active svg {
      color: var(--accent);
    }
    .nav-section {
      margin-top: 4px;
    }
    .nav-sub-item {
      padding-left: 48px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 400;
    }
    .nav-sub-item:hover {
      color: var(--text-secondary);
    }
    /* Sidebar Playlist Item Icons */
    .sidebar-playlists-list .sidebar-playlist-btn::before {
      content: '';
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, var(--accent) 0%, #a78bfa 100%);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z'/%3E%3C/svg%3E");
      background-size: 14px;
      background-position: center;
      background-repeat: no-repeat;
    }
    .sidebar-playlists {
      padding: 16px 12px;
      border-top: 1px solid var(--border);
    }
    .sidebar-playlists-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 4px;
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      user-select: none;
    }
    .sidebar-playlists-toggle {
      transition: transform 0.3s ease;
      font-size: 10px;
    }
    .sidebar-playlists.collapsed .sidebar-playlists-toggle {
      transform: rotate(-90deg);
    }
    .sidebar-playlists-content {
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      max-height: 400px;
      opacity: 1;
    }
    .sidebar-playlists.collapsed .sidebar-playlists-content {
      max-height: 0;
      opacity: 0;
    }
    .sidebar-playlists-list {
      list-style: none;
      margin: 8px 0 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .sidebar-playlist-item {
      padding: 0;
    }
    .sidebar-playlist-btn {
      width: 100%;
      padding: 8px 6px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 13px;
      text-align: left;
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.15s ease, color 0.15s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .sidebar-playlist-btn:hover {
      background: var(--hover-bg);
      color: var(--fg);
    }
    .sidebar-playlist-btn.active {
      background: rgba(98,245,169,0.15);
      color: var(--accent);
    }
    .sidebar-playlist-thumb {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      background: var(--border) center/cover no-repeat;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .sidebar-playlist-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sidebar-playlist-count {
      font-size: 11px;
      color: var(--muted);
    }
    .sidebar-playlists-empty {
      padding: 12px 6px;
      text-align: center;
      font-size: 12px;
      color: var(--muted);
    }
    .main-wrapper {
      flex: 1;
      margin-left: var(--sidebar-width);
      min-width: 0;
      padding-bottom: var(--player-height);
    }

    /* New Navigation Section Styles */
    .nav-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px 8px;
      font-size: 13px;
      font-weight: 600;
      color: var(--fg);
      cursor: pointer;
      user-select: none;
    }
    .nav-section-header:hover {
      background: var(--hover-bg);
    }
    .nav-section-header .chevron {
      font-size: 10px;
      transition: transform 0.2s ease;
      color: var(--muted);
    }
    .nav-section.collapsed .chevron {
      transform: rotate(-90deg);
    }
    .nav-section-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
      max-height: 500px;
    }
    .nav-section.collapsed .nav-section-content {
      max-height: 0;
    }
    .nav-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 16px;
    }

    /* Header Icons */
    .header-icons {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .header-icon-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .header-icon-btn:hover {
      background: var(--hover-bg);
      color: var(--fg);
    }
    .header-icon-btn svg {
      width: 22px;
      height: 22px;
    }
    .header-profile-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid var(--accent);
      background: var(--hover-bg);
      color: var(--accent);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .header-profile-btn:hover {
      background: rgba(139,92,246,0.1);
    }
    .header-profile-btn svg {
      width: 22px;
      height: 22px;
    }

    /* Home Page Title */
    .page-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--fg);
      margin: 0 0 24px 0;
      padding: 0;
    }

    /* Section Headers */
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .section-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--fg);
      margin: 0;
    }
    .section-nav {
      display: flex;
      gap: 8px;
    }
    .section-nav-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .section-nav-btn:hover:not(:disabled) {
      border-color: var(--accent);
      color: var(--accent);
    }
    .section-nav-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Major Releases Carousel */
    .releases-section {
      margin-bottom: 32px;
    }
    .releases-carousel {
      display: flex;
      gap: 16px;
      overflow-x: auto;
      scroll-behavior: smooth;
      scrollbar-width: none;
      -ms-overflow-style: none;
      padding-bottom: 8px;
    }
    .releases-carousel::-webkit-scrollbar {
      display: none;
    }
    .release-card {
      flex: 0 0 220px;
      height: 280px;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .release-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 24px rgba(0,0,0,0.15);
    }
    .release-card-bg {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      background-color: #e0e0e0;
    }
    .release-card-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0) 40%, rgba(0,0,0,0.8) 100%);
    }
    .release-card-content {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 16px;
      color: #fff;
    }
    .release-card-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 4px 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .release-card-artist {
      font-size: 14px;
      color: rgba(255,255,255,0.8);
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Playlist View - Two Column Layout */
    .playlist-view {
      display: none;
      flex-direction: column;
      gap: 24px;
      padding: 0;
      height: calc(100vh - var(--player-height) - 97px);
      overflow: hidden;
    }
    .playlist-view.active {
      display: flex;
    }
    .playlist-view-header {
      margin-bottom: 8px;
    }
    .playlist-view-header-top {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .playlist-back-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--fg);
      transition: background 0.15s ease;
    }
    .playlist-back-btn:hover {
      background: var(--hover-bg);
    }
    .playlist-view-titles {
      flex: 1;
    }
    .playlist-view-title {
      font-size: 32px;
      font-weight: 700;
      color: var(--fg);
      margin: 0 0 4px 0;
    }
    .playlist-view-subtitle {
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }
    .playlist-view-content {
      display: flex;
      gap: 32px;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    /* Left Column - Album List */
    .playlist-albums-list {
      flex: 0 0 380px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      padding-right: 16px;
      height: 100%;
    }
    .playlist-albums-list::-webkit-scrollbar {
      width: 6px;
    }
    .playlist-albums-list::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }
    .playlist-album-item {
      display: flex;
      gap: 16px;
      padding: 8px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.15s ease;
    }
    .playlist-album-item:hover {
      background: var(--hover-bg);
    }
    .playlist-album-item.selected {
      background: var(--hover-bg);
    }
    .playlist-album-thumb {
      width: 110px;
      height: 110px;
      border-radius: 6px;
      overflow: hidden;
      flex-shrink: 0;
      background: var(--border);
    }
    .playlist-album-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .playlist-album-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
      min-width: 0;
    }
    .playlist-album-name {
      font-size: 16px;
      font-weight: 600;
      color: #888888;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .playlist-album-artist {
      font-size: 14px;
      color: #888888;
      margin: 0;
    }
    .playlist-album-stats {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }
    .playlist-album-stat {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 13px;
      color: #8a8a8a;
    }
    .playlist-album-stat svg {
      width: 14px;
      height: 14px;
    }

    /* Right Column - Selected Album Details */
    .playlist-album-detail {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 0;
      overflow-y: auto;
      height: 100%;
    }
    .playlist-album-detail::-webkit-scrollbar {
      width: 6px;
    }
    .playlist-album-detail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }
    .playlist-detail-header {
      display: flex;
      gap: 24px;
    }
    .playlist-detail-artwork {
      width: 180px;
      height: 180px;
      border-radius: 12px;
      overflow: hidden;
      flex-shrink: 0;
      background: var(--border);
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }
    .playlist-detail-artwork img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .playlist-detail-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 0;
    }
    .playlist-detail-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--fg);
      margin: 0;
    }
    .playlist-detail-artist {
      font-size: 28px;
      font-weight: 700;
      color: var(--accent);
      margin: 0;
      cursor: pointer;
    }
    .playlist-detail-artist:hover {
      text-decoration: underline;
    }
    .playlist-detail-meta {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-top: 10px;
    }
    .playlist-detail-genre {
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .playlist-detail-year {
      font-size: 14px;
      color: var(--muted);
    }
    .playlist-detail-stats {
      display: flex;
      gap: 24px;
      margin-top: 16px;
    }
    .playlist-detail-stat {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      color: #8a8a8a;
    }
    .playlist-detail-stat svg {
      width: 14px;
      height: 14px;
    }

    /* Track List */
    .playlist-track-list {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin-top: 24px;
    }
    .playlist-track-item {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 14px 0;
      border-bottom: 1px solid #eaeaec;
      cursor: pointer;
      transition: background 0.15s ease;
    }
    .playlist-track-item:first-child {
      border-top: 1px solid #eaeaec;
    }
    .playlist-track-item:hover {
      background: rgba(0,0,0,0.02);
    }
    .playlist-track-item.playing {
      background: rgba(139,92,246,0.08);
    }
    .playlist-track-number {
      width: 28px;
      font-size: 15px;
      color: #8a8a8a;
      text-align: left;
    }
    .playlist-track-name {
      flex: 1;
      font-size: 15px;
      color: #888888;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .playlist-track-duration {
      font-size: 15px;
      color: #8a8a8a;
      min-width: 45px;
      text-align: right;
    }
    .playlist-track-actions {
      display: flex;
      gap: 6px;
      opacity: 0;
      transition: opacity 0.15s ease;
      flex-shrink: 0;
    }
    .playlist-track-item:hover .playlist-track-actions {
      opacity: 1;
    }
    .track-action-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      color: var(--text-secondary);
      white-space: nowrap;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
    }
    .track-action-btn:hover {
      background: var(--hover-bg);
      color: var(--fg);
    }
    .track-action-btn.saved {
      border-color: var(--accent);
      color: var(--accent);
    }
    .album-action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    .album-action-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 7px 14px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      color: var(--fg);
      transition: background 0.15s, color 0.15s, border-color 0.15s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .album-action-btn:hover {
      background: var(--hover-bg);
    }
    .album-action-btn.saved {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Responsive */
    @media (max-width: 1000px) {
      .playlist-view-content {
        flex-direction: column;
      }
      .playlist-albums-list {
        flex: none;
        max-height: 300px;
      }
      .playlist-detail-header {
        flex-direction: column;
        align-items: center;
        text-align: center;
      }
      .playlist-detail-meta,
      .playlist-detail-stats {
        justify-content: center;
      }
    }

    /* Updated Bottom Player - Matching Reference Design Exactly */
    .mini-player {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--player-height);
      background: #F5F8FF;
      border-top: none;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 0 24px;
      gap: 16px;
      z-index: 200;
    }
    .mini-player.active {
      display: flex;
    }
    .mini-player-left {
      display: flex;
      align-items: center;
      gap: 14px;
      min-width: 200px;
    }
    .mini-player-artwork {
      width: 52px;
      height: 52px;
      border-radius: 6px;
      overflow: hidden;
      background: #e0e0e4;
      flex-shrink: 0;
    }
    .mini-player-artwork img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .mini-player-info {
      display: flex;
      flex-direction: column;
      gap: 0;
      min-width: 0;
      align-items: flex-start;
      text-align: left;
    }
    .mini-player-title {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #1a1a1a;
      line-height: 1.2;
    }
    .mini-player-artist {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      line-height: 1.2;
    }
    .mini-player-artist:hover {
      text-decoration: underline;
    }
    .mini-player-center {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .mini-player-right {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 50px;
    }
    .player-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: transparent;
      color: #6b6b6b;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.15s ease;
      flex-shrink: 0;
    }
    .player-btn:hover {
      color: var(--accent);
    }
    .player-btn.play-pause {
      width: 34px;
      height: 34px;
      background: transparent;
      color: #6b6b6b;
      border: 2px solid #6b6b6b;
      border-radius: 50%;
    }
    .player-btn.play-pause:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    .player-time {
      font-size: 12px;
      color: #8a8a8a;
      min-width: 40px;
      text-align: center;
      flex-shrink: 0;
    }
    .player-progress-bar {
      width: 483px;
      height: 4px;
      background: #d8d8dc;
      border-radius: 2px;
      cursor: pointer;
      position: relative;
      flex-shrink: 0;
    }
    .player-progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s linear;
    }
    .player-volume-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: #8a8a8a;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .player-volume-btn:hover {
      color: var(--accent);
    }
    .player-volume-slider {
      width: 80px;
      height: 4px;
      background: #d8d8dc;
      border-radius: 2px;
      cursor: pointer;
      position: relative;
    }
    .player-volume-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      width: 70%;
    }

    /* Responsive player */
    @media (max-width: 900px) {
      .mini-player {
        left: 0;
        padding: 0 16px;
        gap: 16px;
      }
      .mini-player-left {
        flex: 0 0 auto;
      }
      .mini-player-right {
        flex: 0 0 auto;
      }
      .player-volume-slider {
        display: none;
      }
      .player-progress-bar {
        min-width: 100px;
      }
    }

    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:'Open Sans',-apple-system,BlinkMacSystemFont,sans-serif;min-height:100vh;}
    html{background:var(--bg);}
    body{background:var(--bg);}
    header{height:97px;box-sizing:border-box;padding:0;border-bottom:none;position:sticky;top:0;background:var(--sidebar-bg);z-index:10;display:flex;align-items:center;}
    .header-main{width:100%;padding:0 32px;display:flex;gap:16px;align-items:center;justify-content:flex-start;}
    .header-logo{flex-shrink:0;max-height:80px;filter:drop-shadow(0 6px 12px rgba(0,0,0,0.25));}
    .searchbar{display:flex;align-items:center;gap:4px;}
    .search-fields{display:flex;gap:4px;flex:1;}
    .searchbar input{background:var(--card);color:var(--fg);border:1px solid var(--border);border-radius:6px;padding:4px 6px;font-size:11px;outline:none;min-width:60px;}
    .searchbar select{padding:4px 6px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--fg);font-size:11px;cursor:pointer;min-width:80px;}
    .searchbar button{border-radius:6px;padding:4px 8px;font-weight:600;cursor:pointer;font-size:11px;height:24px;white-space:nowrap;}
    .searchbar > div:last-of-type{display:flex;gap:4px;align-items:center;}
    .header-actions{display:flex;align-items:center;gap:4px;flex-wrap:nowrap;}
    .header-actions .btn, .auth-controls .btn{height:24px;padding:4px 8px;font-size:11px;border-radius:6px;}
    .ai-search-toggle{padding:4px 8px;font-size:11px;height:24px;}
    .ai-search-toggle strong{font-size:11px;}

    main{max-width:1400px;margin:0 auto;padding:24px 32px 40px 32px;}
    #homeContent{margin-bottom:32px;}
    .layout-grid{display:flex;gap:20px;align-items:flex-start;flex-wrap:nowrap;justify-content:space-between;}
    .playlist-column{flex:0 0 260px;max-width:260px;width:100%;display:flex;flex-direction:column;gap:14px;position:relative;order:1;}
    .playlist-column[hidden]{display:none !important;}
    .playlist-column:not(:has(section:not([hidden]))){display:none !important;}
    .content-column{flex:1 1 auto;min-width:400px;display:flex;flex-direction:column;gap:16px;width:100%;order:2;}
    /* Mini player ribbon removed - now using bottom ribbon */
    .public-playlists{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;display:flex;flex-direction:column;gap:10px;transition:gap 0.3s ease;}
    .public-playlists.collapsed{gap:0;}
    .public-playlists .playlists-header{display:flex;align-items:center;justify-content:space-between;gap:8px;cursor:pointer;user-select:none;padding:4px 8px;margin:-4px -8px;border-radius:8px;transition:background 0.2s ease;pointer-events:auto;}
    .public-playlists .playlists-header *{pointer-events:none;}
    .public-playlists .playlists-header:hover{background:rgba(0,0,0,0.03);}
    .public-playlists .playlists-header .main-accordion-toggle{margin-left:8px;transition:transform 0.3s ease;color:var(--muted);font-size:18px;}
    .public-playlists.collapsed .playlists-header .main-accordion-toggle{transform:rotate(-90deg);}
    .public-playlists-content{overflow:hidden;transition:max-height 0.4s ease,opacity 0.3s ease,margin 0.3s ease;max-height:2000px;opacity:1;margin-top:0;}
    .public-playlists.collapsed .public-playlists-content{max-height:0;opacity:0;margin-top:0;padding-top:0;padding-bottom:0;}
    .public-playlists-list{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:6px;}
    .public-playlist-item button{width:100%;text-align:left;background:var(--card);border:1px solid var(--border);border-radius:10px;padding:8px 10px;color:var(--fg);font-size:14px;display:flex;align-items:center;justify-content:space-between;gap:8px;cursor:pointer;transition:background .15s ease,border-color .15s ease;}
    .public-playlist-item button:hover{background:var(--border);}
    .public-playlist-item button.active{border-color:var(--accent);box-shadow:0 0 0 1px var(--accent);background:rgba(98,245,169,0.15);}
    .public-playlist-count{color:var(--muted);font-size:12px;}
    .public-featured-row{display:flex;align-items:flex-start;gap:18px;width:100%;}
    .public-featured-row > .public-playlists{flex:0 0 220px;max-width:240px;}
    .public-playlist-view{display:flex;flex-direction:column;gap:12px;border:1px solid var(--border);border-radius:14px;background:var(--card);padding:12px;flex:1;min-width:0;}
    .public-playlist-view[hidden]{display:none !important;}
    .public-playlist-header{display:flex;align-items:center;justify-content:space-between;gap:8px;}
    .public-playlist-title{margin:0;font-size:18px;}
    .public-playlist-status{color:var(--muted);font-size:13px;}
    .public-playlist-tracks{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:6px;overflow-y:auto;max-height:none;}
    .public-playlist-tracks::-webkit-scrollbar{width:8px;}
    .public-playlist-tracks::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.15);border-radius:999px;}
    .public-playlist-track .track-name-title{font-size:14px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .public-playlist-track .track-name-artist{font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .public-playlist-item button{justify-content:flex-start;gap:10px;}
    .public-playlist-thumb{width:34px;height:34px;border-radius:8px;background:#f5f5f5 center/cover no-repeat;flex-shrink:0;display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:16px;overflow:hidden;transition:background .2s ease, color .2s ease;}
    .public-playlist-thumb.has-art{color:transparent;}
    .public-playlist-label{display:flex;flex-direction:column;align-items:flex-start;gap:2px;flex:1;min-width:0;}
    .public-playlist-name{font-weight:600;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .public-playlist-count{color:var(--muted);font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .public-playlist-hero{border-radius:16px;overflow:hidden;background:#f5f5f5;display:flex;align-items:center;justify-content:center;padding:12px;}
    .public-playlist-hero[hidden]{display:none;}
    .public-playlist-hero img{display:block;width:60%;height:auto;max-height:240px;object-fit:contain;}
    .public-playlist-main{flex:1;display:flex;flex-direction:column;gap:12px;}
    .playlist-actions{display:flex;align-items:center;gap:6px;}
    .playlist-footer-actions{margin-top:12px;display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap;}
    .playlist-footer-actions .btn{flex:1;min-width:120px;background:var(--accent);color:var(--btn-text);border:none;font-weight:700;box-shadow:0 4px 12px rgba(98,245,169,0.25);transition:all 0.2s ease;}
    .playlist-footer-actions .btn:hover{transform:translateY(-2px);box-shadow:0 6px 16px rgba(98,245,169,0.35);}
    @media (max-width:1200px){
      .layout-grid{flex-wrap:wrap;}
      .playlist-column{order:1;max-width:100%;flex:1 1 100%;}
      .content-column{order:2;max-width:100%;flex:1 1 100%;}
    }
    @media (max-width:900px){
      .layout-grid{flex-direction:column;gap:16px;}
      .playlist-column{max-width:100%;order:1;}
      .content-column{order:2;min-width:260px;}
      .public-playlist-view{width:100%;max-width:none;}
      .public-featured-row{flex-direction:column;}
      .public-featured-row > .public-playlists{width:100%;max-width:none;}
    }
    .albums{display:grid;grid-template-columns:repeat(auto-fill,minmax(168px,168px));gap:16px;justify-content:start;}
    .albums.single-album{display:flex;flex-direction:column;align-items:center;gap:24px;}
    .card{position:relative;background:var(--card);border:none;border-radius:0;padding:0;display:flex;flex-direction:column;gap:0;overflow:hidden;transition:transform 0.2s ease,box-shadow 0.2s ease;}
    .card:hover{}
    .card.pending-audio{opacity:0.8;}
    .card.no-audio{display:none !important;}

    /* Cover: square image above text */
    .cover-wrap{position:relative;width:100%;aspect-ratio:1/1;border-radius:0;overflow:hidden;border:none;background:#f5f5f5;margin:0;z-index:1;cursor:pointer;}
    .cover-wrap img{width:100%;height:100%;object-fit:cover;display:block;transition:filter 0.2s ease;}
    .cover-wrap::after{content:'';position:absolute;inset:0;background:rgba(0,0,0,0);transition:background 0.2s ease;pointer-events:none;}
    .card:hover .cover-wrap::after{background:rgba(0,0,0,0.3);}
    .albums.single-album .cover-wrap{width:100%;height:100%;margin:0;position:relative;}

    /* No overlay - text below image */
    .card::before{display:none;}

    /* Expand button (arrow) */
    .card-expand-btn{position:absolute;bottom:20px;right:20px;z-index:5;width:36px;height:36px;border-radius:50%;background:var(--accent);border:none;color:#fff;font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:opacity 0.2s ease,transform 0.2s ease;box-shadow:0 2px 8px rgba(139,92,246,0.4);opacity:0;}
    .card:hover .card-expand-btn{opacity:1;}
    .card-expand-btn:hover{transform:scale(1.1);}

    .heading{position:relative;z-index:3;display:flex;align-items:flex-start;gap:4px;flex-wrap:wrap;justify-content:flex-start;text-align:left;padding:10px 0;flex-direction:column;}
    .card h3{margin:0;font-size:13px;font-weight:600;color:var(--fg);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;text-align:left;cursor:pointer;transition:text-decoration 0.2s ease;}
    .card h3:hover{text-decoration:underline;}
    .albums.single-album .card h3{font-size:26px;}
    .card-artist{color:var(--muted);font-size:11px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;text-align:left;cursor:pointer;transition:text-decoration 0.2s ease;}
    .card-artist:hover{text-decoration:underline;}
    .card-genre{color:var(--muted);font-size:10px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;margin-top:2px;}
    .card-buttons{position:relative;z-index:3;padding:0 0 10px 0;display:flex;gap:8px;justify-content:flex-start;}
    .muted{color:var(--muted);font-size:11px;text-align:left;}
    .albums.single-album .muted{font-size:16px;}
    .badge{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:10px;color:var(--muted);background:var(--card);}

    .btn{border-radius:10px;padding:10px 16px;cursor:pointer;font-weight:600;font-size:14px;white-space:nowrap;}
    .btn.small{padding:6px 8px;font-size:13px;}
    .btn.icon{width:34px;display:inline-flex;align-items:center;justify-content:center;}
    .btn-accent{font-weight:700;filter:brightness(1.08);}
    .btn-error{background:#b9383a;border:none;color:#fff;box-shadow:0 6px 16px rgba(185,56,58,0.35);}
    .btn-error:hover{transform:none !important;box-shadow:0 6px 12px rgba(185,56,58,0.4) !important;}
    .btn-error:disabled{opacity:0.9;box-shadow:none;}
    .btn.info-more{font-size:18px;line-height:1;padding:4px 8px;display:flex;align-items:center;justify-content:center;}

    
    .back-row{display:flex;justify-content:center;margin-bottom:12px;}
.toolbar{display:none;}
    .pager{display:flex;gap:10px;align-items:center;justify-content:center;}
    .pager[hidden]{display:none;}
    .pager button{border-radius:10px;padding:10px 12px;cursor:pointer;}
    .count{display:none;}
    .error{background:#ffe6e8;border:1px solid #ffb1b8;color:#b9383a;padding:10px 12px;border-radius:10px;}

    .explore-wrap{display:flex;align-items:center;gap:12px;flex-wrap:wrap;justify-content:flex-end;min-width:220px;}
    .explore-panel{display:flex;gap:18px;flex-wrap:wrap;align-items:flex-start;justify-content:flex-end;max-width:520px;background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;}
    .explore-panel[hidden]{display:none;}
    .explore-section{display:flex;flex-direction:column;gap:8px;min-width:160px;}
    .explore-section h3{margin:0;font-size:11px;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);}
    .explore-buttons{display:flex;flex-wrap:wrap;gap:8px;}
    .explore-buttons button{border-radius:999px;padding:6px 10px;cursor:pointer;font-size:13px;}
    #explore{padding:10px 20px;border-radius:14px;font-weight:700;font-size:15px;white-space:nowrap;}

    .auth-controls{display:flex;align-items:center;gap:4px;flex-wrap:nowrap;justify-content:flex-end;}
    .auth-controls .badge{font-size:10px;padding:2px 6px;}
    .auth-controls [hidden]{display:none !important;}

    /* Responsive header */
    @media (max-width: 1024px) {
      .header-main{grid-template-columns:1fr;gap:12px;}
      .header-logo{max-height:60px;}
      .search-fields{grid-template-columns:1fr;}
      .header-actions{justify-content:center;}
      .auth-controls{justify-content:center;}
    }
    .auth-form{display:flex;flex-direction:column;gap:12px;margin-top:12px;}
    .auth-form label{display:flex;flex-direction:column;gap:6px;font-size:14px;}
    .auth-form input{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px 12px;color:var(--fg);}
    .auth-switch{display:flex;align-items:center;gap:6px;margin-top:12px;font-size:13px;color:var(--muted);}
    .auth-switch button{background:none;border:none;color:var(--accent);cursor:pointer;font-weight:600;padding:0;}
    .auth-switch button:disabled{opacity:.6;cursor:not-allowed;}
    #authError{margin-top:12px;}

    .playlists-panel{padding:12px;border:1px solid var(--border);border-radius:12px;background:var(--card);display:flex;flex-direction:column;gap:10px;transition:gap 0.3s ease;}
    .playlists-panel.collapsed{gap:0;}
    .playlists-panel[hidden]{display:none;}
    .playlists-header{display:flex;align-items:center;gap:12px;justify-content:space-between;cursor:pointer;user-select:none;padding:4px 8px;margin:-4px -8px;border-radius:8px;transition:background 0.2s ease;pointer-events:auto;}
    .playlists-header *{pointer-events:none;}
    .playlists-header:hover{background:rgba(0,0,0,0.03);}
    .playlists-header h2{margin:0;font-size:14px;letter-spacing:.02em;text-transform:uppercase;color:var(--muted);}
    .playlists-header .main-accordion-toggle{margin-left:8px;transition:transform 0.3s ease;color:var(--muted);font-size:18px;}
    .playlists-panel.collapsed .playlists-header .main-accordion-toggle{transform:rotate(-90deg);}
    .playlists-content{overflow:hidden;transition:max-height 0.4s ease,opacity 0.3s ease,margin 0.3s ease;max-height:2000px;opacity:1;margin-top:0;}
    .playlists-panel.collapsed .playlists-content{max-height:0;opacity:0;margin-top:0;padding-top:0;padding-bottom:0;}
    .playlists-list{display:flex;flex-direction:column;gap:8px;}
    .playlist-pill{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--card);color:var(--fg);cursor:pointer;min-width:0;transition:all .15s ease;font-size:13px;}
    .playlist-pill:hover{background:var(--border);border-color:var(--accent);transform:translateY(-1px);box-shadow:0 10px 20px rgba(0,0,0,.25);}
    .playlist-pill.active{border-color:var(--accent);box-shadow:0 0 0 1px var(--accent);background:rgba(98,245,169,0.15);}
    .playlist-pill-icon{flex-shrink:0;width:32px;height:32px;border-radius:6px;background:rgba(98,245,169,0.15);color:var(--accent);display:flex;align-items:center;justify-content:center;font-size:16px;}
    .playlist-pill-info{flex:1;min-width:0;display:flex;flex-direction:column;gap:2px;}
    .playlist-pill-name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--fg);}
    .playlist-pill-count{font-size:11px;color:var(--muted);}
    .playlist-pill .name{font-weight:600;font-size:13px;}
    .playlist-pill .meta{color:var(--muted);font-size:11px;}
    .playlist-empty{color:var(--muted);font-size:12px;}
    .playlist-create{display:flex;align-items:center;gap:6px;flex-wrap:wrap;}
    .playlist-create input{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:8px 10px;color:var(--fg);flex:1;min-width:160px;font-size:13px;}
    .playlist-create button{padding:8px 12px;border-radius:8px;cursor:pointer;font-size:12px;}

    .playlist-tracks{padding:12px;border:1px solid var(--border);border-radius:12px;background:var(--card);display:flex;flex-direction:column;gap:6px;}
    .playlist-tracks[hidden]{display:none;}
    .playlist-tracks-content{display:flex;flex-direction:column;gap:10px;}
    .playlist-tracks .playlists-header{margin-bottom:0;}
    .playlist-tracks .playlists-header h2{font-size:18px;}
    .playlist-tracks .muted{font-size:13px;}
    #playlistTracksMeta{padding:8px 12px;background:rgba(98,245,169,0.1);border:1px solid rgba(98,245,169,0.2);border-radius:8px;color:var(--accent);font-size:12px;font-weight:600;text-align:left;}
    .playlist-tracks .tracks{display:flex;flex-direction:column;gap:6px;margin:0;padding:0;list-style:none;max-height:360px;overflow-y:auto;}
    .playlist-track{display:flex;align-items:center;gap:10px;padding:6px 10px;border-radius:6px;background:transparent;border:1px solid transparent;min-height:36px;}
    .playlist-track:hover{background:#f5f5f5;border-color:rgba(0,0,0,0.07);}
    .playlist-track.playing{background:#e8f9f0;border-color:var(--accent);}
    .playlist-track .track-name{flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:14px;font-weight:600;line-height:1.4;margin:0;}
    .playlist-track .track-play{width:26px;height:26px;border-radius:4px;padding:0;font-size:12px;font-weight:600;display:inline-flex;align-items:center;justify-content:center;line-height:1;}
    .playlist-tracks.collapsed .playlist-tracks-content{display:none;}
    .playlist-tracks.collapsed .main-accordion-toggle{transform:rotate(-90deg);}
    .playlist-tracks.only-current .tracks{display:none;}
    .playlist-tracks.only-current .playlist-empty{display:none;}
    .playlist-tracks.only-current .now-playing-placeholder{display:none;}

    /* Mini Player Ribbon - styles moved to top of file */

    /* Landing placeholder */
    .landing{display:flex;align-items:center;justify-content:center;min-height:40vh;}
    .landing img{max-width:520px;max-height:520px;opacity:.9;display:block;}

    /* ======= Modal (centered track window) ======= */
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:space-evenly;background:var(--bg);z-index:100;padding:20px;padding-left:5%;padding-right:calc(260px + 40px);}
    .overlay.open{display:flex;}
    .modal-album-sleeve{width:320px;height:320px;border-radius:12px;overflow:hidden;background:#f5f5f5;border:1px solid var(--border);box-shadow:0 10px 40px rgba(0,0,0,.35);flex-shrink:0;display:none;}
    .modal-album-sleeve.show{display:block;}
    .modal-album-sleeve img{width:100%;height:100%;object-fit:cover;}
    .modal{background:var(--card);border:1px solid var(--border);border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.35);width:min(450px,90vw);max-height:85vh;display:flex;flex-direction:column;overflow:hidden;}
    @media (max-width: 900px) {
      .overlay{flex-direction:column;gap:12px;padding-left:5%;padding-right:20px;justify-content:center;}
      .modal-album-sleeve{width:200px;height:200px;}
    }
    @media (max-width: 640px) {
      .overlay{padding-left:20px;padding-right:20px;}
      .modal-album-sleeve.show{display:none;}
    }

    /* ======= Image Lightbox ======= */
    .image-lightbox{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.9);z-index:200;}
    .image-lightbox.open{display:flex;}
    .image-lightbox-close{position:absolute;top:20px;right:20px;width:48px;height:48px;border-radius:50%;background:rgba(255,255,255,0.1);border:none;color:#fff;font-size:32px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:background 0.2s ease;}
    .image-lightbox-close:hover{background:rgba(255,255,255,0.2);}
    .image-lightbox img{max-width:90vw;max-height:90vh;object-fit:contain;}
    .modal header{display:flex;align-items:center;gap:8px;padding:8px 10px;border-bottom:1px solid var(--border);background:#f8f8f8;position:sticky;top:0;z-index:1;}
    .modal .cover-wrap{width:40px;height:40px;margin:0;display:none !important;}
    .modal .meta{display:flex;flex-direction:column;gap:2px;min-width:0;}
    .modal h2{margin:0;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .modal .sub{color:var(--muted);font-size:11px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;}
    .modal .spacer{flex:1;}
    .modal .close{border-radius:8px;padding:6px 8px;cursor:pointer;font-size:13px;}
    .modal .content{padding:10px;overflow:auto;}
    .album-actions{display:flex;justify-content:flex-end;gap:6px;margin:0 0 8px;}
    .album-actions .btn{white-space:nowrap;font-size:12px;padding:6px 10px;}
    .tracks{margin:0;padding:0;list-style:none;display:flex;flex-direction:column;gap:6px;}
    .track{background:#f8f8f8;padding:6px 8px;border-radius:6px;display:flex;flex-direction:column;gap:4px;}
    .track.loading{opacity:0.75;}
    .track.loading .btn.small{pointer-events:none;}
    .track-top{display:flex;align-items:center;justify-content:space-between;gap:8px;}
    .track-title{display:flex;flex-direction:column;flex:1;min-width:0;}
    .track .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;}
    .track .artist{color:var(--muted);font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .controls{display:flex;align-items:center;gap:4px;}
    .playing{outline:1px solid var(--accent); background:#e8f9f0;}
    .progress{display:flex;align-items:center;gap:6px;margin-top:4px;}
    .seek{appearance:none;width:180px;height:6px;background:linear-gradient(var(--accent),var(--accent)) 0/var(--fill,0%) 100% no-repeat,#e5f5ec;border-radius:999px;outline:none;border:1px solid var(--accent);}
    .seek::-webkit-slider-thumb{appearance:none;width:10px;height:10px;border-radius:50%;background:var(--accent);}
    .time{font-size:11px;color:var(--muted);min-width:80px;text-align:right;}
    .no-scroll{overflow:hidden;}

    /* More by Artist section in modal */
    .more-by-artist{background:#f8f8f8;border-top:1px solid var(--border);padding:12px;display:flex;flex-direction:column;gap:10px;max-height:280px;overflow-y:auto;}
    .more-by-artist[hidden]{display:none;}
    .more-by-artist-title{margin:0;font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;font-weight:600;}
    .more-by-artist-grid{display:flex;flex-direction:column;gap:8px;}
    .more-by-artist::-webkit-scrollbar{width:6px;}
    .more-by-artist::-webkit-scrollbar-thumb{background:rgba(0,0,0,0.15);border-radius:999px;}
    .more-by-artist-item{display:flex;align-items:center;gap:8px;padding:6px;background:var(--card);border:1px solid var(--border);border-radius:8px;cursor:pointer;transition:background 0.15s ease,border-color 0.15s ease;}
    .more-by-artist-item:hover{background:#f0f0f0;border-color:var(--accent);}
    .more-by-artist-item img{width:40px;height:40px;border-radius:6px;object-fit:cover;background:#f5f5f5;}
    .more-by-artist-item-info{flex:1;min-width:0;display:flex;flex-direction:column;gap:2px;}
    .more-by-artist-item-title{font-size:12px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .more-by-artist-item-meta{font-size:10px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

    .info-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:150;}
    .info-modal-overlay.open{display:flex;}
    .info-modal{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:18px 20px;width:min(480px,92vw);max-height:80vh;overflow:auto;box-shadow:0 18px 48px rgba(0,0,0,.4);}
    .info-modal header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:12px;}
    .info-modal h3{margin:0;font-size:18px;}
    .info-modal .info-close{border-radius:8px;padding:6px 10px;cursor:pointer;}
    .info-modal dl{margin:0;display:grid;grid-template-columns:minmax(120px,auto) 1fr;gap:10px 14px;font-size:14px;}
    .info-modal dt{font-weight:600;color:var(--muted);}
    .info-modal dd{margin:0;}
    .info-modal-empty{color:var(--muted);font-style:italic;text-align:center;margin:12px 0;}

    /* Busy / searching status indicator */
    .status{display:inline-flex;align-items:center;gap:8px;margin-left:8px;color:var(--muted);font-size:13px;}
    .status[hidden]{display:none;}
    .status .pulse{width:8px;height:8px;border-radius:50%;background:var(--accent);
      box-shadow:0 0 0 0 rgba(98,245,169,.7);animation:pulse 1.3s infinite;}
    @keyframes pulse{
      0%{transform:scale(.9);box-shadow:0 0 0 0 rgba(98,245,169,.7);}
      70%{transform:scale(1);box-shadow:0 0 0 10px rgba(98,245,169,0);}
      100%{transform:scale(.9);box-shadow:0 0 0 0 rgba(98,245,169,0);}
        }
    .btn,
    .searchbar button,
    .pager button,
    .explore-buttons button,
    .modal .close,
    .info-modal .info-close,
    #explore {
      background:linear-gradient(135deg,var(--btn-gradient-start),var(--btn-gradient-end));
      color:var(--btn-text);
      border:none;
      box-shadow:0 6px 18px var(--btn-shadow);
      transition:transform 0.15s ease,box-shadow 0.15s ease,opacity 0.15s ease;
    }

    .btn:hover,
    .searchbar button:hover,
    .pager button:hover,
    .explore-buttons button:hover,
    .modal .close:hover,
    .info-modal .info-close:hover,
    #explore:hover {
      transform:translateY(-1px);
      box-shadow:0 8px 20px var(--btn-shadow-hover);
    }

    .btn:active,
    .searchbar button:active,
    .pager button:active,
    .explore-buttons button:active,
    .modal .close:active,
    .info-modal .info-close:active,
    #explore:active {
      transform:translateY(0);
      box-shadow:0 5px 14px var(--btn-shadow);
    }

    button:disabled{opacity:.6;cursor:not-allowed;transform:none !important;box-shadow:none !important;}

    /* Fix playlist row layout: keep items in a row next to the play button */
    .track.playlist-track {
      flex-direction: row;       /* override .track { flex-direction: column } */
      align-items: center;
      gap: 0.5rem;               /* keep a little space between button and text */
    }

    /* Ensure the text can shrink and ellipsis correctly in a flex row */
    .playlist-track .track-name {
      flex: 1;
      min-width: 0;              /* required so text-overflow works inside flex */
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .playlist-track .track-name-artist {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .playlist-track .track-name-title {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Access Token Entry Screen */
    .access-token-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 24px;
    }
    .access-token-overlay.hidden {
      display: none;
    }
    .access-token-box {
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: 16px;
      padding: 32px;
      max-width: 480px;
      width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    .access-token-title {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 12px;
      color: var(--accent);
    }
    .access-token-subtitle {
      font-size: 16px;
      color: var(--muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .access-token-input {
      width: 100%;
      padding: 14px 18px;
      font-size: 16px;
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 10px;
      color: var(--fg);
      text-align: center;
      font-family: monospace;
      text-transform: uppercase;
      margin-bottom: 16px;
      transition: border-color 0.2s ease;
    }
    .access-token-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(98,245,169,0.15);
    }
    .access-token-submit {
      width: 100%;
      padding: 14px 24px;
      font-size: 16px;
      font-weight: 600;
      background: var(--accent);
      color: var(--btn-text);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: filter 0.2s ease;
    }
    .access-token-submit:hover {
      filter: brightness(1.1);
    }
    .access-token-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .access-token-error {
      color: #ff4444;
      font-size: 14px;
      margin-top: 12px;
      display: none;
    }
    .access-token-error.show {
      display: block;
    }
    .access-token-info {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 13px;
      color: var(--muted);
      z-index: 100;
      max-width: 280px;
    }
    .access-token-info.hidden {
      display: none;
    }
    .access-token-info strong {
      color: var(--fg);
      display: block;
      margin-bottom: 4px;
    }

    /* Cookie Notice Banner */
    .cookie-notice {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(23, 24, 28, 0.98);
      border-top: 1px solid var(--border);
      padding: 16px 20px;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      backdrop-filter: blur(10px);
      animation: slideUp 0.3s ease-out;
    }
    .cookie-notice.hidden {
      display: none;
    }
    .cookie-notice-content {
      display: flex;
      align-items: center;
      gap: 20px;
      max-width: 1100px;
      width: 100%;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    .cookie-notice-text {
      font-size: 14px;
      color: #ffffff;
      line-height: 1.5;
      flex: 1;
      min-width: 280px;
    }
    .cookie-notice-text a {
      color: var(--accent);
      text-decoration: none;
      font-weight: 500;
    }
    .cookie-notice-text a:hover {
      text-decoration: underline;
    }
    .cookie-notice-btn {
      background: var(--accent);
      color: var(--btn-text);
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      transition: filter 0.2s ease;
    }
    .cookie-notice-btn:hover {
      filter: brightness(1.1);
    }
    @keyframes slideUp {
      from {
        transform: translateY(100%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Subscription Toast */
    .subscription-toast {
      position: fixed;
      bottom: 80px;
      right: 24px;
      background: linear-gradient(135deg, var(--card) 0%, #1f2127 100%);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px 20px;
      min-width: 320px;
      max-width: 420px;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.5);
      z-index: 9998;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.4s ease, transform 0.4s ease;
      font-size: 15px;
      font-weight: 500;
      line-height: 1.5;
      color: var(--fg);
    }
    .subscription-toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    .subscription-toast-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .subscription-toast-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--fg);
    }
    .subscription-toast-body {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    .subscription-toast-body:hover {
      opacity: 0.85;
    }
    @media (max-width: 640px) {
      .subscription-toast {
        bottom: 20px;
        right: 16px;
        left: 16px;
        min-width: auto;
        max-width: none;
      }
    }

    /* Share/Export/Import Playlist Modals */
    .share-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:150;}
    .share-modal-overlay.open{display:flex;}
    .share-modal{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:24px;width:min(520px,92vw);box-shadow:0 18px 48px rgba(0,0,0,.4);}
    .share-modal h3{margin:0 0 8px;font-size:18px;}
    .share-modal p{margin:0 0 16px;color:var(--muted);font-size:14px;}
    .share-modal input{width:100%;background:var(--bg);color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:12px;font-size:14px;font-family:monospace;margin-bottom:16px;}
    .share-modal textarea{width:100%;background:var(--bg);color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:12px;font-size:14px;font-family:monospace;margin-bottom:12px;resize:vertical;}
    .share-modal input:focus{outline:2px solid var(--accent);outline-offset:2px;}
    .share-modal textarea:focus{outline:2px solid var(--accent);outline-offset:2px;}
    .share-modal .actions{display:flex;gap:10px;justify-content:flex-end;}
    .share-modal .btn{min-width:100px;}

    /* Hide Missing Audio Mode Banner */
    .missing-mode-banner{display:none;}

    /* AI Search Panel */
    .ai-search-panel{position:relative;flex:0 0 auto;margin-top:0;}
    .ai-search-toggle{display:flex;align-items:center;gap:6px;padding:7px 12px;border:1px solid rgba(255,255,255,0.2);border-radius:999px;background:transparent;color:var(--fg);font-size:12px;font-weight:600;cursor:pointer;transition:border-color 0.2s ease,color 0.2s ease;}
    .ai-search-toggle:hover{border-color:var(--accent);color:var(--accent);}
    .ai-search-toggle strong{display:inline;font-size:12px;font-weight:600;}
    .ai-search-chevron{font-size:12px;color:var(--muted);transition:transform 0.2s ease;}
    .ai-search-panel[data-collapsed="true"] .ai-search-body{display:none;}
    .ai-search-panel[data-collapsed="false"] .ai-search-chevron{transform:rotate(90deg);}
    .ai-search-body{position:absolute;top:calc(100% + 8px);right:0;z-index:15;width:min(420px,calc(100vw - 48px));background:rgba(10,14,20,0.95);border:1px solid rgba(255,255,255,0.1);border-radius:14px;padding:14px;display:flex;flex-direction:column;gap:10px;box-shadow:0 10px 30px rgba(0,0,0,0.4);}
    .ai-search-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .ai-search-row input{flex:1;min-width:200px;background:var(--card);color:var(--fg);border:1px solid var(--border);border-radius:999px;padding:10px 16px;font-size:15px;}
    .ai-search-row input:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(98,245,169,0.15);}
    .ai-search-row button{height:40px;padding:0 18px;border-radius:999px;}
    .ai-search-status{display:flex;align-items:center;gap:8px;font-size:13px;color:var(--muted);}
    .ai-search-status[hidden]{display:none;}
    .ai-search-status .pulse{width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 0 rgba(98,245,169,.6);animation:pulse 1.6s infinite;}
    .ai-search-interpretation{font-size:12px;color:var(--fg);background:rgba(98,245,169,0.05);border:1px solid rgba(98,245,169,0.2);padding:8px 12px;border-radius:10px;}
    .ai-search-interpretation[hidden]{display:none;}

  </style>
</head>
<body>

  <!-- Mobile Device Detection & Redirect -->
  <script>
    (function() {
      // Check if user is on mobile device
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isSmallScreen = window.innerWidth <= 768;

      // Redirect mobile users to /mobile unless they explicitly want desktop view
      if ((isMobile || isSmallScreen) && !sessionStorage.getItem('forceDesktopView')) {
        window.location.href = '/mobile';
      }
    })();
  </script>

  <!-- Access Token Entry Overlay -->
  <div class="access-token-overlay hidden" id="accessTokenOverlay">
    <div class="access-token-box">
      <div class="access-token-title">Welcome to MASS</div>
      <div class="access-token-subtitle">
        Please enter your access token to continue
      </div>
      <form id="accessTokenForm" onsubmit="return false;">
        <input
          type="text"
          id="accessTokenInput"
          class="access-token-input"
          placeholder="MASS-XXXX-XXXXXX"
          autocomplete="off"
          spellcheck="false"
        />
        <button type="submit" class="access-token-submit" id="accessTokenSubmit">
          Activate Access
        </button>
        <div class="access-token-error" id="accessTokenError"></div>
      </form>
    </div>
  </div>

  <!-- Access Token Info Display (shown when logged in) -->
  <div class="access-token-info hidden" id="accessTokenInfo">
    <strong>Access Token</strong>
    <div id="accessTokenStatus"></div>
    <button id="resetAppBtn" style="margin-top:8px;font-size:11px;padding:4px 8px;background:var(--border);border:1px solid var(--muted);border-radius:6px;color:var(--muted);cursor:pointer;">Reset App</button>
  </div>

  <!-- Cookie Notice Banner -->
  <div class="cookie-notice hidden" id="cookieNotice">
    <div class="cookie-notice-content">
      <div class="cookie-notice-text">
        This site uses cookies for authentication and session management. By continuing to use this service, you accept our use of cookies.
      </div>
      <button class="cookie-notice-btn" id="cookieNoticeBtn">Got it!</button>
    </div>
  </div>

  <div class="app-wrapper">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-logo">
        <img src="/img/Madmusiclogonew.png" alt="MAD - Music Africa Direct">
      </div>

      <nav class="sidebar-nav">
        <!-- Home -->
        <a href="/" class="nav-item">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
          </svg>
          Home
        </a>

        <!-- Library Section -->
        <div class="nav-section" id="librarySection">
          <div class="nav-section-header" onclick="toggleNavSection('librarySection')">
            <span>Library</span>
            <span class="chevron">&#9650;</span>
          </div>
          <div class="nav-section-content">
            <a href="/library?tab=songs" class="nav-item">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
              </svg>
              Songs
            </a>
            <a href="/library?tab=albums" class="nav-item">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49 0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-5.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"/>
              </svg>
              Albums
            </a>
          </div>
        </div>

        <!-- Playlists Section -->
        <div class="nav-section" id="playlistsSection">
          <div class="nav-section-header" onclick="toggleNavSection('playlistsSection')">
            <span>Playlists</span>
            <span class="chevron">&#9650;</span>
          </div>
          <div class="nav-section-content">
            <!-- Dynamic user playlists -->
            <div id="sidebarMyPlaylists">
              <ul id="sidebarMyPlaylistsList" style="list-style:none;padding:0;margin:0;"></ul>
              <div id="sidebarMyPlaylistsEmpty" hidden style="padding:6px 20px;font-size:12px;color:var(--muted);">No playlists yet</div>
            </div>
            <!-- Create New Playlist -->
            <button class="nav-item" id="createPlaylistBtn" style="color: var(--accent);">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
              </svg>
              Create New Playlist
            </button>
          </div>
        </div>

      </nav>
    </aside>

    <script>
      function toggleNavSection(sectionId) {
        const section = document.getElementById(sectionId);
        section.classList.toggle('collapsed');
      }
    </script>

    <div class="main-wrapper">
  <header>
    <div class="header-main">
      <div class="searchbar">
        <div class="search-fields" id="searchFields">
          <input id="searchArtist" type="search" placeholder="Artist" autocomplete="off" />
          <input id="searchAlbum" type="search" placeholder="Album" autocomplete="off" />
          <input id="searchTrack" type="search" placeholder="Track" autocomplete="off" />
          <select id="searchDecade" style="padding:8px 12px;border-radius:8px;border:1px solid var(--border);background:var(--card);color:var(--fg);font-size:13px;cursor:pointer;">
            <option value="">All Decades</option>
            <option value="1950s">1950s</option>
            <option value="1960s">1960s</option>
            <option value="1970s">1970s</option>
            <option value="1980s">1980s</option>
            <option value="1990s">1990s</option>
            <option value="2000s">2000s</option>
            <option value="2010s">2010s</option>
            <option value="2020s">2020s</option>
          </select>
          <select id="searchGenre" style="padding:8px 12px;border-radius:8px;border:1px solid var(--border);background:var(--card);color:var(--fg);font-size:13px;cursor:pointer;">
            <option value="">All Genres</option>
            <option value="60's">60's</option>
            <option value="70's">70's</option>
            <option value="80's">80's</option>
            <option value="90's">90's</option>
            <option value="Adult Contemporary">Adult Contemporary</option>
            <option value="African">African</option>
            <option value="African Jazz">African Jazz</option>
            <option value="Amapiano">Amapiano</option>
            <option value="Afro Beat">Afro Beat</option>
            <option value="Afro-Folk">Afro-Folk</option>
            <option value="Afro Fusion">Afro Fusion</option>
            <option value="Afro House">Afro House</option>
            <option value="Afro Jazz">Afro Jazz</option>
            <option value="Afro Pop">Afro Pop</option>
            <option value="Afro Soul">Afro Soul</option>
            <option value="Blues">Blues</option>
            <option value="Classical">Classical</option>
            <option value="Country">Country</option>
            <option value="Dance">Dance</option>
            <option value="Disco">Disco</option>
            <option value="Electronic">Electronic</option>
            <option value="Folk">Folk</option>
            <option value="Funk">Funk</option>
            <option value="Gospel">Gospel</option>
            <option value="Gqom">Gqom</option>
            <option value="Hip Hop">Hip Hop</option>
            <option value="Jazz">Jazz</option>
            <option value="Kwaito">Kwaito</option>
            <option value="Latin">Latin</option>
            <option value="Maskandi">Maskandi</option>
            <option value="Pop">Pop</option>
            <option value="R & B/Soul">R &amp; B/Soul</option>
            <option value="Reggae">Reggae</option>
            <option value="RnB">RnB</option>
            <option value="Rock">Rock</option>
            <option value="Soul">Soul</option>
            <option value="World">World</option>
          </select>
        </div>
        <div>
          <input id="search" type="search" placeholder="Search albums, artists, tracks, year, genreâ€¦" autocomplete="off" hidden />
          <button id="go">Search</button>
          <button id="clear">Clear</button>
          <span id="status" class="status" hidden aria-live="polite" role="status"><span class="pulse"></span><span id="statusText">Searchingâ€¦</span></span>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end;">
        <div class="header-actions">
          <div class="ai-search-panel" id="aiSearchPanel" data-collapsed="true">
            <button id="aiSearchToggle" type="button" class="ai-search-toggle" aria-expanded="false" aria-controls="aiSearchPanelBody" aria-label="Toggle AI natural language search panel">
              <strong>AI Search</strong>
              <span class="ai-search-chevron">â–¸</span>
            </button>
            <div class="ai-search-body" id="aiSearchPanelBody">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                <span style="font-size:13px;font-weight:600;color:var(--fg);">AI Natural Language Search</span>
                <button id="aiSearchClose" type="button" style="background:transparent;border:none;color:var(--muted);font-size:20px;cursor:pointer;padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:4px;" aria-label="Close AI search">&times;</button>
              </div>
              <div class="ai-search-row">
                <input id="aiSearchInput" type="search" placeholder="Describe the vibe, genre, instruments, year, or metadataâ€¦" autocomplete="off" />
                <button id="aiSearchButton" type="button" class="btn">Ask AI</button>
              </div>
              <div id="aiSearchStatus" class="ai-search-status" hidden aria-live="polite" role="status">
                <span class="pulse"></span>
                <span id="aiSearchStatusText">Asking FileMaker for matchesâ€¦</span>
              </div>
              <div id="aiSearchInterpretation" class="ai-search-interpretation" hidden></div>
            </div>
          </div>
        </div>
        <div id="authControls" class="auth-controls">
          <span id="userBadge" class="badge" hidden></span>
          <button id="logoutButton" type="button" class="btn" hidden>Log out</button>
        </div>
        <!-- Header Icons -->
        <div class="header-icons">
          <button class="header-icon-btn" id="notificationBtn" title="Notifications">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
              <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
            </svg>
          </button>
          <button class="header-profile-btn" id="profileBtn" title="Profile">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </header>

  <div class="explore-wrap" style="display:none !important;">
    <button id="explore" type="button" aria-expanded="false" style="display:none !important;">Explore</button>
    <div id="explorePanel" class="explore-panel" hidden>
      <section class="explore-section">
        <h3>Decades</h3>
        <div id="exploreDecades" class="explore-buttons"></div>
      </section>
      <section class="explore-section">
        <h3>Genres</h3>
        <div id="exploreGenres" class="explore-buttons"></div>
      </section>
      <section class="explore-section">
        <h3>Moods</h3>
        <div id="exploreMoods" class="explore-buttons"></div>
      </section>
    </div>
  </div>

  <div class="missing-mode-banner">ðŸ” MISSING AUDIO MODE - Showing albums with no valid audio (Press Ctrl+Shift+M to refresh â€¢ Escape to exit)</div>

  <main>
    <!-- Playlist View (Two-Column Layout) -->
    <div id="playlistView" class="playlist-view">
      <div class="playlist-view-header">
        <div class="playlist-view-header-top">
          <button class="playlist-back-btn" id="playlistBackBtn" title="Back to albums">
            <svg viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
          </button>
          <div class="playlist-view-titles">
            <h1 class="playlist-view-title" id="playlistViewTitle">Playlist</h1>
            <p class="playlist-view-subtitle">Playlist</p>
          </div>
        </div>
      </div>
      <div class="playlist-view-content">
        <!-- Left Column - Album List -->
        <div class="playlist-albums-list" id="playlistAlbumsList">
          <!-- Albums will be populated here -->
        </div>

        <!-- Right Column - Selected Album Details -->
        <div class="playlist-album-detail" id="playlistAlbumDetail">
          <div class="playlist-detail-header">
            <div class="playlist-detail-artwork">
              <img id="playlistDetailArtwork" src="/img/placeholder.jpg" alt="Album artwork">
            </div>
            <div class="playlist-detail-info">
              <h2 class="playlist-detail-title" id="playlistDetailTitle">Select an album</h2>
              <p class="playlist-detail-artist" id="playlistDetailArtist">Artist</p>
              <div class="playlist-detail-meta">
                <span class="playlist-detail-genre" id="playlistDetailGenre">GENRE</span>
                <span class="playlist-detail-year" id="playlistDetailYear">Year</span>
              </div>
              <div class="playlist-detail-stats">
                <span class="playlist-detail-stat">
                  <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                  <span id="playlistDetailPlays">0</span>
                </span>
                <span class="playlist-detail-stat">
                  <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
                  <span id="playlistDetailRepeats">0</span>
                </span>
              </div>
              <div class="album-action-buttons" id="albumActionButtons">
                <button class="album-action-btn" id="addAlbumToPlaylistBtn" title="Add all tracks to a playlist">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg>
                  + Playlist
                </button>
                <button class="album-action-btn" id="addAlbumToLibraryBtn" title="Save album to your library">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                  â™¡ Albums
                </button>
              </div>
            </div>
          </div>
          <div class="playlist-track-list" id="playlistTrackList">
            <!-- Tracks will be populated here -->
          </div>
        </div>
      </div>
    </div>

    <div class="layout-grid">
      <section class="content-column">
        <div class="toolbar">
          <div id="count" class="count"></div>
        </div>
        <section id="publicPlaylistView" class="public-playlist-view" hidden>
          <div class="public-playlist-header">
            <div style="display:flex;flex-direction:column;gap:4px;flex:1;min-width:0;">
              <h2 id="publicPlaylistTitle" class="public-playlist-title">Recommended Playlist</h2>
              <span id="publicPlaylistMeta" class="public-playlist-status"></span>
            </div>
            <button id="closePublicPlaylistBtn" class="btn small" type="button" aria-label="Close playlist">&times;</button>
          </div>
          <div id="publicPlaylistStatus" class="public-playlist-status" hidden></div>
          <div id="publicPlaylistHero" class="public-playlist-hero" hidden>
            <img id="publicPlaylistArt" alt="Playlist artwork" loading="lazy" decoding="async" />
          </div>
          <ul id="publicPlaylistTracks" class="tracks public-playlist-tracks"></ul>
          <div id="publicPlaylistEmpty" class="playlist-empty" hidden>No tracks in this playlist.</div>
        </section>
        <section id="sharedPlaylistView" class="public-playlist-view" hidden>
          <div class="public-playlist-header">
            <h2 id="sharedPlaylistTitle" class="public-playlist-title">Playlist</h2>
            <span id="sharedPlaylistMeta" class="public-playlist-status"></span>
          </div>
          <div id="sharedPlaylistStatus" class="public-playlist-status" hidden></div>
          <div id="sharedPlaylistHero" class="public-playlist-hero" hidden>
            <img id="sharedPlaylistArt" alt="Playlist artwork" loading="lazy" decoding="async" />
          </div>
          <ul id="sharedPlaylistTracks" class="tracks public-playlist-tracks"></ul>
          <div id="sharedPlaylistEmpty" class="playlist-empty" hidden>No tracks are available in this shared playlist.</div>
          <div class="shared-playlist-actions">
            <button id="sharedPlaylistBack" type="button" class="btn small">Close</button>
            <button id="sharedPlaylistCopy" type="button" class="btn small">Copy share link</button>
          </div>
        </section>
        <div id="loadingIndicator" class="loading-indicator">
          <img src="/img/placeholder.png" alt="" class="loading-background" loading="lazy" decoding="async" />
          <div class="loading-spinner"></div>
          <div class="loading-text">Loading albums...</div>
        </div>
        <div id="albums" class="albums"></div>
        <div id="pager" class="pager" hidden>
          <button id="prev">â—€ Prev</button>
          <span id="pageInfo" class="badge">Page 1</span>
          <button id="next">Next â–¶</button>
        </div>
        <div id="loadMoreContainer" style="text-align: center; padding: 20px;" hidden>
          <button id="loadMoreBtn" class="btn" style="padding: 12px 24px; font-size: 14px;">
            Next Page â†’
          </button>
          <div style="margin-top: 8px; color: var(--muted); font-size: 12px;" id="loadMoreInfo"></div>
        </div>
        <div id="error" class="error" hidden></div>
      </section>
    </div>
  </main>

  <!-- Mini Player Ribbon -->
  <div class="mini-player" id="miniPlayer">
    <!-- Left: Album Art + Track Info -->
    <div class="mini-player-left">
      <div class="mini-player-artwork" id="nowPlayingThumb">
        <img src="" alt="Album artwork" id="nowPlayingThumbImg">
      </div>
      <div class="mini-player-info">
        <div class="mini-player-title" id="nowPlayingTitle"></div>
        <div class="mini-player-artist" id="nowPlayingSubtitle"></div>
      </div>
    </div>

    <!-- Center: Controls & Progress -->
    <div class="mini-player-center">
      <button class="player-btn" id="playerPrev" title="Previous">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
        </svg>
      </button>
      <button class="player-btn play-pause" id="nowPlayingToggle" title="Play/Pause">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" id="playIcon">
          <path d="M8 5v14l11-7z"/>
        </svg>
      </button>
      <button class="player-btn" id="playerNext" title="Next">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
        </svg>
      </button>
      <div class="player-progress-bar" id="playerProgressBar">
        <div class="player-progress-fill" id="nowPlayingProgressFill"></div>
      </div>
      <span class="player-time" id="playerCurrentTime">0:00</span>
    </div>

    <!-- Right: Volume -->
    <div class="mini-player-right">
      <button class="player-volume-btn" id="volumeBtn" title="Volume">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
      </button>
      <div class="player-volume-slider" id="volumeSlider">
        <div class="player-volume-fill" id="volumeFill"></div>
      </div>
    </div>
  </div>

  <!-- Single centered modal (reused for all albums) -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div id="modalAlbumSleeve" class="modal-album-sleeve"></div>
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <header>
        <div id="modalCover" class="cover-wrap" aria-hidden="true"></div>
        <div class="meta">
          <h2 id="modalTitle">Album</h2>
          <div class="sub">
            <span id="modalArtist"></span>
            <span id="modalYear" class="badge"></span>
            <span id="modalCat" class="badge"></span>
          </div>
        </div>
        <div class="spacer"></div>
        <button id="modalClose" class="close" aria-label="Close">âœ•</button>
          </header>
      <div id="modalContent" class="content"></div>
      <div id="moreByArtist" class="more-by-artist" hidden>
        <h3 class="more-by-artist-title">More by this artist</h3>
        <div id="moreByArtistGrid" class="more-by-artist-grid"></div>
      </div>
    </div>
  </div>

  <div id="trackInfoOverlay" class="info-modal-overlay" hidden>
    <div id="trackInfoDialog" class="info-modal" role="dialog" aria-modal="true" aria-labelledby="trackInfoTitle">
      <header>
        <h3 id="trackInfoTitle">More info</h3>
        <button type="button" id="trackInfoClose" class="info-close">Close</button>
      </header>
      <div id="trackInfoBody"></div>
    </div>
  </div>

  <div id="authOverlay" class="info-modal-overlay" hidden>
    <div id="authDialog" class="info-modal" role="dialog" aria-modal="true" aria-labelledby="authTitle">
      <header>
        <h3 id="authTitle">Log in</h3>
        <button type="button" id="authClose" class="info-close">Close</button>
      </header>
      <form id="authForm" class="auth-form">
        <label for="authEmail">
          <span>Email</span>
          <input id="authEmail" type="email" name="email" autocomplete="email" required />
        </label>
        <label for="authPassword">
          <span>Password</span>
          <input id="authPassword" type="password" name="password" autocomplete="current-password" minlength="8" required />
        </label>
        <button type="submit" id="authSubmit" class="btn btn-accent">Log in</button>
      </form>
      <div class="auth-switch">
        <span id="authToggleText">Need an account?</span>
        <button type="button" id="authSwitchMode">Subscribe</button>
      </div>
      <div id="authError" class="error" hidden></div>
    </div>
  </div>

  <div id="shareModal" class="share-modal-overlay">
    <div class="share-modal" role="dialog" aria-modal="true" aria-labelledby="shareModalTitle">
      <h3 id="shareModalTitle">Share Playlist</h3>
      <p>Copy this link to share your playlist:</p>
      <input id="shareLinkInput" type="text" readonly />
      <div class="actions">
        <button type="button" id="shareModalClose" class="btn small">Close</button>
      </div>
    </div>
  </div>

  <div id="exportModal" class="share-modal-overlay">
    <div class="share-modal" role="dialog" aria-modal="true" aria-labelledby="exportModalTitle">
      <h3 id="exportModalTitle">Export Playlist</h3>
      <p>Copy the compact code or download as JSON file:</p>
      <input id="exportCodeInput" type="text" readonly />
      <div class="actions">
        <button type="button" id="exportDownloadBtn" class="btn small">Download JSON</button>
        <button type="button" id="exportCopyBtn" class="btn small">Copy Code</button>
        <button type="button" id="exportModalClose" class="btn small">Close</button>
      </div>
    </div>
  </div>

  <div id="importModal" class="share-modal-overlay">
    <div class="share-modal" role="dialog" aria-modal="true" aria-labelledby="importModalTitle">
      <h3 id="importModalTitle">Import Playlist</h3>
      <p>Paste a compact code (MASS:...) or upload a JSON file:</p>
      <textarea id="importCodeInput" placeholder="Paste MASS:... code here" rows="4" style="width:100%;background:var(--bg);color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:12px;font-size:14px;font-family:monospace;margin-bottom:12px;resize:vertical;"></textarea>
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
        <span style="color:var(--muted);font-size:14px;">or</span>
        <input type="file" id="importFileInput" accept=".json" style="flex:1;font-size:14px;" />
      </div>
      <div id="importStatus" style="color:var(--muted);font-size:13px;margin-bottom:12px;min-height:20px;"></div>
      <div class="actions">
        <button type="button" id="importSubmitBtn" class="btn small">Import</button>
        <button type="button" id="importModalClose" class="btn small">Close</button>
      </div>
    </div>
  </div>

  <audio id="player" preload="none"></audio>

  <!-- Image Lightbox for enlarged album artwork -->
  <div id="imageLightbox" class="image-lightbox" aria-hidden="true">
    <button id="imageLightboxClose" class="image-lightbox-close" aria-label="Close">&times;</button>
    <img id="imageLightboxImg" alt="Album artwork" loading="lazy" decoding="async" />
  </div>


  <script>
    // Initialize Home Page Content (Major Releases & Highlights)
    async function initializeHomePage() {
      try {
        // Fetch featured albums for Major Releases
        const response = await fetch('/api/featured-albums?limit=10');
        if (response.ok) {
          const data = await response.json();
          const items = data.items || [];

          // Transform the data to a cleaner format
          const albums = items.map(item => {
            const fields = item.fields || {};
            return {
              title: fields['Tape Files::Album Title'] || fields['Album Title'] || 'Unknown Album',
              artist: fields['Tape Files::Album Artist'] || fields['Album Artist'] || 'Unknown Artist',
              artworkUrl: fields['Tape Files::Artwork_S3_URL'] || fields['Artwork::Picture'] || '/img/placeholder.jpg',
              year: fields['Year of Release'] || '',
              genre: fields['Genre'] || ''
            };
          });

          // Remove duplicates based on title+artist
          const uniqueAlbums = albums.filter((album, index, self) =>
            index === self.findIndex(a => a.title === album.title && a.artist === album.artist)
          );

          populateMajorReleases(uniqueAlbums);

          // Use first album for highlight if available
          if (uniqueAlbums.length > 0) {
            populateHighlight(uniqueAlbums[0]);
          }
        }
      } catch (err) {
        console.log('[Home] Could not load home content:', err);
      }
    }

    function populateMajorReleases(albums) {
      const carousel = document.getElementById('releasesCarousel');
      if (!carousel) return;

      carousel.innerHTML = albums.map(album => {
        const artUrl = album.artworkUrl || '/img/placeholder.jpg';
        const title = album.title || 'Unknown Album';
        const artist = album.artist || 'Unknown Artist';

        return `
          <div class="release-card" data-album="${encodeURIComponent(title)}" data-artist="${encodeURIComponent(artist)}">
            <div class="release-card-bg" style="background-image: url('${artUrl}')"></div>
            <div class="release-card-overlay"></div>
            <div class="release-card-content">
              <h3 class="release-card-title">${title}</h3>
              <p class="release-card-artist">${artist}</p>
            </div>
          </div>
        `;
      }).join('');

      // Add click handlers to cards
      carousel.querySelectorAll('.release-card').forEach(card => {
        card.addEventListener('click', () => {
          const albumTitle = decodeURIComponent(card.dataset.album);
          const artistName = decodeURIComponent(card.dataset.artist);
          // Trigger search for this album
          const searchAlbum = document.getElementById('searchAlbum');
          const searchArtist = document.getElementById('searchArtist');
          const goBtn = document.getElementById('go');
          if (searchAlbum && goBtn) {
            searchAlbum.value = albumTitle;
            if (searchArtist) searchArtist.value = artistName;
            document.getElementById('searchFields').hidden = false;
            goBtn.click();
          }
        });
      });

      // Carousel navigation
      const prevBtn = document.getElementById('releasesPrev');
      const nextBtn = document.getElementById('releasesNext');

      if (prevBtn && nextBtn) {
        prevBtn.addEventListener('click', () => {
          carousel.scrollBy({ left: -240, behavior: 'smooth' });
        });
        nextBtn.addEventListener('click', () => {
          carousel.scrollBy({ left: 240, behavior: 'smooth' });
        });
      }
    }

    function populateHighlight(album) {
      const banner = document.getElementById('highlightBanner');
      const bannerBg = document.getElementById('highlightBannerBg');
      const titleEl = document.getElementById('highlightTitle');
      const subtitleEl = document.getElementById('highlightSubtitle');

      if (banner && album) {
        const artUrl = album.artworkUrl || '/img/placeholder.jpg';
        const albumTitle = album.title || 'Featured Album';
        const artist = album.artist || 'Discover new music';

        if (bannerBg) bannerBg.style.backgroundImage = `url('${artUrl}')`;
        if (titleEl) titleEl.textContent = albumTitle;
        if (subtitleEl) subtitleEl.textContent = artist;

        banner.addEventListener('click', () => {
          const searchAlbum = document.getElementById('searchAlbum');
          const goBtn = document.getElementById('go');
          if (searchAlbum && goBtn) {
            searchAlbum.value = albumTitle;
            document.getElementById('searchFields').hidden = false;
            goBtn.click();
          }
        });
      }
    }

    // Initialize home page on load
    document.addEventListener('DOMContentLoaded', initializeHomePage);

    // Playlist View Functionality
    function showPlaylistView(playlistName, tracks) {
      const playlistView = document.getElementById('playlistView');
      const layoutGrid = document.querySelector('.layout-grid');
      const playlistTitle = document.getElementById('playlistViewTitle');
      const albumsList = document.getElementById('playlistAlbumsList');

      if (!playlistView || !layoutGrid) return;

      // Update title
      if (playlistTitle) playlistTitle.textContent = playlistName;

      // Hide regular grid, show playlist view
      layoutGrid.style.display = 'none';
      playlistView.classList.add('active');

      // Group tracks by album
      const albumsMap = new Map();
      tracks.forEach(track => {
        const albumKey = track.album || track.albumTitle || 'Unknown Album';
        if (!albumsMap.has(albumKey)) {
          albumsMap.set(albumKey, {
            title: albumKey,
            artist: track.artist || track.albumArtist || 'Unknown Artist',
            artwork: track.artworkUrl || track.artwork || '/img/placeholder.jpg',
            genre: track.genre || '',
            year: track.year || '',
            tracks: []
          });
        }
        albumsMap.get(albumKey).tracks.push(track);
      });

      // Populate album list
      const albums = Array.from(albumsMap.values());
      albumsList.innerHTML = albums.map((album, index) => `
        <div class="playlist-album-item ${index === 0 ? 'selected' : ''}" data-album-index="${index}">
          <div class="playlist-album-thumb">
            <img src="${album.artwork}" alt="${album.title}" onerror="this.src='/img/placeholder.jpg'">
          </div>
          <div class="playlist-album-info">
            <h3 class="playlist-album-name">${album.title}</h3>
            <p class="playlist-album-artist">${album.artist}</p>
            <p class="playlist-album-genre" style="font-size:12px;color:#888888;margin:0;">${album.genre || ''}</p>
            <div class="playlist-album-stats">
              <span class="playlist-album-stat">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                ${Math.floor(Math.random() * 50)}K
              </span>
              <span class="playlist-album-stat">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
                ${Math.floor(Math.random() * 30)}
              </span>
            </div>
          </div>
        </div>
      `).join('');

      // Add click handlers to album items
      albumsList.querySelectorAll('.playlist-album-item').forEach(item => {
        item.addEventListener('click', () => {
          // Remove selected from all
          albumsList.querySelectorAll('.playlist-album-item').forEach(i => i.classList.remove('selected'));
          item.classList.add('selected');

          const albumIndex = parseInt(item.dataset.albumIndex);
          showAlbumDetail(albums[albumIndex]);
        });
      });

      // Show first album details
      if (albums.length > 0) {
        showAlbumDetail(albums[0]);
      }
    }

    function showAlbumDetail(album) {
      const artwork = document.getElementById('playlistDetailArtwork');
      const title = document.getElementById('playlistDetailTitle');
      const artist = document.getElementById('playlistDetailArtist');
      const genre = document.getElementById('playlistDetailGenre');
      const year = document.getElementById('playlistDetailYear');
      const plays = document.getElementById('playlistDetailPlays');
      const repeats = document.getElementById('playlistDetailRepeats');
      const trackList = document.getElementById('playlistTrackList');

      if (artwork) artwork.src = album.artwork || '/img/placeholder.jpg';
      if (title) title.textContent = album.title;
      if (artist) artist.textContent = album.artist;
      if (genre) genre.textContent = album.genre || 'MUSIC';
      if (year) year.textContent = album.year || '';
      if (plays) plays.textContent = Math.floor(Math.random() * 50) + 'K';
      if (repeats) repeats.textContent = Math.floor(Math.random() * 10);

      // Populate track list
      if (trackList && album.tracks) {
        trackList.innerHTML = album.tracks.map((track, index) => `
          <div class="playlist-track-item" data-track-index="${index}">
            <span class="playlist-track-number">${index + 1}.</span>
            <span class="playlist-track-name">${track.name || track.trackName || 'Unknown Track'}</span>
            <span class="playlist-track-duration">${track.duration || '3:15'}</span>
          </div>
        `).join('');

        // Add click handlers to tracks
        trackList.querySelectorAll('.playlist-track-item').forEach(item => {
          item.addEventListener('click', () => {
            const trackIndex = parseInt(item.dataset.trackIndex);
            const track = album.tracks[trackIndex];
            // Play the track (integrate with existing player)
            if (track && track.audioUrl) {
              const player = document.getElementById('player');
              if (player) {
                player.src = track.audioUrl;
                player.play();
              }
            }
            // Mark as playing
            trackList.querySelectorAll('.playlist-track-item').forEach(t => t.classList.remove('playing'));
            item.classList.add('playing');
          });
        });
      }
    }

    function hidePlaylistView() {
      const playlistView = document.getElementById('playlistView');
      const layoutGrid = document.querySelector('.layout-grid');

      if (playlistView) playlistView.classList.remove('active');
      if (layoutGrid) layoutGrid.style.display = 'flex';
    }


    // Close featured playlist button handler
    document.addEventListener('DOMContentLoaded', () => {
      const closeBtn = document.getElementById('closePublicPlaylistBtn');
      const clearBtn = document.getElementById('clear');
      const publicPlaylistView = document.getElementById('publicPlaylistView');
      const searchEl = document.getElementById('search');
      const searchArtistEl = document.getElementById('searchArtist');
      const searchAlbumEl = document.getElementById('searchAlbum');
      const searchTrackEl = document.getElementById('searchTrack');
      const searchFieldsEl = document.getElementById('searchFields');
      let goBtn = document.getElementById('go');

      // Show search fields when Search button is clicked
      if (goBtn && searchFieldsEl) {
        console.log('[MASS] Attaching search button handler to:', goBtn);

        // CRITICAL: Remove all existing handlers from the button first
        // Clone the button to remove all listeners, then replace it
        const newGoBtn = goBtn.cloneNode(true);
        goBtn.parentNode.replaceChild(newGoBtn, goBtn);
        goBtn = newGoBtn; // Update reference for Enter key handler below

        // Now attach our handler to the fresh button
        goBtn.addEventListener('click', (e) => {
          console.log('[MASS] Search button clicked, searchFieldsEl.hidden:', searchFieldsEl.hidden);

          if (searchFieldsEl.hidden) {
            console.log('[MASS] Showing search fields and stopping propagation');
            searchFieldsEl.hidden = false;
            // Focus on first field
            if (searchArtistEl) searchArtistEl.focus();
            // Stop the event from reaching any other handlers
            e.stopImmediatePropagation();
            e.preventDefault();
            return; // Don't search yet, just show fields
          } else {
            console.log('[MASS] Search fields already visible, allowing search to proceed');
          }
        }, true); // Use capture phase to run before other handlers
      }

      if (closeBtn && clearBtn && publicPlaylistView) {
        closeBtn.addEventListener('click', () => {
          // Hide the featured playlist view immediately
          publicPlaylistView.hidden = true;
          // Clear search fields and trigger clear button to reload featured albums
          if (searchEl) searchEl.value = '';
          if (searchArtistEl) searchArtistEl.value = '';
          if (searchAlbumEl) searchAlbumEl.value = '';
          if (searchTrackEl) searchTrackEl.value = '';
          clearBtn.click();
        });
      }

      // Debounce utility for search
      function debounce(fn, delay) {
        let timer;
        return function(...args) {
          clearTimeout(timer);
          timer = setTimeout(() => fn.apply(this, args), delay);
        };
      }

      // Allow Enter key to trigger search from any search field
      const searchFields = [searchArtistEl, searchAlbumEl, searchTrackEl].filter(Boolean);

      // Debounced search on input (400ms delay to reduce API calls)
      const debouncedSearch = debounce(() => {
        if (!searchFieldsEl.hidden && goBtn) {
          goBtn.click();
        }
      }, 400);

      searchFields.forEach(field => {
        // Immediate search on Enter key
        field.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            goBtn.click();
          }
        });

        // Debounced search as user types
        field.addEventListener('input', debouncedSearch);
      });

      // Set Recommended Playlists to collapsed by default
      const publicPlaylistsPanel = document.getElementById('publicPlaylistsPanel');
      if (publicPlaylistsPanel) {
        publicPlaylistsPanel.classList.add('collapsed');
      }

      // Accordion functionality for playlist tracks section
      const playlistTracksSection = document.getElementById('playlistTracksSection');
      if (playlistTracksSection) {
        const header = playlistTracksSection.querySelector('.playlists-header');
        if (header) {
          header.addEventListener('click', (e) => {
            // Don't toggle if clicking on a button
            if (e.target.tagName === 'BUTTON' || e.target.closest('.playlist-actions')) return;
            playlistTracksSection.classList.toggle('collapsed');
            localStorage.setItem('playlistTracksCollapsed', playlistTracksSection.classList.contains('collapsed'));
          });
        }
        if (localStorage.getItem('playlistTracksCollapsed') === 'true') {
          playlistTracksSection.classList.add('collapsed');
        }
      }

      // Keep old search field handler for compatibility
      if (searchEl && goBtn) {
        searchEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            goBtn.click();
          }
        });
      }

      // AI Search toggle and close buttons
      const aiSearchClose = document.getElementById('aiSearchClose');
      const aiSearchPanel = document.getElementById('aiSearchPanel');
      const aiSearchToggle = document.getElementById('aiSearchToggle');
      const aiSearchInput = document.getElementById('aiSearchInput');
      const aiSearchButton = document.getElementById('aiSearchButton');
      const aiSearchStatus = document.getElementById('aiSearchStatus');
      const aiSearchStatusText = document.getElementById('aiSearchStatusText');
      const aiSearchInterpretation = document.getElementById('aiSearchInterpretation');

      if (aiSearchToggle && aiSearchPanel) {
        // Toggle button to open/close panel
        aiSearchToggle.addEventListener('click', () => {
          const isCollapsed = aiSearchPanel.getAttribute('data-collapsed') === 'true';
          aiSearchPanel.setAttribute('data-collapsed', isCollapsed ? 'false' : 'true');
          aiSearchToggle.setAttribute('aria-expanded', isCollapsed ? 'true' : 'false');
        });
      }
      if (aiSearchClose && aiSearchPanel && aiSearchToggle) {
        // Close button
        aiSearchClose.addEventListener('click', () => {
          aiSearchPanel.setAttribute('data-collapsed', 'true');
          aiSearchToggle.setAttribute('aria-expanded', 'false');
        });
      }

      // AI Search functionality
      const performAiSearch = async () => {
        const query = aiSearchInput.value.trim();
        if (!query) return;

        try {
          // Show loading state
          if (aiSearchStatus) {
            aiSearchStatus.hidden = false;
            aiSearchStatusText.textContent = 'Asking FileMaker for matchesâ€¦';
          }
          if (aiSearchInterpretation) aiSearchInterpretation.hidden = true;
          if (aiSearchButton) aiSearchButton.disabled = true;

          // Make API request
          const response = await fetch(`/api/ai-search?q=${encodeURIComponent(query)}`);
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || 'AI search failed');
          }

          // Show interpretation if available
          if (data.interpretation && aiSearchInterpretation) {
            aiSearchInterpretation.textContent = data.interpretation;
            aiSearchInterpretation.hidden = false;
          }

          // Display results
          if (data.albums && data.albums.length > 0) {
            renderAlbums(data.albums);
            if (resultsTitle) resultsTitle.textContent = `AI Search Results (${data.albums.length})`;
          } else {
            albumsEl.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;color:var(--muted);">No results found for your query</div>';
            if (resultsTitle) resultsTitle.textContent = 'No Results';
          }

          // Hide loading state
          if (aiSearchStatus) aiSearchStatus.hidden = true;

        } catch (err) {
          console.error('AI Search error:', err);
          if (aiSearchStatus) {
            aiSearchStatusText.textContent = 'Error: ' + err.message;
          }
          albumsEl.innerHTML = `<div style="grid-column:1/-1;text-align:center;padding:40px;color:#ff4444;">Error: ${err.message}</div>`;
        } finally {
          if (aiSearchButton) aiSearchButton.disabled = false;
        }
      };

      if (aiSearchButton && aiSearchInput) {
        aiSearchButton.addEventListener('click', performAiSearch);
        aiSearchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            performAiSearch();
          }
        });
      }

      // Image lightbox for album artwork (only in modal track view)
      const imageLightbox = document.getElementById('imageLightbox');
      const imageLightboxImg = document.getElementById('imageLightboxImg');
      const imageLightboxClose = document.getElementById('imageLightboxClose');
      const modalOverlay = document.getElementById('overlay');

      if (imageLightbox && imageLightboxImg && imageLightboxClose) {
        // Handle clicks on album artwork
        document.addEventListener('click', (e) => {
          const coverWrap = e.target.closest('.cover-wrap');
          if (coverWrap) {
            const img = coverWrap.querySelector('img');
            if (img && img.src) {
              e.preventDefault();
              e.stopPropagation();

              // Check if cover is in the modal (track view)
              const isInModal = modalOverlay && modalOverlay.classList.contains('open') &&
                                coverWrap.closest('.modal');

              if (isInModal) {
                // In modal: enlarge the image
                imageLightboxImg.src = img.src;
                imageLightbox.classList.add('open');
                imageLightbox.setAttribute('aria-hidden', 'false');
              } else {
                // In grid/random view: search for albums by this artist
                const card = coverWrap.closest('.card');
                if (card) {
                  const artistEl = card.querySelector('.card-artist');
                  if (artistEl) {
                    const artistName = artistEl.textContent.trim();
                    if (artistName) {
                      // Set artist in search field and trigger search
                      const searchArtistEl = document.getElementById('searchArtist');
                      const searchAlbumEl = document.getElementById('searchAlbum');
                      const searchTrackEl = document.getElementById('searchTrack');
                      const searchFieldsEl = document.getElementById('searchFields');
                      const goBtn = document.getElementById('go');

                      if (searchArtistEl && searchFieldsEl && goBtn) {
                        // Clear other fields and set artist
                        searchArtistEl.value = artistName;
                        if (searchAlbumEl) searchAlbumEl.value = '';
                        if (searchTrackEl) searchTrackEl.value = '';

                        // Show fields and trigger search
                        searchFieldsEl.hidden = false;
                        goBtn.click();
                      }
                    }
                  }
                }
              }
            }
          }
        });

        // Close lightbox on click
        const closeLightbox = () => {
          imageLightbox.classList.remove('open');
          imageLightbox.setAttribute('aria-hidden', 'true');
          imageLightboxImg.src = '';
        };

        imageLightboxClose.addEventListener('click', closeLightbox);
        imageLightbox.addEventListener('click', (e) => {
          if (e.target === imageLightbox) closeLightbox();
        });

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && imageLightbox.classList.contains('open')) {
            closeLightbox();
          }
        });
      }

      // Wake up the FileMaker connection to prevent idle timeout issues
      // This ensures the token is fresh and connection is warm before user tries to play audio
      function wakeUpConnection() {
        fetch('/api/wake', {
          headers: { 'Accept': 'application/json' },
          cache: 'no-cache',
          keepalive: true // Prevent connection from being terminated
        })
        .then(res => res.json())
        .then(data => {
          console.log('[MASS] Connection warmed up:', data.status);
        })
        .catch(err => {
          console.warn('[MASS] Wake call failed:', err);
        });
      }

      // Call on page load
      wakeUpConnection();

      // Also call when page becomes visible again (user returns to tab after being away)
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          console.log('[MASS] Page became visible, warming up connection...');
          wakeUpConnection();
        }
      });

      // Periodically wake the connection to prevent token expiration
      // FileMaker tokens expire after ~11.5 minutes, so wake every 8 minutes (safer than 5 with less overhead)
      setInterval(() => {
        if (!document.hidden) {
          console.log('[MASS] Periodic wake (keeping connection alive)...');
          wakeUpConnection();
        }
      }, 8 * 60 * 1000); // 8 minutes (changed from 5 for better balance)

      // Preload recommended playlists in the background - but only after access token is ready
      window.addEventListener('mass:access-ready', function() {
        // Hide loading indicator once access is ready
        const loadingIndicator = document.getElementById('loadingIndicator');
        if (loadingIndicator) {
          loadingIndicator.setAttribute('hidden', '');
        }

        setTimeout(() => {
          console.log('[Preload] Starting recommended playlists preload');
          fetch('/api/public-playlists', { headers: { 'Accept': 'application/json' } })
            .then(res => res.json())
            .then(data => {
              if (Array.isArray(data?.playlists)) {
                // Preload each recommended playlist's tracks in the background
                data.playlists.forEach((playlist, index) => {
                  if (playlist?.name) {
                    // Stagger the requests to avoid overwhelming the server
                    setTimeout(() => {
                      fetch(`/api/public-playlists?name=${encodeURIComponent(playlist.name)}`, {
                        headers: { 'Accept': 'application/json' }
                      }).catch(err => console.log('Preload failed for', playlist.name));
                    }, index * 500); // 500ms between each preload
                  }
                });
              }
            })
            .catch(err => console.log('Failed to preload recommended playlists'));
        }, 2000); // Wait 2 seconds after access ready before preloading
      });
    });
  </script>

  <script>
  // ========= COOKIE NOTICE =========
  (function() {
    const COOKIE_CONSENT_KEY = 'mass_cookie_consent';
    const cookieNotice = document.getElementById('cookieNotice');
    const cookieNoticeBtn = document.getElementById('cookieNoticeBtn');

    // Check if user has already accepted cookies
    const hasAccepted = localStorage.getItem(COOKIE_CONSENT_KEY);

    if (!hasAccepted) {
      // Show cookie notice after a short delay for better UX
      setTimeout(() => {
        cookieNotice.classList.remove('hidden');
      }, 1000);
    }

    // Handle "Got it!" button click
    cookieNoticeBtn.addEventListener('click', () => {
      localStorage.setItem(COOKIE_CONSENT_KEY, 'true');
      cookieNotice.classList.add('hidden');
    });
  })();
  </script>

  <script>
  // ========= ACCESS TOKEN MANAGEMENT =========
  // IMPORTANT: This must run BEFORE app.min.js to intercept fetch calls
  (function() {
    const STORAGE_KEY = 'mass_access_token';
    const STORAGE_INFO_KEY = 'mass_access_token_info';
    const SESSION_ID_KEY = 'mass_session_id';

    // Generate or retrieve unique session ID for this device/browser
    function getSessionId() {
      let sessionId = localStorage.getItem(SESSION_ID_KEY);
      if (!sessionId) {
        // Generate UUID v4
        sessionId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
        localStorage.setItem(SESSION_ID_KEY, sessionId);
        console.log('[Session] Generated new session ID:', sessionId);
      }
      return sessionId;
    }

    const sessionId = getSessionId();

    // Load token from localStorage IMMEDIATELY before anything else
    let currentAccessToken = localStorage.getItem(STORAGE_KEY);
    let tokenInfo = null;
    try {
      const infoStr = localStorage.getItem(STORAGE_INFO_KEY);
      if (infoStr) {
        tokenInfo = JSON.parse(infoStr);
      }
    } catch (e) {
      console.warn('[Access Token] Failed to parse token info:', e);
    }

    console.log('[Access Token] Pre-loaded token:', currentAccessToken ? 'YES' : 'NO');

    const overlay = document.getElementById('accessTokenOverlay');
    const form = document.getElementById('accessTokenForm');
    const input = document.getElementById('accessTokenInput');
    const submitBtn = document.getElementById('accessTokenSubmit');
    const errorDiv = document.getElementById('accessTokenError');
    const infoDiv = document.getElementById('accessTokenInfo');
    const statusDiv = document.getElementById('accessTokenStatus');

    // Intercept all fetch requests to add access token header
    const originalFetch = window.fetch;
    window.fetch = function(url, options = {}) {
      const isApiCall = url.includes('/api/') || url.startsWith('/api/');

      // Public endpoints that don't require access token
      const publicEndpoints = [
        '/api/access/validate',
        '/api/wake',
        '/api/container',
        '/api/random-songs',
        '/api/public-playlists',
        '/api/search',
        '/api/album',
        '/api/trending',
        '/api/featured-albums',
        '/api/missing-audio-songs'
      ];

      const isPublicEndpoint = publicEndpoints.some(endpoint => url.includes(endpoint));

      // Block API calls without token (except public endpoints)
      if (isApiCall && !currentAccessToken && !isPublicEndpoint) {
        console.warn('[Access Token] Blocking API call without token:', url);
        return Promise.reject(new Error('API call attempted before access token was ready'));
      }

      // Add access token header if we have one and it's an API request
      if (currentAccessToken && isApiCall) {
        console.log('[Access Token] Adding token to request:', url);

        // Initialize headers if not present
        if (!options.headers) {
          options.headers = {};
        }

        // Handle both Headers objects and plain objects
        if (options.headers instanceof Headers) {
          options.headers.set('X-Access-Token', currentAccessToken);
        } else if (typeof options.headers === 'object') {
          options.headers['X-Access-Token'] = currentAccessToken;
        }
      }

      // Call original fetch and handle 403 errors
      return originalFetch(url, options).then(response => {
        // If we get 403 and it requires access token, show the overlay
        if (response.status === 403 && url.includes('/api/')) {
          response.clone().json().then(data => {
            if (data.requiresAccessToken) {
              console.log('[Access Token] 403 error - token required or invalid');
              clearAccessToken();
              showTokenOverlay();
            }
          }).catch(() => {});
        }
        return response;
      });
    };

    function showError(message) {
      errorDiv.textContent = message;
      errorDiv.classList.add('show');
      setTimeout(() => {
        errorDiv.classList.remove('show');
      }, 5000);
    }

    function showTokenOverlay() {
      overlay.classList.remove('hidden');
      input.value = '';
      input.focus();
    }

    function hideTokenOverlay() {
      overlay.classList.add('hidden');
    }

    function updateTokenInfo() {
      if (!tokenInfo) {
        infoDiv.classList.add('hidden');
        return;
      }

      let statusText = '';
      if (tokenInfo.type === 'unlimited') {
        statusText = 'Unlimited Access';
      } else if (tokenInfo.expirationDate && tokenInfo.expirationDate.trim() !== '') {
        const expDate = new Date(tokenInfo.expirationDate);
        const now = new Date();

        // Check if date is valid
        if (isNaN(expDate.getTime())) {
          statusText = 'Active';
        } else {
          const hoursLeft = (expDate - now) / (1000 * 60 * 60);
          const daysLeft = Math.ceil(hoursLeft / 24);

          if (hoursLeft < 1) {
            statusText = 'Expired';
          } else if (hoursLeft < 24) {
            statusText = `Expires in ${Math.floor(hoursLeft)} hour${Math.floor(hoursLeft) !== 1 ? 's' : ''}`;
          } else if (daysLeft === 1) {
            statusText = `Expires in 1 day`;
          } else {
            statusText = `Expires in ${daysLeft} days`;
          }
        }
      } else {
        statusText = 'Active (no expiration)';
      }

      statusDiv.textContent = statusText;
      infoDiv.classList.remove('hidden');

      // Auto-hide notification after 10 seconds
      setTimeout(() => {
        infoDiv.classList.add('hidden');
      }, 10000);
    }

    function saveAccessToken(token, info) {
      currentAccessToken = token;
      tokenInfo = info;
      localStorage.setItem(STORAGE_KEY, token);
      localStorage.setItem(STORAGE_INFO_KEY, JSON.stringify(info));
      updateTokenInfo();
    }

    function loadAccessToken() {
      // Token already loaded at script start, just update UI and return it
      if (currentAccessToken) {
        updateTokenInfo();
      }
      return currentAccessToken;
    }

    async function clearAccessToken() {
      // Call backend to clear session from FileMaker
      if (currentAccessToken && sessionId) {
        console.log('[Access Token] Calling logout endpoint with token:', currentAccessToken, 'sessionId:', sessionId);
        try {
          const response = await originalFetch('/api/access/logout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              token: currentAccessToken,
              sessionId: sessionId
            })
          });
          const data = await response.json();
          console.log('[Access Token] Logout response:', response.status, data);
          if (response.ok) {
            console.log('[Access Token] âœ… Session cleared from server successfully');
          } else {
            console.error('[Access Token] âŒ Logout failed:', data);
          }
        } catch (err) {
          console.error('[Access Token] âŒ Logout request failed:', err);
        }
      } else {
        console.log('[Access Token] Skipping logout - no token or sessionId');
      }

      // Clear local storage
      currentAccessToken = null;
      tokenInfo = null;
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(STORAGE_INFO_KEY);
      infoDiv.classList.add('hidden');
      window.massAccessReady = false;
      window.massAccessToken = null;
    }

    async function validateToken(token) {
      try {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Validating...';
        errorDiv.classList.remove('show');

        const response = await originalFetch('/api/access/validate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            token: token.trim().toUpperCase(),
            sessionId: sessionId
          })
        });

        const data = await response.json();

        if (response.ok && data.valid) {
          const normalized = token.trim().toUpperCase();
          saveAccessToken(normalized, {
            type: data.type,
            expirationDate: data.expirationDate
          });

          // Save email to localStorage for currentUser
          if (data.email) {
            localStorage.setItem('mass_token_email', data.email);
          }

          hideTokenOverlay();
          console.log('[Access Token] Token validated successfully');

          // Notify app that access is ready so it can do its initial load
          window.massAccessReady = true;
          window.massAccessToken = normalized;
          window.dispatchEvent(new CustomEvent('mass:access-ready', {
            detail: { token: normalized, email: data.email || null }
          }));

          return true;
        } else {
          // Check for "token in use" error
          if (data.reason === 'Token is currently in use on another device') {
            showError('âš ï¸ This token is already active on another device. Please wait or use a different token.');
          } else {
            showError(data.reason || data.error || 'Invalid token');
          }
          return false;
        }
      } catch (err) {
        console.error('[Access Token] Validation error:', err);
        showError('Failed to validate token. Please try again.');
        return false;
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Activate Access';
      }
    }

    // Form submission handler
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const token = input.value.trim();

      if (!token) {
        showError('Please enter an access token');
        return;
      }

      await validateToken(token);
    });

    // Check for existing token on page load
    const existingToken = loadAccessToken();
    if (existingToken) {
      console.log('[Access Token] Found existing token, validating...');
      // Validate the existing token (validateToken will dispatch 'mass:access-ready' if valid)
      validateToken(existingToken).then(valid => {
        if (!valid) {
          console.log('[Access Token] Existing token invalid, showing overlay');
          showTokenOverlay();
        } else {
          console.log('[Access Token] Existing token valid (event already dispatched)');
          // Note: hideTokenOverlay and event dispatch already handled in validateToken
        }
      });
    } else {
      console.log('[Access Token] No existing token, showing overlay');
      showTokenOverlay();
    }

    // Allow clearing token with Ctrl+Shift+T (for testing)
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'T') {
        console.log('[Access Token] Clearing token (Ctrl+Shift+T)');
        clearAccessToken();
        showTokenOverlay();
      }
    });

    // Reset App button handler
    const resetAppBtn = document.getElementById('resetAppBtn');
    if (resetAppBtn) {
      resetAppBtn.addEventListener('click', async () => {
        if (confirm('Reset app? This will clear all stored data (access token, cookies, settings) and reload the page.')) {
          console.log('[Access Token] Resetting app - clearing all localStorage');

          // First, clear session from server
          await clearAccessToken();

          // Then clear all local storage and cookies
          localStorage.clear();
          sessionStorage.clear();
          // Also clear cookies
          document.cookie.split(";").forEach((c) => {
            document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
          });
          location.reload(true); // Force reload from server, not cache
        }
      });
    }

    console.log('[Access Token] Token management initialized');
  })();
  </script>

  <script>
  // Check for URL parameters IMMEDIATELY to prevent featured albums from loading
  (function() {
    const urlParams = new URLSearchParams(window.location.search);
    const albumParam = urlParams.get('album');
    const artistParam = urlParams.get('artist');

    if (albumParam || artistParam) {
      // Set flag to prevent app.min.js from loading featured albums
      window.__skipFeaturedLoad = true;
      console.log('[MASS] URL parameters detected early, skipping featured album load');
    }
  })();
  </script>
  <!-- Album/Playlist detail autoplay â€” MUST register before app.min.js so ended fires first -->
  <script>
  (function() {
    const player = document.getElementById('player');
    if (!player) return;

    function isDetailViewActive() {
      const pv = document.getElementById('playlistView');
      return pv && pv.classList.contains('active');
    }

    function advanceDetailTrack(direction) {
      const trackList = document.getElementById('playlistTrackList');
      if (!trackList) return false;
      const playing = trackList.querySelector('.playlist-track-item.playing');
      if (!playing) return false;
      const items = Array.from(trackList.querySelectorAll('.playlist-track-item'));
      const idx = items.indexOf(playing);
      if (idx === -1) return false;
      const nextIdx = direction === 'next' ? idx + 1 : idx - 1;
      if (nextIdx < 0 || nextIdx >= items.length) return false;
      items[nextIdx].click();
      // Scroll into view smoothly
      items[nextIdx].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      return true;
    }

    // Expose for Next/Prev button handlers added after app.min.js loads
    window.__advanceDetailTrack = advanceDetailTrack;
    window.__isDetailViewActive = isDetailViewActive;

    // Auto-advance when track ends â€” fires before app.min.js handler
    player.addEventListener('ended', function(e) {
      if (!isDetailViewActive()) return;
      const advanced = advanceDetailTrack('next');
      if (advanced) {
        // Prevent app.min.js from also trying to advance (avoids wrong-track jumps)
        e.stopImmediatePropagation();
      }
    });
  })();
  </script>
  <script defer src="/app.min.js?v=94&t=1735077300"></script>
  <script>
  // Fix logout button to call clearAccessToken endpoint
  window.addEventListener('DOMContentLoaded', () => {
    // Wait a bit for app.min.js to initialize
    setTimeout(() => {
      const logoutBtn = document.getElementById('logoutButton');
      if (logoutBtn) {
        // Remove existing listeners by cloning
        const newLogoutBtn = logoutBtn.cloneNode(true);
        logoutBtn.parentNode.replaceChild(newLogoutBtn, logoutBtn);

        // Add our logout handler
        newLogoutBtn.addEventListener('click', async () => {
          console.log('[LOGOUT] Logout button clicked');

          // Call clearAccessToken from the access token script
          const token = localStorage.getItem('mass_access_token');
          const sessionId = localStorage.getItem('mass_session_id');

          if (token && sessionId) {
            console.log('[LOGOUT] Calling logout endpoint');
            try {
              const response = await fetch('/api/access/logout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token, sessionId })
              });
              const data = await response.json();
              console.log('[LOGOUT] Response:', data);
            } catch (err) {
              console.error('[LOGOUT] Failed:', err);
            }
          }

          // Clear localStorage
          localStorage.removeItem('mass_access_token');
          localStorage.removeItem('mass_token_info');
          localStorage.removeItem('mass_token_email');
          window.massAccessReady = false;
          window.massAccessToken = null;

          // Reload page
          window.location.reload();
        });
        console.log('[LOGOUT] Logout button handler installed');
      }
    }, 1000);
  });
  </script>
  <script>
  // Override search to use separate fields
  window.addEventListener('load', () => {
    const searchArtistEl = document.getElementById('searchArtist');
    const searchAlbumEl = document.getElementById('searchAlbum');
    const searchTrackEl = document.getElementById('searchTrack');
    const searchGenreEl = document.getElementById('searchGenre');
    const searchDecadeEl = document.getElementById('searchDecade');
    const searchFieldsEl = document.getElementById('searchFields');
    const goEl = document.getElementById('go');
    const clearEl = document.getElementById('clear');

    // Check if we need to trigger immediate search from URL params
    const hasUrlParams = window.__skipFeaturedLoad === true;

    function setupSearchOverride() {
      const originalDoSearch = typeof window.doSearch === 'function' ? window.doSearch : null;
      if (!originalDoSearch) {
        console.warn('[Separate Search] Unable to override doSearch (missing original implementation)');
        return;
      }

      window.doSearch = function(q, options = {}) {
        console.log('[doSearch Override] Called with q:', q, 'options:', options);
        const artist = searchArtistEl?.value?.trim() || '';
        const album = searchAlbumEl?.value?.trim() || '';
        const track = searchTrackEl?.value?.trim() || '';
        const genre = searchGenreEl?.value?.trim() || '';
        const decade = searchDecadeEl?.value?.trim() || '';
        console.log('[doSearch Override] Field values - artist:', artist, 'album:', album, 'track:', track, 'genre:', genre, 'decade:', decade);
        // Use options.genre only if it's a non-empty string, otherwise use the dropdown value
        const genreValue = (options.genre?.trim() || genre);
        const decadeValue = (options.decade?.trim() || decade);
        const useAdvanced = Boolean(artist || album || track || genreValue || decadeValue);
        console.log('[doSearch Override] useAdvanced:', useAdvanced, 'genreValue:', genreValue, 'decadeValue:', decadeValue);

        if (!useAdvanced) {
          return originalDoSearch.call(this, q, options);
        }

        const params = new URLSearchParams();
        if (artist) params.set('artist', artist);
        if (album) params.set('album', album);
        if (track) params.set('track', track);
        if (genreValue) params.set('genre', genreValue);
        if (decadeValue) params.set('decade', decadeValue);
        const searchLimit = (artist && !album && !track) ? 500 : 200;
        params.set('limit', searchLimit);
        const requestedOffset = Number.isFinite(options.offset) ? Math.max(0, Number(options.offset)) : 0;
        params.set('offset', requestedOffset);


        console.log('[Separate Search] Advanced search params:', {
          artist,
          album,
          track,
          genre: genreValue,
          offset: requestedOffset,
          limit: searchLimit
        });

        if (window.inFlight) {
          try { window.inFlight.abort(); } catch {}
        }
        const ctrl = new AbortController();
        window.inFlight = ctrl;

        return fetch(`/api/search?${params}`, { signal: ctrl.signal })
          .then(async (r) => {
            if (!r.ok) throw new Error(await r.text().catch(() => `HTTP ${r.status}`));
            return r.json();
          })
          .finally(() => {
            if (window.inFlight === ctrl) window.inFlight = null;
          });
      };

      // Override go button handler
      if (goEl && searchFieldsEl) {
        const oldHandler = goEl.onclick;
        goEl.onclick = null;
        goEl.removeEventListener('click', oldHandler);

        goEl.addEventListener('click', () => {
          // If fields are hidden, don't search (the capture phase handler will show them)
          if (searchFieldsEl.hidden) {
            return;
          }

          const artist = searchArtistEl?.value?.trim() || '';
          const album = searchAlbumEl?.value?.trim() || '';
          const track = searchTrackEl?.value?.trim() || '';
          const genre = searchGenreEl?.value?.trim() || '';
          const decade = searchDecadeEl?.value?.trim() || '';

          // Need at least one field to search
          if (!artist && !album && !track && !genre && !decade) {
            return;
          }

          // Call run function with a dummy query to trigger the search flow
          // The actual parameters will be read from the input fields by doSearch
          if (typeof window.run === 'function') {
            window.run(' ');
          }
        });
      }

      // Clear button reloads the page for a clean state
      if (clearEl) {
        clearEl.addEventListener('click', () => {
          window.location.reload();
        });
      }

      // Add change listeners to genre and decade dropdowns to trigger search
      if (searchGenreEl) {
        searchGenreEl.addEventListener('change', () => {
          console.log('[Genre Change] Selected genre:', searchGenreEl.value);
          if (searchGenreEl.value) {
            // Clear other search fields for genre-only search
            if (searchArtistEl) searchArtistEl.value = '';
            if (searchAlbumEl) searchAlbumEl.value = '';
            if (searchTrackEl) searchTrackEl.value = '';
            // Show search fields when genre is selected
            if (searchFieldsEl) searchFieldsEl.hidden = false;
            console.log('[Genre Change] Using genre pagination:', searchGenreEl.value);
            // Use genre pagination mode instead of regular search
            if (typeof window.runGenreExplore === 'function') {
              window.runGenreExplore(searchGenreEl.value);
            } else {
              console.error('[Genre Change] window.runGenreExplore is not a function!');
            }
          } else {
            // If cleared, reload featured or clear results
            if (typeof window.clear === 'function') {
              window.clear();
            }
          }
        });
      }

      if (searchDecadeEl) {
        searchDecadeEl.addEventListener('change', () => {
          if (searchDecadeEl.value) {
            // Clear other search fields for decade-only search
            if (searchArtistEl) searchArtistEl.value = '';
            if (searchAlbumEl) searchAlbumEl.value = '';
            if (searchTrackEl) searchTrackEl.value = '';
            // Show search fields when decade is selected
            if (searchFieldsEl) searchFieldsEl.hidden = false;
            // Trigger search with run() which handles rendering
            if (typeof window.run === 'function') {
              window.run(' ');
            }
          } else {
            // If cleared, reload featured or clear results
            if (typeof window.clear === 'function') {
              window.clear();
            }
          }
        });
      }

      // Handle URL parameters for album/artist filtering from Modern View
      if (hasUrlParams) {
        const urlParams = new URLSearchParams(window.location.search);
        const albumParam = urlParams.get('album');
        const artistParam = urlParams.get('artist');

        if ((albumParam || artistParam) && searchFieldsEl) {
          console.log('[MASS] URL parameters detected, pre-filling search:', { album: albumParam, artist: artistParam });

          // Show search fields
          searchFieldsEl.hidden = false;

          // Pre-fill the search fields
          if (artistParam && searchArtistEl) {
            searchArtistEl.value = artistParam;
          }
          if (albumParam && searchAlbumEl) {
            searchAlbumEl.value = albumParam;
          }

          // Return true to indicate we should trigger search after setup
          return true;
        }
      }
      return false;
    }

    // Function to trigger automatic search after setup
    function triggerAutoSearch() {
      console.log('[MASS] Triggering automatic search after setup complete');
      // Use multiple RAF to ensure all handlers and DOM updates are complete
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          setTimeout(() => {
            // Verify fields are filled
            const artist = searchArtistEl?.value?.trim() || '';
            const album = searchAlbumEl?.value?.trim() || '';
            const track = searchTrackEl?.value?.trim() || '';

            console.log('[MASS] Auto-search with values:', { artist, album, track });

            if (!artist && !album && !track) {
              console.warn('[MASS] No search values found, aborting auto-search');
              return;
            }

            // Call doSearch directly instead of window.run
            if (typeof window.doSearch === 'function' && typeof window.run === 'function') {
              console.log('[MASS] Executing doSearch and applying results');
              // Call run with a non-empty query to trigger the search flow
              // The doSearch override will use the field values
              window.run('auto-search-trigger');
            } else {
              console.warn('[MASS] Search functions not ready');
            }
          }, 300);
        });
      });
    }

    // If window.run is already available (deferred script loaded), setup immediately
    // Otherwise poll for it (should be very quick with defer)
    if (typeof window.run === 'function') {
      console.log('[MASS] window.run already available, setting up immediately');
      const shouldAutoSearch = setupSearchOverride();
      if (shouldAutoSearch) {
        // Wait even longer to ensure everything is ready
        setTimeout(() => {
          console.log('[MASS] Delayed auto-search trigger');
          triggerAutoSearch();
        }, 500);
      }
    } else {
      console.log('[MASS] Polling for window.run...');
      const checkInterval = setInterval(() => {
        if (typeof window.run === 'function') {
          clearInterval(checkInterval);
          console.log('[MASS] window.run detected, setting up');
          const shouldAutoSearch = setupSearchOverride();
          if (shouldAutoSearch) {
            // Wait even longer to ensure everything is ready
            setTimeout(() => {
              console.log('[MASS] Delayed auto-search trigger after polling');
              triggerAutoSearch();
            }, 500);
          }
        }
      }, 10);
      // Fallback timeout
      setTimeout(() => clearInterval(checkInterval), 2000);
    }
  });
  </script>

  <script>
  // Secret keystroke: Ctrl+Shift+M to toggle/refresh Missing Audio Mode, Escape to exit
  document.addEventListener('keydown', async (e) => {
    const albumsEl = document.getElementById('albums');
    if (!albumsEl) return;

    const isActive = document.body.classList.contains('missing-audio-mode');

    // Escape key exits missing audio mode
    if (e.key === 'Escape' && isActive) {
      e.preventDefault();
      window.location.reload();
      return;
    }

    // Ctrl+Shift+M toggles on or refreshes
    if (e.ctrlKey && e.shiftKey && e.key === 'M') {
      e.preventDefault();

      if (isActive) {
        console.log('ðŸ”„ Refreshing missing audio songs...');
      } else {
        document.body.classList.add('missing-audio-mode');
        console.log('ðŸ” Missing Audio Mode ACTIVATED');
      }

      // Load songs WITHOUT valid audio
      try {
        const res = await fetch('/api/missing-audio-songs?count=12&_t=' + Date.now());
        const data = await res.json();
        const songs = data.items || [];
        console.log(`ðŸ” Loaded ${songs.length} songs with missing audio`);

        albumsEl.innerHTML = '';

        if (songs.length === 0) {
          albumsEl.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;color:var(--muted);">No songs with missing audio found in database</div>';
        } else {
          // Render missing audio cards
          for (const item of songs) {
            const fields = item.fields || {};
            const card = document.createElement('div');
            card.className = 'card';
            card.style.border = '2px solid #ff4444';

            const title = fields['Track Name'] || fields['Song Name'] || fields['Title'] || 'Unknown Track';
            const artist = fields['Album Artist'] || fields['Artist'] || 'Unknown Artist';
            const album = fields['Album Title'] || fields['Album'] || 'Unknown Album';
            const genre = fields['Genre'] || fields['Local Genre'] || '';

            card.innerHTML = `
              <div class="heading">
                <h3 style="color:#ff4444;">${title}</h3>
                <div class="card-artist">${artist}</div>
                <div class="muted">${album}${genre ? ' â€¢ ' + genre : ''}</div>
                <div class="muted" style="color:#ff4444;margin-top:8px;font-weight:600;">âš ï¸ MISSING AUDIO</div>
              </div>
            `;
            albumsEl.appendChild(card);
          }
        }
      } catch (err) {
        console.error('âŒ Failed to load missing audio songs:', err);
        albumsEl.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;color:#ff4444;">Error loading missing audio songs</div>';
      }
    }
  });
  </script>

  <script>
  // More by Artist functionality in modal
  (function() {
    const overlay = document.getElementById('overlay');
    const modalArtist = document.getElementById('modalArtist');
    const modalTitle = document.getElementById('modalTitle');
    const moreByArtistSection = document.getElementById('moreByArtist');
    const moreByArtistGrid = document.getElementById('moreByArtistGrid');

    if (!overlay || !modalArtist || !moreByArtistSection || !moreByArtistGrid) {
      console.warn('[More by Artist] Required elements not found');
      return;
    }

    // Watch for modal opening
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const isOpen = overlay.classList.contains('open');
          if (isOpen) {
            loadMoreByArtist();
          } else {
            // Clear when modal closes
            moreByArtistGrid.innerHTML = '';
            moreByArtistSection.hidden = true;
          }
        }
      }
    });

    observer.observe(overlay, { attributes: true });

    async function loadMoreByArtist() {
      const artistName = modalArtist.textContent.trim();
      const currentAlbum = modalTitle.textContent.trim();

      if (!artistName) {
        moreByArtistSection.hidden = true;
        return;
      }

      try {
        // Search for albums by this artist
        const params = new URLSearchParams();
        params.set('artist', artistName);
        params.set('limit', 20);

        const response = await fetch(`/api/search?${params}`);
        if (!response.ok) throw new Error('Failed to fetch albums');

        const data = await response.json();
        const albums = data.albums || [];

        // Filter out the current album and limit to 5
        const otherAlbums = albums
          .filter(album => album.album !== currentAlbum)
          .slice(0, 5);

        if (otherAlbums.length === 0) {
          moreByArtistSection.hidden = true;
          return;
        }

        // Render albums
        moreByArtistGrid.innerHTML = '';
        otherAlbums.forEach(album => {
          const item = document.createElement('div');
          item.className = 'more-by-artist-item';
          item.dataset.artist = album.artist || '';
          item.dataset.album = album.album || '';

          const img = document.createElement('img');
          img.src = album.artwork || '/img/placeholder.png';
          img.alt = album.album || 'Album';
          img.loading = 'lazy';

          const info = document.createElement('div');
          info.className = 'more-by-artist-item-info';

          const title = document.createElement('div');
          title.className = 'more-by-artist-item-title';
          title.textContent = album.album || 'Unknown Album';

          const meta = document.createElement('div');
          meta.className = 'more-by-artist-item-meta';
          const parts = [];
          if (album.year) parts.push(album.year);
          if (album.genre) parts.push(album.genre);
          meta.textContent = parts.join(' â€¢ ') || 'Album';

          info.appendChild(title);
          info.appendChild(meta);
          item.appendChild(img);
          item.appendChild(info);

          // Click to open this album
          item.addEventListener('click', () => {
            // Close current modal first
            overlay.classList.remove('open');
            // Then search for this album
            const searchArtist = document.getElementById('searchArtist');
            const searchAlbum = document.getElementById('searchAlbum');
            const searchTrack = document.getElementById('searchTrack');
            const searchFields = document.getElementById('searchFields');
            const goBtn = document.getElementById('go');

            if (searchArtist && searchAlbum && searchFields && goBtn) {
              searchArtist.value = item.dataset.artist;
              searchAlbum.value = item.dataset.album;
              if (searchTrack) searchTrack.value = '';
              searchFields.hidden = false;
              setTimeout(() => goBtn.click(), 100);
            }
          });

          moreByArtistGrid.appendChild(item);
        });

        moreByArtistSection.hidden = false;
      } catch (err) {
        console.error('[More by Artist] Failed to load albums:', err);
        moreByArtistSection.hidden = true;
      }
    }
  })();
  </script>

  <script>
  // Show subscription prompt after 5 minutes for non-authenticated users
  (function() {
    const PROMPT_DELAY_MS = 5 * 60 * 1000; // 5 minutes
    let promptShown = false;

    function isUserLoggedIn() {
      const userBadge = document.getElementById('userBadge');
      const isLoggedIn = userBadge && !userBadge.hidden;
      return isLoggedIn;
    }

    function showSubscriptionPrompt() {
      if (promptShown) return;
      if (isUserLoggedIn()) return;

      promptShown = true;

      // Create persistent toast notification
      const toast = document.createElement('div');
      toast.className = 'subscription-toast';
      toast.innerHTML = `
        <button class="subscription-toast-close" aria-label="Close">âœ•</button>
        <div style="padding-right:20px;cursor:pointer;" class="subscription-toast-body">
          ðŸŽµ Enjoying the music?<br/>
          <span style="font-weight:400;font-size:13px;opacity:0.9;">Subscribe to unlock playlists and more features!</span>
        </div>
      `;
      document.body.appendChild(toast);

      // Show toast with animation
      setTimeout(() => toast.classList.add('show'), 100);

      // Close button handler - only dismiss
      const closeBtn = toast.querySelector('.subscription-toast-close');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 400);
        });
      }

      // Click toast body to open subscribe modal
      const toastBody = toast.querySelector('.subscription-toast-body');
      if (toastBody) {
        toastBody.addEventListener('click', () => {
          const signupTrigger = document.getElementById('signupTrigger');
          if (signupTrigger) {
            signupTrigger.click();
          }
        });
      }

      console.log('ðŸ“¢ Subscription prompt displayed (persistent until dismissed)');
    }

    // Set timer
    console.log(`â±ï¸ Subscription prompt timer started (${Math.floor(PROMPT_DELAY_MS / 1000)} seconds)`);

    setTimeout(() => {
      showSubscriptionPrompt();
    }, PROMPT_DELAY_MS);
  })();
  </script>

  <script>
  // Lazy loading for images - improves performance
  (function() {
    // Add lazy loading and async decoding to all existing images
    document.querySelectorAll('img').forEach(img => {
      if (!img.loading) img.loading = 'lazy';
      if (!img.decoding) img.decoding = 'async';
    });

    // Observe new images being added to the DOM
    const imageObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.tagName === 'IMG') {
            if (!node.loading) node.loading = 'lazy';
            if (!node.decoding) node.decoding = 'async';
          } else if (node.querySelectorAll) {
            node.querySelectorAll('img').forEach(img => {
              if (!img.loading) img.loading = 'lazy';
              if (!img.decoding) img.decoding = 'async';
            });
          }
        });
      });
    });

    imageObserver.observe(document.body, {
      childList: true,
      subtree: true
    });

    console.log('ðŸ–¼ï¸ Image lazy loading initialized');
  })();
  </script>


  <script>
  // ðŸŽµ Animated Record Player - Tonearm and spinning vinyl (Now Playing only)
  (function() {
    let currentAudio = null;

    // Listen for audio playback events
    document.addEventListener('DOMContentLoaded', () => {
      const nowPlayingThumb = document.querySelector('.mini-player-artwork');

      if (!nowPlayingThumb) {
        console.warn('âš ï¸ Mini player artwork not found');
        return;
      }

      // Monitor all audio elements
      const checkAudioPlayback = () => {
        const allAudio = document.querySelectorAll('audio');

        allAudio.forEach(audio => {
          if (!audio.dataset.recordPlayerListenerAdded) {
            audio.dataset.recordPlayerListenerAdded = 'true';

            const toggleJukeboxGlow = (isPlaying) => {
              // Placeholder for jukebox glow effect
            };

            // When audio starts playing
            audio.addEventListener('play', () => {
              currentAudio = audio;
              const thumb = document.querySelector('.mini-player-artwork');
              const miniPlayer = document.getElementById('miniPlayer');
              const modalAlbumSleeve = document.getElementById('modalAlbumSleeve');
              const toggleBtn = document.getElementById('nowPlayingToggle');

              console.log('[PLAYER] Audio playing, showing mini player');

              // Show mini player ribbon
              if (miniPlayer) {
                miniPlayer.classList.add('active');
                console.log('[MINI PLAYER] Ribbon shown');
              }

              // Update toggle button to show pause icon
              if (toggleBtn) {
                toggleBtn.textContent = 'â¸';
                toggleBtn.title = 'Pause';
              }

              // Extract track info from the currently playing track in modal
              const playingTrack = document.querySelector('.track.playing, .playlist-track.playing');
              if (playingTrack) {
                const trackName = playingTrack.querySelector('.track-name, .name')?.textContent || 'Unknown Track';
                const artistName = playingTrack.querySelector('.artist')?.textContent || 'Unknown Artist';

                document.getElementById('nowPlayingTitle').textContent = trackName;
                document.getElementById('nowPlayingSubtitle').textContent = artistName;
                console.log('[RIBBON] Updated track info:', trackName, '-', artistName);
              }

              // Extract metadata from modal
              const modalYear = document.getElementById('modalYear')?.textContent.trim();
              const modalCat = document.getElementById('modalCat')?.textContent.trim();
              const modalArtist = document.getElementById('modalArtist')?.textContent.trim();

              // Update metadata fields (only show if available)
              const yearEl = document.getElementById('nowPlayingYear');
              const genreEl = document.getElementById('nowPlayingGenre');
              const languageEl = document.getElementById('nowPlayingLanguage');
              const composerEl = document.getElementById('nowPlayingComposer');
              const producerEl = document.getElementById('nowPlayingProducer');
              const sourceEl = document.getElementById('nowPlayingSource');

              if (yearEl && modalYear) yearEl.textContent = modalYear;
              if (sourceEl && modalCat) sourceEl.textContent = modalCat;

              // Try to extract additional metadata from track data attributes
              if (playingTrack && playingTrack.dataset) {
                if (genreEl && playingTrack.dataset.genre) genreEl.textContent = playingTrack.dataset.genre;
                if (languageEl && playingTrack.dataset.language) languageEl.textContent = playingTrack.dataset.language;
                if (composerEl && playingTrack.dataset.composer) composerEl.textContent = `â™« ${playingTrack.dataset.composer}`;
                if (producerEl && playingTrack.dataset.producer) producerEl.textContent = `âš™ ${playingTrack.dataset.producer}`;
              }

              console.log('[RIBBON] Updated metadata:', {year: modalYear, cat: modalCat});

              // Try to get album artwork from modal or page
              let artworkUrl = null;

              // Try multiple selectors to find artwork
              const artworkSelectors = [
                '.modal.open .cover-wrap img',
                '#modalCover img',
                '.modal header .cover-wrap img',
                '.card.active .cover-wrap img',
                '.album.active .cover-wrap img'
              ];

              for (const selector of artworkSelectors) {
                const img = document.querySelector(selector);
                if (img && img.src && !img.src.includes('placeholder')) {
                  artworkUrl = img.src;
                  break;
                }
              }

              if (artworkUrl && thumb) {
                thumb.innerHTML = `<img src="${artworkUrl}" alt="Album artwork">`;
                console.log('[RIBBON] Updated artwork:', artworkUrl);
              }

              // Show and populate album sleeve in modal if overlay is open
              if (modalAlbumSleeve) {
                const overlay = document.getElementById('overlay');
                if (overlay && overlay.classList.contains('open')) {
                  modalAlbumSleeve.classList.add('show');

                  // Get artwork from audio element's data attributes or find it
                  const trackData = audio.dataset;
                  const artworkUrl = trackData.artwork || trackData.artworkUrl;

                  if (artworkUrl) {
                    modalAlbumSleeve.innerHTML = `<img src="${artworkUrl}" alt="Album artwork">`;
                    console.log('[ALBUM SLEEVE] Showing artwork:', artworkUrl);
                  }
                }
              }

              if (thumb) {
                thumb.classList.add('playing');
                console.log('[PLAYER] Added playing class to artwork');
              }
              toggleJukeboxGlow(true);
            });

            // Track playback progress
            audio.addEventListener('timeupdate', () => {
              const progressFill = document.getElementById('nowPlayingProgressFill');

              if (audio.duration && !audio.paused) {
                const progress = audio.currentTime / audio.duration;

                // Update progress bar
                if (progressFill) {
                  progressFill.style.width = `${progress * 100}%`;
                }
              }
            });

            // When audio pauses
            audio.addEventListener('pause', () => {
              const thumb = document.querySelector('.mini-player-artwork');
              const toggleBtn = document.getElementById('nowPlayingToggle');

              if (thumb) {
                thumb.classList.remove('playing');
              }
              if (toggleBtn) {
                toggleBtn.textContent = 'â–¶';
                toggleBtn.title = 'Play';
              }
              toggleJukeboxGlow(false);
            });

            // When audio ends
            audio.addEventListener('ended', () => {
              const thumb = document.querySelector('.mini-player-artwork');
              const progressFill = document.getElementById('nowPlayingProgressFill');
              const toggleBtn = document.getElementById('nowPlayingToggle');

              if (thumb) {
                thumb.classList.remove('playing');
              }
              if (toggleBtn) {
                toggleBtn.textContent = 'â–¶';
                toggleBtn.title = 'Play';
              }

              // Reset progress bar
              if (progressFill) {
                progressFill.style.width = '0%';
              }

              toggleJukeboxGlow(false);
            });
          }
        });
      };

      // Initial check
      checkAudioPlayback();

      // Monitor for new audio elements being added
      const audioObserver = new MutationObserver(() => {
        checkAudioPlayback();
      });

      audioObserver.observe(document.body, {
        childList: true,
        subtree: true
      });

      // Also check periodically for the #player element (created by app.min.js)
      const playerCheckInterval = setInterval(() => {
        const player = document.getElementById('player');
        if (player && !player.dataset.recordPlayerListenerAdded) {
          console.log('[RIBBON] Found #player element, attaching listeners');
          checkAudioPlayback();
          clearInterval(playerCheckInterval);
        }
      }, 100);

      // Stop checking after 10 seconds
      setTimeout(() => clearInterval(playerCheckInterval), 10000);

      console.log('ðŸŽµ Record player animations initialized (Now Playing only)');
    });
  })();
  </script>

  <script>
  // Change "Pause" to "Stop" on now playing button
  (function() {
    const updateButtonText = () => {
      const btn = document.getElementById('nowPlayingToggle');
      if (btn && btn.textContent.trim() === 'Pause') {
        btn.textContent = 'Stop';
      }
    };

    // Monitor button text changes
    const observer = new MutationObserver(updateButtonText);

    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('nowPlayingToggle');
      if (btn) {
        observer.observe(btn, {
          childList: true,
          characterData: true,
          subtree: true
        });
        updateButtonText(); // Initial check
      }
    });
  })();
  </script>

  <script>
  // Fix play button arrow disappearing after playback
  (function() {
    const playSymbol = 'â–¶';

    const fixPlayButtons = () => {
      // Find all buttons in album cards
      const buttons = document.querySelectorAll('.card button, .albums button');

      buttons.forEach(btn => {
        const text = btn.textContent.trim();
        // If button text is empty or doesn't contain play symbol, restore it
        if (text === '' || (text.length < 2 && !text.includes(playSymbol))) {
          btn.textContent = playSymbol;
        }
      });
    };

    // Run on DOM load
    document.addEventListener('DOMContentLoaded', () => {
      fixPlayButtons();

      // Monitor for changes to buttons
      const observer = new MutationObserver(() => {
        fixPlayButtons();
      });

      // Observe the albums container
      const albumsContainer = document.querySelector('.albums');
      if (albumsContainer) {
        observer.observe(albumsContainer, {
          childList: true,
          subtree: true,
          characterData: true
        });
      }

      // Also run periodically as a fallback
      setInterval(fixPlayButtons, 2000);
    });
  })();
  </script>

  <script>
  // Dark mode functionality
  (function() {
    const DARK_MODE_KEY = 'mass.darkMode';

    function applyDarkMode(isDark) {
      document.body.classList.toggle('dark-mode', isDark);
      console.log('[Dark Mode] Applied:', isDark);
    }

    // Apply saved preference immediately
    const savedMode = localStorage.getItem(DARK_MODE_KEY);
    if (savedMode !== null) {
      const isDark = savedMode === 'true';
      applyDarkMode(isDark);
    }

    // Make toggle function globally available for Settings button
    window.toggleDarkMode = function() {
      const isDark = !document.body.classList.contains('dark-mode');
      applyDarkMode(isDark);
      localStorage.setItem(DARK_MODE_KEY, isDark);
    };
  })();
  </script>

  <script>
  // Secret feature: Publish playlist to FileMaker (Ctrl+Shift+F9)
  (function() {
    document.addEventListener('keydown', async (e) => {
      // Check for Ctrl+Shift+F9 (or Cmd+Shift+F9 on Mac)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'F9') {
        console.log('[Secret] Keystroke detected: Ctrl/Cmd+Shift+F9');
        e.preventDefault();

        // Get current playlist from UI
        const playlistTracksSection = document.getElementById('playlistTracksSection');
        console.log('[Secret] playlistTracksSection:', playlistTracksSection);
        console.log('[Secret] playlistTracksSection.hidden:', playlistTracksSection?.hidden);

        if (!playlistTracksSection || playlistTracksSection.hidden) {
          console.log('[Secret] No playlist is currently open');
          alert('No playlist is currently open.\n\nPlease open a playlist first, then press Ctrl+Shift+F9 (or Cmd+Shift+F9).');
          return;
        }

        const playlistId = playlistTracksSection.dataset.playlistId;
        console.log('[Secret] Playlist ID from dataset:', playlistId);

        if (!playlistId) {
          console.log('[Secret] No playlist ID found');
          alert('Could not find playlist ID.\n\nPlease try closing and reopening the playlist.');
          return;
        }

        const confirmed = confirm('ðŸ”’ SECRET FEATURE ðŸ”’\n\nPublish this playlist to FileMaker as a Public Playlist?\n\nThis will set the PublicPlaylist field on all tracks in this playlist.');
        if (!confirmed) {
          return;
        }

        try {
          console.log(`[Secret] Publishing playlist ${playlistId} to FileMaker...`);
          const response = await fetch(`/api/playlists/${playlistId}/publish-to-filemaker`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });

          const result = await response.json();

          if (result.ok) {
            alert(`âœ… Success!\n\nPlaylist "${result.playlistName}" published to FileMaker.\n\n${result.successCount} tracks updated successfully\n${result.failCount} failed`);
            console.log('[Secret] Publish results:', result);
          } else {
            alert(`âŒ Failed to publish playlist:\n\n${result.error}`);
            console.error('[Secret] Publish failed:', result);
          }
        } catch (err) {
          alert(`âŒ Error publishing playlist:\n\n${err.message}`);
          console.error('[Secret] Publish error:', err);
        }
      }
    });
    console.log('[Secret] Playlist publish feature loaded (Ctrl+Shift+F9 or Cmd+Shift+F9)');
  })();
  </script>

  <script>
    // Sidebar Navigation
    (function() {
      const navItems = document.querySelectorAll('.nav-item[data-view]');

      navItems.forEach(item => {
        item.addEventListener('click', () => {
          const view = item.getAttribute('data-view');

          switch(view) {
            case 'home':
              // Hide playlist view and show regular content
              if (typeof hidePlaylistView === 'function') {
                hidePlaylistView();
              }
              // Remove active from all nav items and set home as active
              navItems.forEach(i => i.classList.remove('active'));
              item.classList.add('active');
              // Remove active from playlists
              document.querySelectorAll('.sidebar-playlist-btn').forEach(b => b.classList.remove('active'));
              break;
            case 'tracks':
              // TODO: Implement tracks view
              console.log('Tracks view - not yet implemented');
              break;
            case 'albums':
              // Already on classic/albums view â€” just mark active
              navItems.forEach(i => i.classList.remove('active'));
              item.classList.add('active');
              break;
            case 'favourites':
              // TODO: Implement favourites view
              console.log('Favourites view - not yet implemented');
              break;
            case 'fav-tracks':
              // TODO: Implement favourite tracks view
              console.log('Favourite tracks view - not yet implemented');
              break;
            case 'fav-albums':
              // TODO: Implement favourite albums view
              console.log('Favourite albums view - not yet implemented');
              break;
            case 'fav-artists':
              // TODO: Implement favourite artists view
              console.log('Favourite artists view - not yet implemented');
              break;
            case 'account':
              // TODO: Implement account view
              console.log('Account view - not yet implemented');
              break;
            case 'settings':
              // Toggle dark mode
              if (window.toggleDarkMode) {
                window.toggleDarkMode();
              }
              break;
          }
        });
      });

      console.log('[Sidebar] Navigation initialized');
    })();

    // Sidebar Recommended Playlists
    (function() {
      const playlistsList = document.getElementById('sidebarPlaylistsList');
      const playlistsEmpty = document.getElementById('sidebarPlaylistsEmpty');
      const playlistsHeader = document.getElementById('sidebarPlaylistsHeader');
      const sidebarPlaylists = document.querySelector('.sidebar-playlists');
      let currentPlaylist = null;

      // Toggle collapse/expand
      if (playlistsHeader && sidebarPlaylists) {
        playlistsHeader.addEventListener('click', () => {
          sidebarPlaylists.classList.toggle('collapsed');
        });
      }

      // Load recommended playlists
      async function loadRecommendedPlaylists() {
        try {
          const res = await fetch('/api/public-playlists');
          const data = await res.json();

          if (data.ok && Array.isArray(data.playlists) && data.playlists.length > 0) {
            renderPlaylists(data.playlists);
            playlistsEmpty.hidden = true;
          } else {
            playlistsEmpty.hidden = false;
          }
        } catch (err) {
          console.error('[Sidebar] Failed to load recommended playlists:', err);
          playlistsEmpty.hidden = false;
        }
      }

      function renderPlaylists(playlists) {
        playlistsList.innerHTML = '';

        playlists.forEach(playlist => {
          const li = document.createElement('li');
          li.className = 'sidebar-playlist-item';

          const btn = document.createElement('button');
          btn.className = 'sidebar-playlist-btn';
          btn.dataset.playlistName = playlist.name;

          // Thumbnail
          const thumb = document.createElement('div');
          thumb.className = 'sidebar-playlist-thumb';
          if (playlist.artwork) {
            thumb.style.backgroundImage = `url(${playlist.artwork})`;
          } else {
            thumb.textContent = 'ðŸŽµ';
          }

          // Name and count
          const name = document.createElement('span');
          name.className = 'sidebar-playlist-name';
          name.textContent = playlist.name;

          const count = document.createElement('span');
          count.className = 'sidebar-playlist-count';
          count.textContent = playlist.trackCount || '';

          btn.appendChild(thumb);
          btn.appendChild(name);
          if (playlist.trackCount) {
            btn.appendChild(count);
          }

          btn.addEventListener('click', () => handlePlaylistClick(playlist, btn));

          li.appendChild(btn);
          playlistsList.appendChild(li);
        });
      }

      async function handlePlaylistClick(playlist, btn) {
        // Remove active class from all buttons
        document.querySelectorAll('.sidebar-playlist-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        currentPlaylist = playlist.name;
        console.log('[Sidebar] Playlist clicked:', playlist.name);

        // Fetch playlist tracks
        try {
          const res = await fetch(`/api/public-playlists?name=${encodeURIComponent(playlist.name)}`);
          const data = await res.json();

          if (data.ok && data.tracks && data.tracks.length > 0) {
            // Transform tracks data using actual API field names
            const tracks = data.tracks.map(t => ({
              name: t.name || 'Unknown Track',
              artist: t.trackArtist || t.albumArtist || 'Unknown Artist',
              album: t.albumTitle || 'Unknown Album',
              albumArtist: t.albumArtist || '',
              artworkUrl: t.picture || t.albumPicture || '/img/placeholder.jpg',
              genre: t.genre || '',
              year: t.year || '',
              duration: t.duration || '3:15',
              audioUrl: t.resolvedSrc || t.mp3 || ''
            }));

            // Show the playlist view
            if (typeof showPlaylistView === 'function') {
              showPlaylistView(playlist.name, tracks);
            }
          } else {
            console.log('[Sidebar] No tracks found for playlist:', playlist.name);
          }
        } catch (err) {
          console.error('[Sidebar] Failed to load playlist tracks:', err);
        }
      }

      // Initialize on access ready
      window.addEventListener('mass:access-ready', () => {
        loadRecommendedPlaylists();
      });

      // Check if already ready
      if (window.massAccessReady) {
        loadRecommendedPlaylists();
      }

      console.log('[Sidebar] Recommended playlists initialized');
    })();

    // Sidebar My Playlists
    (function() {
      const myPlaylistsSection = document.getElementById('sidebarMyPlaylists');
      const myPlaylistsList = document.getElementById('sidebarMyPlaylistsList');
      const myPlaylistsEmpty = document.getElementById('sidebarMyPlaylistsEmpty');
      const myPlaylistsHeader = document.getElementById('sidebarMyPlaylistsHeader');
      const createForm = document.getElementById('sidebarPlaylistCreateForm');
      const nameInput = document.getElementById('sidebarPlaylistNameInput');
      let currentUserEmail = null;

      // Toggle collapse/expand
      if (myPlaylistsHeader && myPlaylistsSection) {
        myPlaylistsHeader.addEventListener('click', () => {
          myPlaylistsSection.classList.toggle('collapsed');
        });
      }

      // Load user's playlists
      async function loadMyPlaylists() {
        try {
          const res = await fetch('/api/playlists');
          const data = await res.json();

          if (data.ok && Array.isArray(data.playlists)) {
            if (data.playlists.length > 0) {
              renderMyPlaylists(data.playlists);
              myPlaylistsEmpty.hidden = true;
              myPlaylistsSection.hidden = false;
            } else {
              myPlaylistsEmpty.hidden = false;
              myPlaylistsSection.hidden = false;
            }
          }
        } catch (err) {
          console.error('[Sidebar] Failed to load my playlists:', err);
          // User might not be authenticated, keep section hidden
        }
      }

      function renderMyPlaylists(playlists) {
        myPlaylistsList.innerHTML = '';

        playlists.forEach(playlist => {
          const li = document.createElement('li');
          li.className = 'sidebar-playlist-item';

          const btn = document.createElement('button');
          btn.className = 'sidebar-playlist-btn';
          btn.dataset.playlistId = playlist.id;

          // Thumbnail (use default music icon)
          const thumb = document.createElement('div');
          thumb.className = 'sidebar-playlist-thumb';
          thumb.textContent = 'ðŸŽµ';

          // Name and count
          const name = document.createElement('span');
          name.className = 'sidebar-playlist-name';
          name.textContent = playlist.name;

          const count = document.createElement('span');
          count.className = 'sidebar-playlist-count';
          count.textContent = playlist.tracks?.length || 0;

          btn.appendChild(thumb);
          btn.appendChild(name);
          btn.appendChild(count);

          btn.addEventListener('click', () => handleMyPlaylistClick(playlist, btn));

          li.appendChild(btn);
          myPlaylistsList.appendChild(li);
        });
      }

      function handleMyPlaylistClick(playlist, btn) {
        document.querySelectorAll('.sidebar-playlist-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const tracks = (playlist.tracks || []).map(t => ({
          name: t.name || t.trackName || 'Unknown Track',
          artist: t.artist || t.trackArtist || t.albumArtist || 'Unknown Artist',
          album: t.album || t.albumTitle || 'Unknown Album',
          albumArtist: t.albumArtist || t.artist || '',
          artworkUrl: t.artworkUrl || t.artwork || '/img/placeholder.jpg',
          genre: t.genre || '',
          year: t.year || '',
          duration: t.duration || '',
          audioUrl: t.audioUrl || t.S3_URL || t.mp3 || ''
        }));

        if (typeof showPlaylistView === 'function') {
          showPlaylistView(playlist.name, tracks);
        }
      }

      // Handle playlist creation
      if (createForm) {
        createForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          const name = nameInput.value.trim();

          if (!name) return;

          try {
            const res = await fetch('/api/playlists', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name })
            });

            const data = await res.json();

            if (data.ok) {
              nameInput.value = '';
              loadMyPlaylists(); // Reload playlists
              console.log('[Sidebar] Playlist created:', name);
            } else {
              console.error('[Sidebar] Failed to create playlist:', data.error);
            }
          } catch (err) {
            console.error('[Sidebar] Playlist creation error:', err);
          }
        });
      }

      // Expose for external reload (e.g. after creating a playlist via modal)
      window.reloadSidebarPlaylists = loadMyPlaylists;

      // Initialize on access ready
      window.addEventListener('mass:access-ready', () => {
        loadMyPlaylists();
      });

      // Check if already ready
      if (window.massAccessReady) {
        loadMyPlaylists();
      }

      console.log('[Sidebar] My playlists initialized');
    })();
  </script>

  <script>
  // Player time display and controls
  (function() {
    function formatTime(seconds) {
      if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    document.addEventListener('DOMContentLoaded', () => {
      const player = document.getElementById('player');
      const currentTimeEl = document.getElementById('playerCurrentTime');
      const durationEl = document.getElementById('playerDuration');
      const progressBar = document.getElementById('playerProgressBar');
      const progressFill = document.getElementById('nowPlayingProgressFill');
      const prevBtn = document.getElementById('playerPrev');
      const nextBtn = document.getElementById('playerNext');
      const volumeBtn = document.getElementById('volumeBtn');
      const volumeSlider = document.getElementById('volumeSlider');
      const volumeFill = document.getElementById('volumeFill');

      if (!player) return;

      // Update time display
      player.addEventListener('timeupdate', () => {
        if (currentTimeEl) currentTimeEl.textContent = formatTime(player.currentTime);
        if (progressFill && player.duration) {
          const percent = (player.currentTime / player.duration) * 100;
          progressFill.style.width = percent + '%';
        }
      });

      player.addEventListener('loadedmetadata', () => {
        if (durationEl) durationEl.textContent = formatTime(player.duration);
      });

      player.addEventListener('durationchange', () => {
        if (durationEl) durationEl.textContent = formatTime(player.duration);
      });

      // Click on progress bar to seek
      if (progressBar) {
        progressBar.addEventListener('click', (e) => {
          const rect = progressBar.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          if (player.duration) {
            player.currentTime = percent * player.duration;
          }
        });
      }

      // Volume control
      if (volumeSlider && volumeFill) {
        volumeSlider.addEventListener('click', (e) => {
          const rect = volumeSlider.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          player.volume = Math.max(0, Math.min(1, percent));
          volumeFill.style.width = (player.volume * 100) + '%';
        });
      }

      // Prev/Next buttons
      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          if (window.__isDetailViewActive && window.__isDetailViewActive()) {
            // <= 3s: go to previous track; > 3s: restart current
            if (player.currentTime <= 3) {
              window.__advanceDetailTrack('prev');
            } else {
              player.currentTime = 0;
            }
          } else {
            if (player.currentTime > 3) player.currentTime = 0;
          }
        });
      }
      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          if (window.__isDetailViewActive && window.__isDetailViewActive()) {
            window.__advanceDetailTrack('next');
          }
        });
      }

      console.log('[Player] Time display initialized');
    });
  })();
  </script>

    </div> <!-- /main-wrapper -->
  </div> <!-- /app-wrapper -->

  <!-- Album Detail View Override - Shows two-column layout instead of modal -->
  <script>
  (function() {
    'use strict';

    // Wait for app.min.js to load
    window.addEventListener('load', function() {
      // Store reference to original openTracksModal if it exists
      const originalOpenTracksModal = window.openTracksModal;

      // New function to show album detail view (two-column layout)
      window.showAlbumDetailView = async function(album, relatedAlbums = []) {
        const playlistView = document.getElementById('playlistView');
        const layoutGrid = document.querySelector('.layout-grid');
        const playlistTitle = document.getElementById('playlistViewTitle');
        const playlistSubtitle = document.querySelector('.playlist-view-subtitle');
        const albumsList = document.getElementById('playlistAlbumsList');
        const albumDetail = document.getElementById('playlistAlbumDetail');

        if (!playlistView || !layoutGrid) return;

        // Update title to album title
        if (playlistTitle) playlistTitle.textContent = album.artist || 'Album';
        if (playlistSubtitle) playlistSubtitle.textContent = 'Artist';

        // Hide regular grid, show playlist view
        layoutGrid.style.display = 'none';
        playlistView.classList.add('active');

        // Fetch more albums by the same artist for the left column
        let artistAlbums = relatedAlbums;
        if (artistAlbums.length === 0 && album.artist) {
          try {
            const response = await fetch(`/api/search?artist=${encodeURIComponent(album.artist)}&limit=500`);
            const data = await response.json();
            if (data.items && data.items.length > 0) {
              // Group items by album
              const albumsMap = new Map();
              data.items.forEach(item => {
                const f = item.fields || {};
                const albumTitle = f['Album Title'] || f['Tape Files::Album Title'] || 'Unknown Album';
                if (!albumsMap.has(albumTitle)) {
                  albumsMap.set(albumTitle, {
                    title: albumTitle,
                    artist: f['Album Artist'] || f['Tape Files::Album Artist'] || f['Track Artist'] || album.artist,
                    artwork: f['Tape Files::Artwork_S3_URL'] || f['Artwork::Picture'] || '/img/placeholder.jpg',
                    genre: f['Genre'] || f['Local Genre'] || '',
                    year: f['Year of Release'] || f['Year Recorded'] || '',
                    tracks: []
                  });
                }
                albumsMap.get(albumTitle).tracks.push({
                  name: f['Track Name'] || 'Unknown Track',
                  artist: f['Track Artist'] || '',
                  duration: f['Duration'] || '3:15',
                  audioUrl: f['S3_URL'] || f['mp3'] || '',
                  recordId: item.recordId || ''
                });
              });
              artistAlbums = Array.from(albumsMap.values());
            }
          } catch (err) {
            console.warn('[AlbumDetailView] Failed to fetch artist albums:', err);
          }
        }

        // Always ensure the clicked album is in the list with its original (high-quality) track data
        const clickedEntry = {
          title: album.title,
          artist: album.artist,
          artwork: album.picture || '/img/placeholder.jpg',
          genre: album.genre || '',
          year: album.year || '',
          tracks: album.tracks || []
        };
        const existingIdx = artistAlbums.findIndex(a => a.title === album.title);
        if (existingIdx !== -1) {
          artistAlbums[existingIdx] = clickedEntry;
        } else {
          artistAlbums.unshift(clickedEntry);
        }

        // Populate album list (left column)
        albumsList.innerHTML = artistAlbums.map((a, index) => {
          const artUrl = a.artwork && a.artwork.includes('://') ? a.artwork :
                        (a.artwork ? `/api/container?u=${encodeURIComponent(a.artwork)}` : '/img/placeholder.jpg');
          const isSelected = a.title === album.title;
          return `
            <div class="playlist-album-item ${isSelected ? 'selected' : ''}" data-album-index="${index}">
              <div class="playlist-album-thumb">
                <img src="${artUrl}" alt="${a.title}" onerror="this.src='/img/placeholder.jpg'">
              </div>
              <div class="playlist-album-info">
                <h3 class="playlist-album-name">${a.title}</h3>
                <p class="playlist-album-artist">${a.artist}</p>
                <p class="playlist-album-genre" style="font-size:12px;color:#888888;margin:0;">${a.genre || ''}</p>
                <div class="playlist-album-stats">
                  <span class="playlist-album-stat">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                    ${Math.floor(Math.random() * 50)}K
                  </span>
                  <span class="playlist-album-stat">
                    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
                    ${Math.floor(Math.random() * 30)}
                  </span>
                </div>
              </div>
            </div>
          `;
        }).join('');

        // Add click handlers to album items
        albumsList.querySelectorAll('.playlist-album-item').forEach(item => {
          item.addEventListener('click', () => {
            albumsList.querySelectorAll('.playlist-album-item').forEach(i => i.classList.remove('selected'));
            item.classList.add('selected');
            const albumIndex = parseInt(item.dataset.albumIndex);
            showAlbumDetailPanel(artistAlbums[albumIndex]);
          });
        });

        // Show the selected album in the right panel
        const selectedAlbum = artistAlbums.find(a => a.title === album.title) || artistAlbums[0];
        showAlbumDetailPanel(selectedAlbum);
      };

      // Function to show album details in the right panel
      window.showAlbumDetailPanel = function(album) {
        const artwork = document.getElementById('playlistDetailArtwork');
        const title = document.getElementById('playlistDetailTitle');
        const artist = document.getElementById('playlistDetailArtist');
        const genre = document.getElementById('playlistDetailGenre');
        const year = document.getElementById('playlistDetailYear');
        const plays = document.getElementById('playlistDetailPlays');
        const repeats = document.getElementById('playlistDetailRepeats');
        const trackList = document.getElementById('playlistTrackList');

        // Set artwork
        if (artwork) {
          const artUrl = album.artwork && album.artwork.includes('://') ? album.artwork :
                        (album.artwork ? `/api/container?u=${encodeURIComponent(album.artwork)}` : '/img/placeholder.jpg');
          artwork.src = artUrl;
          artwork.onerror = () => { artwork.src = '/img/placeholder.jpg'; };
        }

        if (title) title.textContent = album.title;
        if (artist) artist.textContent = album.artist;
        if (genre) genre.textContent = album.genre || 'MUSIC';
        if (year) year.textContent = album.year || '';
        if (plays) plays.textContent = Math.floor(Math.random() * 50) + 'K';
        if (repeats) repeats.textContent = Math.floor(Math.random() * 10);

        // Add click handler to artist name for search
        if (artist && album.artist) {
          artist.style.cursor = 'pointer';
          artist.onclick = () => {
            const searchArtist = document.getElementById('searchArtist');
            const searchFields = document.getElementById('searchFields');
            const goBtn = document.getElementById('go');
            if (searchArtist && goBtn) {
              searchArtist.value = album.artist;
              if (searchFields) searchFields.hidden = false;
              goBtn.click();
            }
          };
        }

        // Wire up album-level action buttons
        const addAlbumToPlaylistBtn = document.getElementById('addAlbumToPlaylistBtn');
        const addAlbumToLibraryBtn = document.getElementById('addAlbumToLibraryBtn');

        if (addAlbumToPlaylistBtn) {
          addAlbumToPlaylistBtn.onclick = () => {
            if (typeof window.handleAddAlbumToPlaylist === 'function') {
              window.handleAddAlbumToPlaylist(album);
            }
          };
        }

        if (addAlbumToLibraryBtn) {
          // Check saved state
          fetch('/api/library').then(r => r.json()).then(data => {
            const saved = (data.albums || []).find(a => a.title === album.title && a.artist === album.artist);
            if (saved) {
              addAlbumToLibraryBtn.classList.add('saved');
              addAlbumToLibraryBtn.dataset.libraryId = saved.id;
              addAlbumToLibraryBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> â™¥ Saved`;
            }
          }).catch(() => {});

          addAlbumToLibraryBtn.onclick = async () => {
            if (addAlbumToLibraryBtn.dataset.libraryId) {
              // Remove from library
              const res = await fetch(`/api/library/albums/${addAlbumToLibraryBtn.dataset.libraryId}`, { method: 'DELETE' });
              if ((await res.json()).ok) {
                addAlbumToLibraryBtn.classList.remove('saved');
                delete addAlbumToLibraryBtn.dataset.libraryId;
                addAlbumToLibraryBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> â™¡ Albums`;
              }
            } else {
              // Add to library
              const artworkUrl = album.picture || album.artwork || '';
              const res = await fetch('/api/library/albums', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title: album.title, artist: album.artist, artwork: artworkUrl, genre: album.genre || '', year: album.year || '' })
              });
              const data = await res.json();
              if (data.ok) {
                const saved = data.album;
                addAlbumToLibraryBtn.classList.add('saved');
                addAlbumToLibraryBtn.dataset.libraryId = saved.id;
                addAlbumToLibraryBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> â™¥ Saved`;
              }
            }
          };
        }

        // Populate track list
        if (trackList && album.tracks && album.tracks.length > 0) {
          trackList.innerHTML = album.tracks.map((track, index) => `
            <div class="playlist-track-item" data-track-index="${index}" data-audio-url="${track.S3_URL || track.resolvedSrc || track.audioUrl || ''}" data-record-id="${track.recordId || ''}">
              <span class="playlist-track-number">${index + 1}.</span>
              <span class="playlist-track-name">${track.name || 'Unknown Track'}</span>
              <span class="playlist-track-duration">${track.duration || '3:15'}</span>
              <div class="playlist-track-actions">
                <button class="track-action-btn track-add-playlist" data-track-index="${index}">+ Playlist</button>
                <button class="track-action-btn track-add-library" data-track-index="${index}">â™¡ Songs</button>
              </div>
            </div>
          `).join('');

          // Add click handlers to tracks
          trackList.querySelectorAll('.playlist-track-item').forEach(item => {
            item.addEventListener('click', async () => {
              const trackIndex = parseInt(item.dataset.trackIndex);
              const track = album.tracks[trackIndex];
              let audioUrl = item.dataset.audioUrl;

              // Try to get audio URL if not available
              if (!audioUrl && item.dataset.recordId) {
                try {
                  const response = await fetch(`/api/track/${item.dataset.recordId}/container`);
                  const data = await response.json();
                  if (data.url) audioUrl = data.url;
                } catch (err) {
                  console.warn('[Track] Failed to get audio URL:', err);
                }
              }

              // Resolve non-S3 HTTPS URLs through the container proxy (adds auth headers)
              if (audioUrl && /^https?:\/\//i.test(audioUrl) && !/\.s3[.-]/.test(audioUrl) && !audioUrl.includes('/api/container?')) {
                audioUrl = `/api/container?u=${encodeURIComponent(audioUrl)}`;
              }

              // Play the track
              const player = document.getElementById('player');
              if (player && audioUrl) {
                player.src = audioUrl;
                player.play().catch(err => console.warn('[Player] Playback failed:', err));

                // Update mini player
                const nowPlayingTitle = document.getElementById('nowPlayingTitle');
                const nowPlayingSubtitle = document.getElementById('nowPlayingSubtitle');
                const nowPlayingThumb = document.getElementById('nowPlayingThumb');

                if (nowPlayingTitle) nowPlayingTitle.textContent = track.name || 'Unknown Track';
                if (nowPlayingSubtitle) nowPlayingSubtitle.textContent = album.artist || '';
                if (nowPlayingThumb) {
                  const artUrl = album.artwork && album.artwork.includes('://') ? album.artwork :
                                (album.artwork ? `/api/container?u=${encodeURIComponent(album.artwork)}` : '/img/placeholder.jpg');
                  const thumbImg = document.getElementById('nowPlayingThumbImg') || nowPlayingThumb.querySelector('img');
                  if (thumbImg) {
                    thumbImg.src = artUrl;
                  } else {
                    nowPlayingThumb.innerHTML = `<img src="${artUrl}" alt="Album art" style="width:100%;height:100%;object-fit:cover;border-radius:6px;">`;
                  }
                }
              }

              // Mark as playing
              trackList.querySelectorAll('.playlist-track-item').forEach(t => t.classList.remove('playing'));
              item.classList.add('playing');
            });

            // + Playlist button
            const addPlaylistBtn = item.querySelector('.track-add-playlist');
            if (addPlaylistBtn) {
              addPlaylistBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const trackIndex = parseInt(addPlaylistBtn.dataset.trackIndex);
                const track = album.tracks[trackIndex];
                if (typeof window.handleAddToPlaylist === 'function') {
                  const audioUrl = track.S3_URL || track.resolvedSrc || track.audioUrl || track.mp3 || '';
                  window.handleAddToPlaylist(album, track, audioUrl);
                }
              });
            }

            // â™¡ Songs (library) button
            const addLibraryBtn = item.querySelector('.track-add-library');
            if (addLibraryBtn) {
              const trackIndex = parseInt(addLibraryBtn.dataset.trackIndex);
              const track = album.tracks[trackIndex];
              // Check saved state on render
              fetch('/api/library').then(r => r.json()).then(data => {
                const saved = (data.songs || []).find(s => s.trackRecordId && s.trackRecordId === (track.recordId || ''));
                if (saved) {
                  addLibraryBtn.classList.add('saved');
                  addLibraryBtn.dataset.libraryId = saved.id;
                  addLibraryBtn.textContent = 'â™¥ Saved';
                }
              }).catch(() => {});

              addLibraryBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (addLibraryBtn.dataset.libraryId) {
                  const res = await fetch(`/api/library/songs/${addLibraryBtn.dataset.libraryId}`, { method: 'DELETE' });
                  if ((await res.json()).ok) {
                    addLibraryBtn.classList.remove('saved');
                    delete addLibraryBtn.dataset.libraryId;
                    addLibraryBtn.textContent = 'â™¡ Songs';
                  }
                } else {
                  const res = await fetch('/api/library/songs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      trackRecordId: track.recordId || '',
                      name: track.name || 'Unknown Track',
                      albumTitle: album.title || '',
                      albumArtist: album.artist || '',
                      trackArtist: track.trackArtist || track.artist || '',
                      artwork: album.picture || album.artwork || '',
                      S3_URL: track.S3_URL || '',
                      mp3: track.mp3 || ''
                    })
                  });
                  const data = await res.json();
                  if (data.ok) {
                    addLibraryBtn.classList.add('saved');
                    addLibraryBtn.dataset.libraryId = data.song.id;
                    addLibraryBtn.textContent = 'â™¥ Saved';
                  }
                }
              });
            }
          });
        } else {
          trackList.innerHTML = '<div style="padding:20px;color:var(--muted);text-align:center;">No tracks available</div>';
        }
      };

      // Close button for album detail view
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          hideAlbumDetailView();
        }
      });

      // Back button click handler
      const backBtn = document.getElementById('playlistBackBtn');
      if (backBtn) {
        backBtn.addEventListener('click', () => {
          hideAlbumDetailView();
        });
      }

      window.hideAlbumDetailView = function() {
        const playlistView = document.getElementById('playlistView');
        const layoutGrid = document.querySelector('.layout-grid');

        if (playlistView) playlistView.classList.remove('active');
        if (layoutGrid) layoutGrid.style.display = 'flex';

        // Remove active state from sidebar items
        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
        document.querySelectorAll('.sidebar-playlist-btn').forEach(b => b.classList.remove('active'));

        // Re-activate Home button
        const homeBtn = document.querySelector('[data-view="home"]');
        if (homeBtn) homeBtn.classList.add('active');
      };

      // Override openTracksModal to use our new view
      window.openTracksModal = function(album, sourceCard) {
        console.log('[AlbumDetailView] Intercepted openTracksModal for:', album.title);
        window.showAlbumDetailView(album);
      };

      console.log('[AlbumDetailView] Album detail view override initialized');
    });
  })();
  </script>

</body>
</html>
