    const albumsEl = document.getElementById('albums');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const searchEl = document.getElementById('search');
    const searchArtistEl = document.getElementById('searchArtist');
    const searchAlbumEl = document.getElementById('searchAlbum');
    const searchTrackEl = document.getElementById('searchTrack');
    const clearEl  = document.getElementById('clear');
    const goEl  = document.getElementById('go');
    const aiSearchPanel = document.getElementById('aiSearchPanel');
    const aiSearchToggle = document.getElementById('aiSearchToggle');
    const aiSearchInput = document.getElementById('aiSearchInput');
    const aiSearchButton = document.getElementById('aiSearchButton');
    const aiSearchStatus = document.getElementById('aiSearchStatus');
    const aiSearchStatusText = document.getElementById('aiSearchStatusText');
    const aiSearchInterpretation = document.getElementById('aiSearchInterpretation');
    const themeToggle = document.getElementById('themeToggle');
    const headerEl = document.querySelector('header');
    const pagerEl  = document.getElementById('pager');
    const prevEl   = document.getElementById('prev');
    const nextEl   = document.getElementById('next');
    const pageInfo = document.getElementById('pageInfo');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const shufflePlayBtn = document.getElementById('shufflePlayBtn');
    const randomStopBtn = document.getElementById('randomStopBtn');
    const randomSkipBtn = document.getElementById('randomSkipBtn');
    const countEl  = document.getElementById('count');
    const errorEl  = document.getElementById('error');
    const player   = document.getElementById('player');
    const landingEl = null; // placeholder removed
    const exploreEl = document.getElementById('explore');
    const explorePanel = document.getElementById('explorePanel');
    const exploreDecadesEl = document.getElementById('exploreDecades');
    const exploreGenresEl = document.getElementById('exploreGenres');
    const exploreMoodsEl = document.getElementById('exploreMoods');
    const publicFeaturedRow = null; // Removed - featured playlists now in sidebar

    // Modal elements
    const overlay = document.getElementById('overlay');
    const modalCover = document.getElementById('modalCover');
    const modalTitle = document.getElementById('modalTitle');
    const modalArtist = document.getElementById('modalArtist');
    const modalCat = document.getElementById('modalCat');
    const modalContent = document.getElementById('modalContent');
    const modalClose = document.getElementById('modalClose');
    const trackInfoOverlay = document.getElementById('trackInfoOverlay');
    const trackInfoDialog = document.getElementById('trackInfoDialog');
    const trackInfoBody = document.getElementById('trackInfoBody');
    const trackInfoClose = document.getElementById('trackInfoClose');

    const playlistColumn = document.getElementById('playlistColumn');
    const publicPlaylistsPanel = document.getElementById('publicPlaylistsPanel');
    const publicPlaylistsHeader = document.getElementById('publicPlaylistsHeader');
    const publicPlaylistsList = document.getElementById('publicPlaylistsList');
    const publicPlaylistsEmpty = document.getElementById('publicPlaylistsEmpty');
    const playlistsPanel = document.getElementById('playlistsPanel');
    const playlistsHeader = document.getElementById('playlistsHeader');
    const playlistsList = document.getElementById('playlistsList');
    const playlistsStatus = document.getElementById('playlistsStatus');
    const playlistsEmpty = document.getElementById('playlistsEmpty');
    const playlistCreateForm = document.getElementById('playlistCreateForm');
    const playlistNameInput = document.getElementById('playlistNameInput');
    const nowPlayingCard = document.getElementById('nowPlayingCard');
    const nowPlayingThumb = document.getElementById('nowPlayingThumb');
    const nowPlayingTitle = document.getElementById('nowPlayingTitle');
    const nowPlayingSubtitle = document.getElementById('nowPlayingSubtitle');
    const nowPlayingSource = document.getElementById('nowPlayingSource');
    const nowPlayingStatus = document.getElementById('nowPlayingStatus');
    const nowPlayingMetaButtons = document.getElementById('nowPlayingMetaButtons');
    const nowPlayingAddButton = document.getElementById('nowPlayingAdd');
    const nowPlayingToggleButton = document.getElementById('nowPlayingToggle');
    const nowPlayingCollapseButton = document.getElementById('nowPlayingCollapse');
    const nowPlayingProgressFill = document.getElementById('nowPlayingProgressFill');
    const playlistTracksSection = document.getElementById('playlistTracksSection');
    const playlistTracksTitle = document.getElementById('playlistTracksTitle');
    const playlistTracksMeta = document.getElementById('playlistTracksMeta');
    const playlistTracksList = document.getElementById('playlistTracksList');
    const playlistTracksEmpty = document.getElementById('playlistTracksEmpty');
    const togglePlaylistTracksButton = document.getElementById('togglePlaylistTracks');
    const sharePlaylistButton = document.getElementById('sharePlaylistButton');
    const shareLinkOutput = document.getElementById('shareLinkOutput');
    const deletePlaylistButton = document.getElementById('deletePlaylistButton');
    const publicPlaylistView = document.getElementById('publicPlaylistView');
    const publicPlaylistTitle = document.getElementById('publicPlaylistTitle');
    const publicPlaylistMeta = document.getElementById('publicPlaylistMeta');
    const publicPlaylistStatus = document.getElementById('publicPlaylistStatus');
    const publicPlaylistHero = document.getElementById('publicPlaylistHero');
    const publicPlaylistArt = document.getElementById('publicPlaylistArt');
    const publicPlaylistTracks = document.getElementById('publicPlaylistTracks');
    const publicPlaylistEmpty = document.getElementById('publicPlaylistEmpty');
    const sharedPlaylistView = document.getElementById('sharedPlaylistView');
    const sharedPlaylistTitle = document.getElementById('sharedPlaylistTitle');
    const sharedPlaylistMeta = document.getElementById('sharedPlaylistMeta');
    const sharedPlaylistStatus = document.getElementById('sharedPlaylistStatus');
    const sharedPlaylistHero = document.getElementById('sharedPlaylistHero');
    const sharedPlaylistArt = document.getElementById('sharedPlaylistArt');
    const sharedPlaylistTracks = document.getElementById('sharedPlaylistTracks');
    const sharedPlaylistEmpty = document.getElementById('sharedPlaylistEmpty');
    const sharedPlaylistBackButton = document.getElementById('sharedPlaylistBack');
    const sharedPlaylistCopyButton = document.getElementById('sharedPlaylistCopy');

    const authControls = document.getElementById('authControls');
    const loginTrigger = document.getElementById('loginTrigger');
    const signupTrigger = document.getElementById('signupTrigger');
    const logoutButton = document.getElementById('logoutButton');
    const userBadge = document.getElementById('userBadge');
    const authOverlay = document.getElementById('authOverlay');
    const authDialog = document.getElementById('authDialog');
    const authClose = document.getElementById('authClose');
    const authForm = document.getElementById('authForm');
    const authTitle = document.getElementById('authTitle');
    const authEmail = document.getElementById('authEmail');
    const authPassword = document.getElementById('authPassword');
    const authSubmit = document.getElementById('authSubmit');
    const authSwitch = document.getElementById('authSwitchMode');
    const authToggleText = document.getElementById('authToggleText');
    const authError = document.getElementById('authError');

    const shareModal = document.getElementById('shareModal');
    const shareLinkInput = document.getElementById('shareLinkInput');
    const shareModalClose = document.getElementById('shareModalClose');

    function ensurePlaylistColumnVisible(){
      if (!playlistColumn) return;
      playlistColumn.hidden = false;
    }

    const exportPlaylistButton = document.getElementById('exportPlaylistButton');
    const exportModal = document.getElementById('exportModal');
    const exportCodeInput = document.getElementById('exportCodeInput');
    const exportCopyBtn = document.getElementById('exportCopyBtn');
    const exportDownloadBtn = document.getElementById('exportDownloadBtn');
    const exportModalClose = document.getElementById('exportModalClose');

    const importPlaylistButton = document.getElementById('importPlaylistButton');
    const importModal = document.getElementById('importModal');
    const importCodeInput = document.getElementById('importCodeInput');
    const importFileInput = document.getElementById('importFileInput');
    const importSubmitBtn = document.getElementById('importSubmitBtn');
    const importStatus = document.getElementById('importStatus');
    const importModalClose = document.getElementById('importModalClose');

    const trackInfoFocusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    let trackInfoReturnFocus = null;
    let trackInfoFocusables = [];

    let authReturnFocus = null;
    let authMode = 'login';
    let authBusy = false;
    let currentUser = null;
    let playlists = [];
    let playlistsLoaded = false;
    let playlistsLoading = false;
    let activePlaylistId = null;
    let playlistTracksCollapsed = true;
    let nowPlayingInfo = { meta: null, isPlaying: false };
    let nowPlayingAddBusy = false;
    let nowPlayingCollapsed = false;
    let publicPlaylistsLoaded = false;
    let publicPlaylistsLoading = false;
    let publicPlaylistsError = null;
    let publicPlaylistTracksLoading = false;
    let publicPlaylistTracksError = null;
    const publicPlaylistTracksCache = new Map();
    let activePublicPlaylistTracks = [];
    let publicPlaylistsSummary = [];
    let activePublicPlaylist = null;
    let activePublicPlaylistImage = '';
    let sharedPlaylistActive = false;
    let sharedPlaylistLoading = false;
    let sharedPlaylistError = null;
    let sharedPlaylistData = null;
    let activeSharedShareId = '';
    let sharedPlaylistShareUrl = '';

    const STREAM_EVENTS_ENDPOINT = '/api/stream-events';
    const STREAM_SESSION_STORAGE_KEY = 'mass.session';
    const STREAM_PROGRESS_INTERVAL_MS = 30 * 1000;
    const STREAM_DEBUG = Boolean(window.massStreamDebug);
    let streamSessionId = null;
    try {
      streamSessionId = localStorage.getItem(STREAM_SESSION_STORAGE_KEY);
    } catch {
      streamSessionId = null;
    }
    if (!streamSessionId) {
      const fallbackId = (window.crypto && typeof window.crypto.randomUUID === 'function')
        ? window.crypto.randomUUID()
        : Math.random().toString(36).slice(2);
      streamSessionId = fallbackId;
      try {
        localStorage.setItem(STREAM_SESSION_STORAGE_KEY, streamSessionId);
      } catch {
        // ignore storage failures; rely on cookie fallback from server
      }
    }
    let lastStreamReportTs = 0;
    let lastStreamReportPos = 0;
    let lastProgressSentAt = 0;
    let lastProgressAttemptTs = 0;
    let seekStartPosition = 0;

    function getCurrentTrackMeta(){
      return (nowPlayingInfo && nowPlayingInfo.meta) || {};
    }

    function toSeconds(value){
      const numeric = typeof value === 'number' ? value : Number(value);
      if (!Number.isFinite(numeric)) return 0;
      return Math.max(0, Math.round(numeric));
    }

    async function sendStreamEvent(type, metaOverride, positionOverride, durationOverride, deltaOverride){
      if (typeof fetch !== 'function') return false;
      const requestTs = Date.now();
      const meta = metaOverride && typeof metaOverride === 'object' ? metaOverride : getCurrentTrackMeta();
      const rawPos = typeof positionOverride === 'number' ? positionOverride : player?.currentTime || 0;
      const rawDur = typeof durationOverride === 'number' ? durationOverride : player?.duration || 0;
      const normalizedPos = toSeconds(rawPos);
      const normalizedDur = toSeconds(rawDur);
      const hasOverride = Number.isFinite(deltaOverride);
      const overrideDelta = hasOverride ? Math.max(0, Math.round(deltaOverride)) : 0;
      const deltaFromPos = Math.max(0, normalizedPos - (Number.isFinite(lastStreamReportPos) ? lastStreamReportPos : 0));
      const deltaFromTime = lastStreamReportTs ? Math.max(0, Math.round((requestTs - lastStreamReportTs) / 1000)) : 0;
      const normalizedDelta = hasOverride ? overrideDelta : (deltaFromPos || deltaFromTime);

      const body = {
        eventType: type,
        trackRecordId: meta.trackRecordId || meta.recordId || meta.id || '',
        trackISRC: meta.trackISRC || meta.isrc || meta.ISRC || '',
        positionSec: normalizedPos,
        durationSec: normalizedDur,
        deltaSec: normalizedDelta
      };

      let responseJson = null;
      try {
        const response = await fetch(STREAM_EVENTS_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Session-ID': streamSessionId
          },
          body: JSON.stringify(body)
        });
        if (!response.ok) {
          let detail = '';
          try {
            const mime = response.headers?.get ? response.headers.get('Content-Type') : '';
            if (mime && mime.includes('application/json')) {
              responseJson = await response.json();
              detail = responseJson?.error || JSON.stringify(responseJson);
            } else {
              detail = await response.text();
            }
          } catch {
            // ignore parsing errors
          }
          console.warn('[MASS] stream event rejected', { status: response.status, detail, body });
          return false;
        }
        responseJson = await response.json().catch(() => null);
        if (!responseJson?.ok) {
          console.warn('[MASS] stream event server reported failure', { response: responseJson, body });
          return false;
        }
        if (STREAM_DEBUG) {
          console.info('[MASS] stream event sent', {
            type,
            trackRecordId: body.trackRecordId,
            positionSec: body.positionSec,
            deltaSec: body.deltaSec,
            recordId: responseJson.recordId || null,
            totalPlayedSec: responseJson.totalPlayedSec || null
          });
        }
      } catch (err) {
        console.warn('[MASS] stream event send failed', err, body);
        return false;
      }

      lastStreamReportTs = requestTs;
      lastStreamReportPos = normalizedPos;
      if (type === 'PROGRESS') {
        lastProgressSentAt = requestTs;
      }
      return true;
    }

    // Config
    const ALBUMS_PER_PAGE = 8;
    const FM_FETCH_LIMIT  = 10; // Small page size keeps searches fast
    const PLAYLIST_ARTWORK_BASE = '/img/playlists/';
    const PLAYLIST_ARTWORK_EXTENSIONS = ['.webp', '.png', '.jpg', '.jpeg', '.avif'];

    function normalizePlaylistName(name){
      return (name || '')
        .toString()
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[’']/g, "'")
        .trim();
    }

    function slugifyPlaylistName(name){
      return normalizePlaylistName(name)
        .toLowerCase()
        .replace(/&/g, ' and ')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    }

    function buildPlaylistArtworkCandidates(name){
      const normalized = normalizePlaylistName(name);
      const slug = slugifyPlaylistName(name);
      const baseNames = new Set();
      const addCandidate = (value) => {
        const trimmed = (value || '').trim();
        if (trimmed) baseNames.add(trimmed);
      };

      if (normalized) {
        addCandidate(normalized);
        addCandidate(normalized.replace(/&/g, ' and '));
        const collapsed = normalized.replace(/&/g, ' and ').replace(/[^A-Za-z0-9]+/g, ' ').trim();
        if (collapsed) {
          const parts = collapsed.split(/\s+/);
          const lowerParts = parts.map((part) => part.toLowerCase());
          const titleParts = parts.map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase());
          addCandidate(parts.join(' '));
          addCandidate(parts.join('-'));
          addCandidate(parts.join('_'));
          addCandidate(lowerParts.join(' '));
          addCandidate(lowerParts.join('-'));
          addCandidate(lowerParts.join('_'));
          addCandidate(titleParts.join(' '));
          addCandidate(titleParts.join('-'));
          addCandidate(titleParts.join('_'));
          addCandidate(parts.join(''));
          addCandidate(lowerParts.join(''));
          addCandidate(titleParts.join(''));
        }
      }

      if (slug) {
        addCandidate(slug);
        addCandidate(slug.replace(/-/g, '_'));
        addCandidate(slug.replace(/-/g, ' '));
        addCandidate(slug.replace(/-/g, ''));
      }

      const candidates = [];
      baseNames.forEach((base) => {
        PLAYLIST_ARTWORK_EXTENSIONS.forEach((ext) => {
          const candidate = `${PLAYLIST_ARTWORK_BASE}${base}${ext}`;
          candidates.push(candidate);
        });
      });
      return candidates;
    }

    function resetPlaylistArtwork(imgEl, containerEl){
      if (containerEl) containerEl.hidden = true;
      if (!imgEl) return;
      imgEl.style.display = 'none';
      imgEl.removeAttribute('src');
      imgEl.removeAttribute('data-playlist-artwork-key');
      imgEl.removeAttribute('data-playlist-artwork-candidate');
      imgEl.onload = null;
      imgEl.onerror = null;
    }

    function loadPlaylistArtwork(imgEl, containerEl, name, options = {}){
      if (!imgEl) return;
      const normalized = normalizePlaylistName(name);
      const preferred = Array.isArray(options.preferredUrls)
        ? options.preferredUrls.filter((url) => typeof url === 'string' && url.trim())
        : [];
      const candidates = [
        ...preferred,
        ...(normalized ? buildPlaylistArtworkCandidates(normalized) : [])
      ];

      const altText = options.altText || (name ? `${name} artwork` : 'Playlist artwork');
      imgEl.alt = altText;

      if (!candidates.length) {
        resetPlaylistArtwork(imgEl, containerEl);
        return;
      }

      const key = `${normalized}::${candidates.join('|')}`;
      imgEl.dataset.playlistArtworkKey = key;
      if (containerEl) containerEl.hidden = true;
      imgEl.style.display = 'none';

      let index = 0;
      const applyNext = () => {
        if (imgEl.dataset.playlistArtworkKey !== key) return;
        if (index >= candidates.length) {
          resetPlaylistArtwork(imgEl, containerEl);
          return;
        }
        const nextUrl = candidates[index++];
        imgEl.dataset.playlistArtworkCandidate = nextUrl;
        imgEl.onerror = () => {
          if (imgEl.dataset.playlistArtworkKey !== key) return;
          applyNext();
        };
        imgEl.onload = () => {
          if (imgEl.dataset.playlistArtworkKey !== key) return;
          const validSize = Number(imgEl.naturalWidth) > 1 && Number(imgEl.naturalHeight) > 1;
          if (!validSize) {
            applyNext();
            return;
          }
          imgEl.style.display = 'block';
          if (containerEl) containerEl.hidden = false;
        };
        imgEl.src = nextUrl;
      };

      applyNext();
    }

    function applyPlaylistThumbArtwork(element, name, remoteUrl = ''){
      if (!element) return;
      const normalized = normalizePlaylistName(name);
      const fallbackChar = (name || '').trim().charAt(0) || '♪';
      element.textContent = fallbackChar;
      element.classList.remove('has-art');
      element.style.backgroundImage = '';

      const candidates = [];
      if (typeof remoteUrl === 'string' && remoteUrl.trim()) candidates.push(remoteUrl.trim());
      if (normalized) candidates.push(...buildPlaylistArtworkCandidates(normalized));
      if (!candidates.length) return;

      const key = `${normalized}::${candidates.join('|')}`;
      element.dataset.playlistThumbKey = key;
      let index = 0;

      const tryNext = () => {
        if (element.dataset.playlistThumbKey !== key) return;
        if (index >= candidates.length) return;
        const candidate = candidates[index++];
        const probe = new Image();
        probe.onload = () => {
          if (element.dataset.playlistThumbKey !== key) return;
          const validSize = Number(probe.naturalWidth) > 1 && Number(probe.naturalHeight) > 1;
          if (!validSize) {
            tryNext();
            return;
          }
          element.style.backgroundImage = `url(${probe.src})`;
          element.textContent = '';
          element.classList.add('has-art');
        };
        probe.onerror = () => {
          if (element.dataset.playlistThumbKey !== key) return;
          tryNext();
        };
        probe.src = candidate;
      };

      tryNext();
    }

    // State
    let lastQ = '';
    let prevSearch = null;
    let inFlight = null;
    let aiSearchController = null;

    // Busy status indicator
    const statusEl = document.getElementById('status');
    const statusTextEl = document.getElementById('statusText');
    let busyCount = 0;
    function showBusy(label='Searching…'){
      busyCount++;
      if (statusTextEl) statusTextEl.textContent = label;
      if (statusEl) statusEl.hidden = false;
      if (goEl) goEl.disabled = true;
      if (exploreEl) exploreEl.disabled = true;
        }
    function hideBusy(){
      busyCount = Math.max(0, busyCount - 1);
      if (busyCount === 0){
        if (statusEl) statusEl.hidden = true;
        if (goEl) goEl.disabled = false;
        if (exploreEl) exploreEl.disabled = false;
      }
        }

    function clearAuthError(){
      if (!authError) return;
      authError.hidden = true;
      authError.textContent = '';
    }

    function setAuthError(message){
      if (!authError) return;
      if (!message) {
        clearAuthError();
        return;
      }
      authError.hidden = false;
      authError.textContent = message;
    }

    function setAuthMode(mode){
      authMode = mode === 'register' ? 'register' : 'login';
      if (authTitle) authTitle.textContent = authMode === 'register' ? 'Create account' : 'Log in';
      if (authSubmit) {
        const base = authMode === 'register' ? 'Subscribe' : 'Log in';
        authSubmit.textContent = authBusy
          ? (authMode === 'register' ? 'Creating…' : 'Signing in…')
          : base;
      }
      if (authToggleText) authToggleText.textContent = authMode === 'register' ? 'Already have an account?' : 'Need an account?';
      if (authSwitch) authSwitch.textContent = authMode === 'register' ? 'Log in' : 'Subscribe';
      if (authPassword) authPassword.setAttribute('autocomplete', authMode === 'register' ? 'new-password' : 'current-password');
    }

    function setAuthBusy(isBusy){
      authBusy = !!isBusy;
      if (authSubmit) {
        authSubmit.disabled = authBusy;
        const base = authMode === 'register' ? 'Subscribe' : 'Log in';
        authSubmit.textContent = authBusy
          ? (authMode === 'register' ? 'Creating…' : 'Signing in…')
          : base;
      }
      if (authSwitch) authSwitch.disabled = authBusy;
      if (authClose) authClose.disabled = authBusy;
      updateAuthUI();
    }

    function updateAuthUI(){
      const email = currentUser?.email || '';
      if (userBadge) {
        if (email) {
          userBadge.textContent = email;
          userBadge.hidden = false;
        } else {
          userBadge.hidden = true;
          userBadge.textContent = '';
        }
      }
      if (logoutButton) {
        logoutButton.hidden = !email;
        logoutButton.disabled = authBusy;
      }
      if (loginTrigger) {
        loginTrigger.hidden = !!email;
        loginTrigger.disabled = authBusy && !email;
      }
      if (signupTrigger) {
        signupTrigger.hidden = !!email;
        signupTrigger.disabled = authBusy && !email;
      }
      if (authControls) {
        authControls.hidden = false;
      }
      const hasUser = !!currentUser;
      const hasPublicPlaylists = publicPlaylistsSummary.length > 0;
      const showPublicPanel = hasUser && (hasPublicPlaylists || publicPlaylistsLoading || !!publicPlaylistsError);
      ensurePlaylistColumnVisible();
      if (publicPlaylistsPanel) publicPlaylistsPanel.hidden = !showPublicPanel;
      if (playlistsPanel) playlistsPanel.hidden = !hasUser;
      syncPublicFeaturedVisibility();
      renderPlaylistsPanel();
    }

    function getMetaFromRow(row){
      if (!row) return null;
      const base = row._meta ? { ...row._meta } : null;
      if (!base) return null;
      if (base.playlistId && !base.playlistName) {
        const pl = playlists.find((p) => p && p.id === base.playlistId);
        if (pl) base.playlistName = pl.name || '';
      }
      base.src = row._src || '';
      return base;
    }

    function prepareNowPlayingAdd(meta){
      if (!meta || !meta.trackName) return null;
      const albumArtist = meta.albumArtist || meta.trackArtist || '';
      const picture = meta.picture || meta.albumPicture || '';
      const catalogue = meta.catalogue || '';
      const seqCandidate = meta.seq ?? meta.trackSeq ?? meta.trackNumber ?? null;

      const album = {
        title: meta.albumTitle || '',
        artist: albumArtist,
        catalogue,
        picture,
        pictureField: meta.pictureField || ''
      };

      const track = {
        recordId: meta.trackRecordId || meta.recordId || meta.trackId || '',
        name: meta.trackName || '',
        trackArtist: meta.trackArtist || albumArtist,
        seq: seqCandidate,
        mp3: meta.mp3 || meta.rawUrl || '',
        rawUrl: meta.rawUrl || '',
        S3_URL: meta.S3_URL || '',
        mp3Field: meta.audioField || '',
        audioField: meta.audioField || '',
        pictureField: meta.pictureField || ''
      };

      const sourceCandidate = meta.src || track.S3_URL || track.mp3 || track.rawUrl || '';
      const playableSrc = meta.src || resolvePlayableSrc(sourceCandidate);
      if (!track.name) return null;
      if (!playableSrc && !sourceCandidate) return null;
      return { album, track, playableSrc };
    }

    function updateNowPlayingAddState(meta, isPlaying){
      if (!nowPlayingAddButton) return;
      const payload = meta ? prepareNowPlayingAdd(meta) : null;
      nowPlayingAddButton._addPayload = payload;
      const shouldShow = Boolean(payload) && isPlaying;
      if (!shouldShow) {
        nowPlayingAddButton.hidden = true;
        nowPlayingAddButton.disabled = true;
        nowPlayingAddButton.textContent = '+ Playlist';
        nowPlayingAddButton.setAttribute('aria-label', 'Add track to playlist');
        return;
      }
      nowPlayingAddButton.hidden = false;
      nowPlayingAddButton.disabled = nowPlayingAddBusy;
      nowPlayingAddButton.textContent = nowPlayingAddBusy ? 'Saving…' : '+ Playlist';
      nowPlayingAddButton.setAttribute('aria-label', nowPlayingAddBusy ? 'Adding track to playlist…' : 'Add track to playlist');
    }

    function updateNowPlayingUI(){
      if (!nowPlayingCard) return;
      const meta = nowPlayingInfo.meta;
      const isPlaying = !!nowPlayingInfo.isPlaying;
      updateNowPlayingAddState(meta, isPlaying);
      if (!meta) {
        if (nowPlayingProgressFill) nowPlayingProgressFill.style.width = '0%';
        if (nowPlayingMetaButtons) nowPlayingMetaButtons.innerHTML = '';
        nowPlayingCard.hidden = true;
        if (nowPlayingToggleButton) {
          nowPlayingToggleButton.textContent = 'Play';
          nowPlayingToggleButton.setAttribute('aria-label', 'Play track');
          nowPlayingToggleButton.disabled = true;
        }
        // Albums grid visibility managed by mode, not playback state
        return;
      }

      nowPlayingCard.hidden = false;
      nowPlayingCard.classList.toggle('collapsed', nowPlayingCollapsed);

      // Albums grid visibility managed by mode, not playback state

      if (nowPlayingTitle) nowPlayingTitle.textContent = meta.trackName || 'Track';
      if (nowPlayingSubtitle) nowPlayingSubtitle.textContent = meta.trackArtist || meta.albumArtist || '';

      const nowPlayingYear = document.getElementById('nowPlayingYear');
      if (nowPlayingYear) {
        nowPlayingYear.textContent = meta.year ? `Released: ${meta.year}` : '';
      }

      if (nowPlayingSource) {
        const parts = [];
        if (meta.playlistName) parts.push(`Playlist • ${meta.playlistName}`);
        if (meta.albumTitle) parts.push(meta.playlistName ? `Album • ${meta.albumTitle}` : meta.albumTitle);
        if (meta.catalogue) parts.push(`#${meta.catalogue}`);
        nowPlayingSource.textContent = parts.join(' • ');
      }

      if (nowPlayingMetaButtons) {
        nowPlayingMetaButtons.innerHTML = '';
        const details = collectTrackMetadata(meta);
        if (details.length) {
          const list = document.createElement('div');
          list.className = 'now-playing-meta-list';
          details.forEach(({ label, value }) => {
            const line = document.createElement('div');
            line.className = 'now-playing-meta-line';
            const key = document.createElement('strong');
            key.textContent = `${label}:`;
            line.appendChild(key);
            line.appendChild(document.createTextNode(` ${value}`));
            list.appendChild(line);
          });
          nowPlayingMetaButtons.appendChild(list);
        }
      }

      if (nowPlayingStatus) nowPlayingStatus.textContent = isPlaying ? 'Playing' : 'Paused';

      if (nowPlayingToggleButton) {
        const buttonText = isPlaying ? 'Pause' : 'Play';
        console.log('[UpdateUI] Setting button text to:', buttonText, '(isPlaying=', isPlaying, ')');
        nowPlayingToggleButton.textContent = buttonText;
        console.log('[UpdateUI] Button text AFTER setting:', nowPlayingToggleButton.textContent);
        nowPlayingToggleButton.setAttribute('aria-label', isPlaying ? 'Pause playback' : 'Play track');
        nowPlayingToggleButton.disabled = !meta.src;
      }

      if (nowPlayingProgressFill) {
        nowPlayingProgressFill.style.width = '0%';
      }

      if (nowPlayingCollapseButton) {
        nowPlayingCollapseButton.textContent = nowPlayingCollapsed ? 'Show info' : 'Hide info';
      }

      if (nowPlayingThumb) {
        const thumbContent = nowPlayingThumb.querySelector('.now-playing-thumb-content');
        if (thumbContent) {
          thumbContent.innerHTML = '';
          if (meta.picture) {
            const raw = String(meta.picture || '');
            const artSrc = raw.startsWith('/api/container?') || /^https?:/i.test(raw)
              ? raw
              : `/api/container?u=${encodeURIComponent(raw)}`;
            const img = document.createElement('img');
            img.src = artSrc;
            img.alt = 'Artwork';
            img.loading = 'lazy';
            img.onerror = () => {
              img.src = '/img/placeholder.png';
              img.classList.add('placeholder-image');
            };
            thumbContent.appendChild(img);
          } else {
            // Show placeholder when no artwork
            const img = document.createElement('img');
            img.src = '/img/placeholder.png';
            img.alt = 'No artwork';
            img.classList.add('placeholder-image');
            thumbContent.appendChild(img);
          }
        }
      }
    }

    function setNowPlayingFromRow(row, isPlaying){
      const meta = getMetaFromRow(row);
      if (!meta) {
        nowPlayingInfo.meta = null;
        nowPlayingInfo.isPlaying = false;
      } else {
        if (!nowPlayingInfo.meta) nowPlayingCollapsed = false;
        nowPlayingInfo.meta = meta;
        nowPlayingInfo.isPlaying = !!isPlaying;
      }
      updateNowPlayingUI();
      syncPlaylistOnlyCurrent();
    }

    function markNowPlayingInactive(){
      if (nowPlayingInfo.meta) {
        nowPlayingInfo.isPlaying = false;
        updateNowPlayingUI();
        syncPlaylistOnlyCurrent();
      }
    }

    function clearNowPlaying(){
      nowPlayingInfo.meta = null;
      nowPlayingInfo.isPlaying = false;
      nowPlayingCollapsed = false;
      updateNowPlayingUI();
      syncPlaylistOnlyCurrent();
    }

    function syncPlaylistOnlyCurrent(){
      if (!playlistTracksSection) return;
      const should = Boolean(nowPlayingInfo.meta && nowPlayingInfo.isPlaying && nowPlayingInfo.meta.playlistId === activePlaylistId);
      playlistTracksSection.classList.toggle('only-current', should);
    }

    function clearPlaylists(){
      playlists = [];
      playlistsLoaded = false;
      playlistsLoading = false;
      activePlaylistId = null;
      /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
      clearNowPlaying();
      renderPlaylistsPanel();
    }

    async function loadUserPlaylists(){
      if (!currentUser) {
        clearPlaylists();
        return [];
      }
      if (playlistsLoading) return playlists;
      playlistsLoading = true;
      try {
        const res = await fetch('/api/playlists', { headers: { 'Accept': 'application/json' } });
        if (res.status === 401) {
          currentUser = null;
          clearPlaylists();
          updateAuthUI();
          return [];
        }
        if (!res.ok) throw new Error('Failed to load playlists');
        const json = await res.json().catch(() => ({}));
        playlists = Array.isArray(json?.playlists) ? json.playlists : [];
        playlistsLoaded = true;
        if (!playlists.length) {
          activePlaylistId = null;
        } else if (!activePlaylistId || !playlists.some((p) => p && p.id === activePlaylistId)) {
          activePlaylistId = playlists[0]?.id || null;
        }
        /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
        renderPlaylistsPanel();
        return playlists;
      } catch (err) {
        console.warn('Playlist fetch failed:', err);
        playlistsLoaded = false;
        renderPlaylistsPanel();
        return [];
      } finally {
        playlistsLoading = false;
        renderPlaylistsPanel();
      }
    }

    async function ensurePlaylistsLoaded(){
      if (!playlistsLoaded) {
        await loadUserPlaylists();
      } else {
        renderPlaylistsPanel();
      }
      return playlists;
    }

    async function createPlaylistOnServer(name){
      const trimmed = typeof name === 'string' ? name.trim() : '';
      if (!trimmed) throw new Error('Playlist name required');
      const res = await fetch('/api/playlists', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ name: trimmed })
      });
      const json = await res.json().catch(() => ({}));
      if (res.status === 409 && json?.playlist) {
        playlists = Array.isArray(playlists) ? playlists : [];
        const existing = json.playlist;
        const idx = playlists.findIndex((p) => p && p.id === existing.id);
        if (idx === -1) playlists.push(existing);
        playlistsLoaded = true;
        activePlaylistId = existing?.id || activePlaylistId;
        renderPlaylistsPanel();
        return existing;
      }
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error || 'Failed to create playlist');
      }
      const playlist = json.playlist;
      playlists = Array.isArray(playlists) ? playlists.slice() : [];
      playlists.push(playlist);
      playlistsLoaded = true;
      activePlaylistId = playlist?.id || activePlaylistId;
      renderPlaylistsPanel();
      return playlist;
    }

    async function addTrackToPlaylistOnServer(playlistId, trackPayload){
      const res = await fetch(`/api/playlists/${encodeURIComponent(playlistId)}/tracks`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ track: trackPayload })
      });
      const json = await res.json().catch(() => ({}));
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error || 'Failed to add track to playlist');
      }
      const updated = json.playlist;
      const track = json.track;
      const idx = playlists.findIndex((p) => p && p.id === updated?.id);
      if (idx !== -1) {
        playlists[idx] = updated;
      } else if (updated) {
        playlists.push(updated);
      }
      playlistsLoaded = true;
      activePlaylistId = updated?.id || activePlaylistId;
      renderPlaylistsPanel();
      return { playlist: updated, track, duplicate: json.duplicate }; // duplicate flag optional
    }

    async function addAlbumToPlaylistOnServer(playlistId, tracksPayload){
      const res = await fetch(`/api/playlists/${encodeURIComponent(playlistId)}/tracks/bulk`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ tracks: tracksPayload })
      });
      const json = await res.json().catch(() => ({}));
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (!res.ok || !json?.ok) {
        throw new Error(json?.error || 'Failed to add album to playlist');
      }
      const updated = json.playlist;
      const idx = playlists.findIndex((p) => p && p.id === updated?.id);
      if (idx !== -1) {
        playlists[idx] = updated;
      } else if (updated) {
        playlists.push(updated);
      }
      playlistsLoaded = true;
      activePlaylistId = updated?.id || activePlaylistId;
      renderPlaylistsPanel();
      return json;
    }

    function getActivePlaylist(){
      if (!activePlaylistId) return null;
      return playlists.find((p) => p && p.id === activePlaylistId) || null;
    }

    function setActivePlaylist(id){
      if (!id || !playlists.some((p) => p && p.id === id)) {
        activePlaylistId = null;
        /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
      } else {
        if (activePlaylistId !== id) /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
        activePlaylistId = id;
      }
      renderPlaylistsPanel();
    }

    function renderPlaylistsPanel(){
      if (!playlistsPanel) return;
      const hasUser = Boolean(currentUser);
      const list = Array.isArray(playlists) ? playlists.filter(Boolean) : [];

      ensurePlaylistColumnVisible();

      if (!hasUser) {
        playlistsPanel.hidden = true;
        renderPlaylistTracks();
        return;
      }

      playlistsPanel.hidden = false;

      if (playlistsStatus) {
        if (playlistsLoading) playlistsStatus.textContent = 'Loading…';
        else playlistsStatus.textContent = list.length ? `${list.length} playlist${list.length === 1 ? '' : 's'}` : 'No playlists yet';
      }

      if (playlistsList) {
        playlistsList.innerHTML = '';
        list.forEach((pl) => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'playlist-pill';
          if (pl.id === activePlaylistId) pill.classList.add('active');
          pill.dataset.playlistId = pl.id || '';

          const count = Array.isArray(pl.tracks) ? pl.tracks.length : 0;
          const countLabel = count ? `${count} track${count === 1 ? '' : 's'}` : 'Empty';
          const label = pl.name ? `${pl.name} • ${countLabel}` : countLabel;
          pill.textContent = label;

          pill.addEventListener('click', () => {
            if (pl.id === activePlaylistId) setActivePlaylist(null);
            else setActivePlaylist(pl.id);
          });

          playlistsList.appendChild(pill);
        });
      }

      if (playlistsEmpty) {
        playlistsEmpty.hidden = list.length > 0 || playlistsLoading;
      }

      if (playlistCreateForm) {
        playlistCreateForm.hidden = false;
      }

      renderPlaylistTracks();
      updateNowPlayingUI();
    }

    function renderPlaylistTracks(){
      if (!playlistTracksSection) return;
      const hasUser = Boolean(currentUser);
      const playlist = getActivePlaylist();

    if (!hasUser) {
      playlistTracksSection.hidden = true;
      if (deletePlaylistButton) deletePlaylistButton.hidden = true;
      if (togglePlaylistTracksButton) togglePlaylistTracksButton.hidden = true;
      if (sharePlaylistButton) sharePlaylistButton.hidden = true;
      if (exportPlaylistButton) exportPlaylistButton.hidden = true;
      if (shareLinkOutput) updateShareLinkDisplay(null);
      return;
    }

    if (!playlist) {
      /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
      if (playlistTracksTitle) playlistTracksTitle.textContent = 'Playlist';
      if (playlistTracksMeta) playlistTracksMeta.textContent = '';
      if (playlistTracksList) playlistTracksList.innerHTML = '';
      if (playlistTracksEmpty) playlistTracksEmpty.hidden = true;
      if (deletePlaylistButton) deletePlaylistButton.hidden = true;
      if (togglePlaylistTracksButton) togglePlaylistTracksButton.hidden = true;
      if (sharePlaylistButton) sharePlaylistButton.hidden = true;
      if (exportPlaylistButton) exportPlaylistButton.hidden = true;
      if (shareLinkOutput) updateShareLinkDisplay(null);
      playlistTracksSection.hidden = true;
      playlistTracksSection.dataset.playlistId = '';
      return;
    }

    playlistTracksSection.hidden = false;
      playlistTracksSection.dataset.playlistId = playlist.id || '';
      playlistTracksSection.classList.toggle('collapsed', playlistTracksCollapsed);

      const tracks = Array.isArray(playlist.tracks) ? playlist.tracks : [];
      const count = tracks.length;

      if (playlistTracksTitle) playlistTracksTitle.textContent = playlist.name || 'Playlist';
      if (playlistTracksMeta) {
        const countText = count ? `${count} track${count === 1 ? '' : 's'}` : 'No tracks yet';
        let display = countText;
        if (playlistTracksCollapsed && count) display += ' • hidden';
        playlistTracksMeta.textContent = display;
        playlistTracksMeta.hidden = false;
      }

      if (deletePlaylistButton) {
        deletePlaylistButton.hidden = false;
        deletePlaylistButton.disabled = playlistsLoading;
      }

      if (sharePlaylistButton) {
        sharePlaylistButton.hidden = false;
        const hasTracks = count > 0;
        sharePlaylistButton.disabled = playlistsLoading || !hasTracks;
        if (!hasTracks) {
          sharePlaylistButton.title = 'Add at least one track before sharing a playlist';
        } else {
          sharePlaylistButton.title = '';
        }
      }

      if (exportPlaylistButton) {
        exportPlaylistButton.hidden = false;
        const hasTracks = count > 0;
        exportPlaylistButton.disabled = playlistsLoading || !hasTracks;
        if (!hasTracks) {
          exportPlaylistButton.title = 'Add at least one track before exporting a playlist';
        } else {
          exportPlaylistButton.title = '';
        }
      }

      updateShareLinkDisplay(playlist);

      if (togglePlaylistTracksButton) {
        const hideToggle = count === 0;
        togglePlaylistTracksButton.hidden = hideToggle;
        if (!hideToggle) {
          togglePlaylistTracksButton.textContent = playlistTracksCollapsed ? 'Show tracks' : 'Hide tracks';
        }
      }

      if (playlistTracksList) {
        const previousPlaylistState = (currentRow && currentRow._playlist)
          ? {
              playlistId: currentRow._playlist,
              src: currentRow._src,
              playing: !player.paused && currentSrc === currentRow._src
            }
          : null;
        let matchedPlayback = false;

        playlistTracksList.innerHTML = '';

        tracks.forEach((track, idx) => {
          const li = document.createElement('li');
          li.className = 'track playlist-track';

          const btnPlay = document.createElement('button');
          btnPlay.type = 'button';
          btnPlay.className = 'btn track-play';
          const srcCandidate = track?.resolvedSrc || track?.S3_URL || track?.mp3 || track?.rawUrl || '';
          const audioField = typeof track?.audioField === 'string' ? track.audioField.trim() : '';
          const artworkField = typeof track?.artworkField === 'string' ? track.artworkField.trim() : '';
          const playableCandidate = resolvePlayableSrc(srcCandidate);
          const playableSrc = canValidateAudioSrc(playableCandidate) ? playableCandidate : '';
          li._src = playableSrc;
          li._btn = btnPlay;
          li._card = null;
          li._playlist = playlist.id;
          li._audioField = audioField;
          li._valid = null;
          li._validated = false;
          li._validating = false;
          if (track?.id) li.dataset.trackId = track.id;
          else if (track?.trackRecordId) li.dataset.trackId = track.trackRecordId;

          const trackName = track?.name || 'Untitled track';
          const artist = (track?.trackArtist || track?.albumArtist || '').trim();

          btnPlay.dataset.playLabel = '▶';
          btnPlay.dataset.pauseLabel = '⏸';
          const readable = artist ? `${artist} — ${trackName}` : trackName;
          btnPlay.dataset.playAria = `Play ${readable}`;
          btnPlay.dataset.pauseAria = `Pause ${readable}`;

          if (playableSrc) {
            btnPlay.textContent = btnPlay.dataset.playLabel;
            btnPlay.disabled = false;
            btnPlay.classList.remove('btn-error');
            btnPlay.setAttribute('aria-label', btnPlay.dataset.playAria);
          } else {
            btnPlay.textContent = 'No audio';
            btnPlay.disabled = true;
            btnPlay.classList.add('btn-error');
            btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
          }

          btnPlay.addEventListener('click', async () => {
            if (!li._src) {
              window.alert('This track has no playable audio source.');
              return;
            }
            if (li._valid === false) {
              btnPlay.textContent = 'Unavailable';
              btnPlay.disabled = true;
              btnPlay.classList.add('btn-error');
              btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
              return;
            }

            if (li._playlist && track?.trackRecordId) {
              const previousLabel = btnPlay.textContent;
              btnPlay.disabled = true;
              btnPlay.textContent = 'Refreshing…';
              btnPlay.setAttribute('aria-label', `Refreshing audio for ${readable}`);
              const oldKey = String(li._src || '').trim();
              if (oldKey) audioProbeCache.delete(oldKey);
              const refreshed = await refreshTrackContainerSource(li, {
                recordId: track.trackRecordId,
                audioField: audioField,
                candidates: AUDIO_FIELD_CANDIDATES,
                forceRefresh: true
              });
              btnPlay.disabled = false;
              btnPlay.textContent = previousLabel;
              if (btnPlay.dataset.playAria) {
                if (btnPlay.textContent === btnPlay.dataset.playLabel) {
                  btnPlay.setAttribute('aria-label', btnPlay.dataset.playAria);
                } else if (btnPlay.dataset.pauseAria && btnPlay.textContent === btnPlay.dataset.pauseLabel) {
                  btnPlay.setAttribute('aria-label', btnPlay.dataset.pauseAria);
                }
              }
              if (refreshed?.notFound) {
                li._src = '';
                li._meta.src = '';
                li._valid = false;
                btnPlay.textContent = 'Unavailable';
                btnPlay.disabled = true;
                btnPlay.classList.add('btn-error');
                btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
                return;
              }
              if (refreshed && refreshed.src) {
                const newSrc = refreshed.src;
                li._src = newSrc;
                li._meta.src = newSrc;
                if (refreshed.audioField) {
                  li._audioField = refreshed.audioField;
                  li._meta.audioField = refreshed.audioField;
                }
                if (track) {
                  track.resolvedSrc = refreshed.src;
                  track.mp3 = refreshed.rawUrl;
                  if (refreshed.audioField) track.audioField = refreshed.audioField;
                }
              }
            }

            handlePlay(btnPlay, li, li._src);

            if (li._valid === true || li._validating) return;
            li._validating = true;
            validateAudio(li, li._src, { optimistic: true }).finally(() => {
              li._validating = false;
            });
          });

          const wrapper = document.createElement('span');
          wrapper.className = 'track-name';

          if (artist) {
            const artistLine = document.createElement('span');
            artistLine.className = 'track-name-artist';
            artistLine.textContent = artist;
            wrapper.appendChild(artistLine);

            const titleLine = document.createElement('span');
            titleLine.className = 'track-name-title';
            titleLine.textContent = trackName;
            wrapper.appendChild(titleLine);
          } else {
            const titleLine = document.createElement('span');
            titleLine.className = 'track-name-title';
            titleLine.textContent = trackName;
            wrapper.appendChild(titleLine);
          }

          const tooltipParts = [artist, track?.albumTitle, track?.albumArtist].filter((part) => typeof part === 'string' && part.trim());
          if (tooltipParts.length) {
            const tooltip = tooltipParts.join(' • ');
            wrapper.title = tooltip;
            li.title = tooltip;
          }

          li.appendChild(btnPlay);
          li.appendChild(wrapper);

          // Add delete button for playlist tracks
          const btnDelete = document.createElement('button');
          btnDelete.type = 'button';
          btnDelete.className = 'btn small btn-error icon';
          btnDelete.textContent = '×';
          btnDelete.title = 'Remove from playlist';
          btnDelete.setAttribute('aria-label', `Remove ${readable} from playlist`);
          btnDelete.style.marginLeft = 'auto';
          btnDelete.addEventListener('click', async () => {
            if (!confirm(`Remove "${trackName}" from this playlist?`)) {
              return;
            }
            try {
              btnDelete.disabled = true;
              btnDelete.textContent = '⏳';
              const response = await fetch(`/api/playlists/${playlist.id}/tracks/${encodeURIComponent(track.addedAt)}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' }
              });
              const result = await response.json();
              if (result.ok) {
                // Remove track from UI
                li.remove();
                // Update playlist metadata
                if (result.playlist) {
                  const count = Array.isArray(result.playlist.tracks) ? result.playlist.tracks.length : 0;
                  if (playlistTracksMeta) {
                    playlistTracksMeta.textContent = `${count} track${count !== 1 ? 's' : ''}`;
                  }
                  if (playlistTracksEmpty) {
                    playlistTracksEmpty.hidden = count > 0;
                  }
                }
              } else {
                window.alert(result.error || 'Failed to remove track from playlist.');
                btnDelete.disabled = false;
                btnDelete.textContent = '×';
              }
            } catch (err) {
              console.error('Failed to delete track:', err);
              window.alert('Failed to remove track from playlist.');
              btnDelete.disabled = false;
              btnDelete.textContent = '×';
            }
          });
          li.appendChild(btnDelete);

          const baseMeta = { ...track };
          baseMeta.trackName = trackName;
          baseMeta.trackArtist = track?.trackArtist || track?.albumArtist || '';
          baseMeta.albumTitle = track?.albumTitle || '';
          baseMeta.albumArtist = track?.albumArtist || '';
          baseMeta.playlistId = playlist.id;
          baseMeta.playlistName = playlist.name || '';
          baseMeta.picture = track?.artwork || '';
          baseMeta.source = 'playlist';
          baseMeta.catalogue = track?.catalogue || '';
          baseMeta.playlistTrackId = track?.id || '';
          baseMeta.trackRecordId = track?.trackRecordId || '';
          baseMeta.audioField = audioField;
          baseMeta.pictureField = artworkField;
          baseMeta.src = playableSrc;
          baseMeta.S3_URL = track?.S3_URL || '';
          baseMeta.rawUrl = track?.rawUrl || '';
          baseMeta.producer = track?.producer || '';
          baseMeta.composer1 = track?.composer1 || '';
          baseMeta.composer2 = track?.composer2 || '';
          baseMeta.composer3 = track?.composer3 || '';
          baseMeta.composer4 = track?.composer4 || '';
          baseMeta.composers = track?.composers || [];
          li._meta = baseMeta;
          playlistTracksList.appendChild(li);

          if (
            playableSrc &&
            previousPlaylistState &&
            previousPlaylistState.playlistId === playlist.id &&
            previousPlaylistState.src === playableSrc
          ) {
            matchedPlayback = true;
            currentRow = li;
            currentBtn = btnPlay;
            li._playlist = playlist.id;
            if (previousPlaylistState.playing) {
              li.classList.add('playing');
              btnPlay.textContent = btnPlay.dataset.pauseLabel || '⏸ Pause';
              btnPlay.classList.add('btn-accent');
              btnPlay.disabled = false;
              if (btnPlay.dataset.pauseAria) btnPlay.setAttribute('aria-label', btnPlay.dataset.pauseAria);
            } else {
              btnPlay.textContent = btnPlay.dataset.playLabel || '▶ Play';
              btnPlay.classList.remove('btn-accent');
              if (btnPlay.dataset.playAria) btnPlay.setAttribute('aria-label', btnPlay.dataset.playAria);
            }
            setNowPlayingFromRow(li, previousPlaylistState.playing);
          }
        });

        if (previousPlaylistState) {
          if (previousPlaylistState.playlistId === playlist.id) {
            if (!matchedPlayback) {
              if (previousPlaylistState.playing && !player.paused && currentSrc === previousPlaylistState.src) {
                player.pause();
              }
              currentSrc = '';
              updateButtonsForStop();
            } else {
              updateProgressUI();
            }
          } else if (previousPlaylistState.playing && !player.paused && currentSrc === previousPlaylistState.src) {
            player.pause();
            currentSrc = '';
            updateButtonsForStop();
          }
        }

        playlistTracksList.hidden = playlistTracksCollapsed;
      }

      if (playlistTracksEmpty) {
        playlistTracksEmpty.hidden = playlistTracksCollapsed || count > 0;
        playlistTracksEmpty.textContent = 'No tracks in this playlist yet.';
      }
      syncPlaylistOnlyCurrent();
    }

    async function deletePlaylistOnServer(id){
      const res = await fetch(`/api/playlists/${encodeURIComponent(id)}`, {
        method: 'DELETE',
        headers: {
          'Accept': 'application/json'
        }
      });
      let json = {};
      try { json = await res.json(); } catch {}
      if (res.status === 401) {
        currentUser = null;
        clearPlaylists();
        updateAuthUI();
        throw new Error('Please log in to manage playlists');
      }
      if (res.status === 404) {
        return null;
      }
      if (!res.ok) {
        throw new Error(json?.error || 'Failed to delete playlist');
      }
      return json?.playlist || null;
    }

    async function deleteActivePlaylist(){
      const playlist = getActivePlaylist();
      if (!playlist) return;
      const name = playlist.name || 'playlist';
      if (!window.confirm(`Delete ${name}? This cannot be undone.`)) return;
      if (deletePlaylistButton) deletePlaylistButton.disabled = true;
      try {
        await deletePlaylistOnServer(playlist.id);
      } catch (err) {
        window.alert(err?.message || 'Unable to delete playlist');
        if (deletePlaylistButton) deletePlaylistButton.disabled = false;
        return;
      }
      playlists = Array.isArray(playlists) ? playlists.filter((p) => p && p.id !== playlist.id) : [];
      playlistsLoaded = true;
      if (playlists.length) {
        activePlaylistId = playlists[0]?.id || null;
      } else {
        activePlaylistId = null;
      }
      if (nowPlayingInfo.meta && nowPlayingInfo.meta.playlistId === playlist.id) {
        try { player.pause(); } catch {}
        updateButtonsForStop();
        currentSrc = '';
        clearNowPlaying();
      }
      /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
      renderPlaylistsPanel();
      if (deletePlaylistButton) deletePlaylistButton.disabled = false;
      window.alert('Playlist deleted.');
    }

    function buildShareUrlFallback(shareId){
      const normalized = typeof shareId === 'string' ? shareId.trim() : '';
      if (!normalized) return '';
      try {
        const current = new URL(window.location.href);
        const base = `${current.origin}${current.pathname}`;
        return `${base}?share=${encodeURIComponent(normalized)}`;
      } catch {
        const origin = (window.location && window.location.origin) || '';
        const path = (window.location && window.location.pathname) || '/';
        const base = origin ? `${origin}${path}` : path;
        return `${base}?share=${encodeURIComponent(normalized)}`;
      }
    }

    async function copyTextToClipboard(text){
      if (!text) return false;
      try {
        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch (err) {
        console.warn('[MASS] Clipboard write failed', err);
      }
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.setAttribute('readonly', '');
        textarea.style.position = 'absolute';
        textarea.style.opacity = '0';
        textarea.style.pointerEvents = 'none';
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        return true;
      } catch (err) {
        console.warn('[MASS] Fallback clipboard copy failed', err);
      }
      window.prompt('Copy this link:', text);
      return false;
    }

    function getExistingShareUrl(playlist){
      if (!playlist || typeof playlist !== 'object') return '';
      const shareId = typeof playlist.shareId === 'string' ? playlist.shareId.trim() : '';
      if (!shareId) return '';
      return buildShareUrlFallback(shareId);
    }

    function updateShareLinkDisplay(playlist, explicitUrl){
      if (!shareLinkOutput) return;
      const url = explicitUrl || getExistingShareUrl(playlist);
      if (url) {
        shareLinkOutput.hidden = false;
        shareLinkOutput.textContent = `Share link: ${url}`;
        shareLinkOutput.dataset.url = url;
      } else {
        shareLinkOutput.hidden = true;
        shareLinkOutput.textContent = '';
        shareLinkOutput.removeAttribute('data-url');
      }
    }

    async function copyActivePlaylistShareLink(){
      const playlist = getActivePlaylist();
      if (!playlist) return;
      if (!Array.isArray(playlist.tracks) || playlist.tracks.length === 0) {
        window.alert('Add tracks before sharing a playlist.');
        return;
      }
      if (sharePlaylistButton) {
        sharePlaylistButton.disabled = true;
      }
      try {
        const res = await fetch(`/api/playlists/${encodeURIComponent(playlist.id)}/share`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({})
        });
        const data = await res.json().catch(() => ({}));
        if (res.status === 401) {
          currentUser = null;
          clearPlaylists();
          updateAuthUI();
          throw new Error('Please log in to manage playlists');
        }
        if (res.status === 400) {
          throw new Error(data?.error || 'Add at least one track before sharing');
        }
        if (!res.ok || !data?.ok) {
          const detail = typeof data?.detail === 'string' && data.detail.trim() ? data.detail.trim() : '';
          const message = typeof data?.error === 'string' && data.error.trim() ? data.error.trim() : 'Unable to generate share link';
          throw new Error(detail || message);
        }
        const shareId = typeof data.shareId === 'string'
          ? data.shareId.trim()
          : typeof data.playlist?.shareId === 'string'
            ? data.playlist.shareId.trim()
            : '';
        if (!shareId) {
          throw new Error('Server did not return a share link');
        }
        const shareUrl = (typeof data.shareUrl === 'string' && data.shareUrl.trim())
          ? data.shareUrl.trim()
          : buildShareUrlFallback(shareId);
        const serverSharedAt = typeof data.playlist?.sharedAt === 'string'
          ? data.playlist.sharedAt
          : playlist.sharedAt || new Date().toISOString();
        playlist.shareId = shareId;
        playlist.sharedAt = serverSharedAt;
        const idx = playlists.findIndex((p) => p && p.id === playlist.id);
        if (idx !== -1) {
          const current = playlists[idx];
          playlists[idx] = {
            ...current,
            shareId,
            sharedAt: serverSharedAt
          };
        }
        const updatedPlaylist = idx !== -1 ? playlists[idx] : { ...playlist };
        updateShareLinkDisplay(updatedPlaylist, shareUrl);

        // Show share modal with link
        showShareModal(shareUrl);
      } catch (err) {
        console.error('Copy share link failed', err);
        const existingShareId = typeof playlist.shareId === 'string' ? playlist.shareId.trim() : '';
        if (existingShareId) {
          const fallbackUrl = buildShareUrlFallback(existingShareId);
          updateShareLinkDisplay(playlist, fallbackUrl);
          showShareModal(fallbackUrl);
        } else {
          window.alert(err?.message || 'Unable to generate share link');
        }
      } finally {
        if (sharePlaylistButton) {
          sharePlaylistButton.disabled = false;
        }
      }
    }

    async function exportActivePlaylist() {
      const playlist = getActivePlaylist();
      if (!playlist) return;
      if (!Array.isArray(playlist.tracks) || playlist.tracks.length === 0) {
        window.alert('Add tracks before exporting a playlist.');
        return;
      }
      if (exportPlaylistButton) {
        exportPlaylistButton.disabled = true;
      }
      try {
        const res = await fetch(`/api/playlists/${encodeURIComponent(playlist.id)}/export`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json'
          }
        });
        const data = await res.json().catch(() => ({}));
        if (res.status === 401) {
          currentUser = null;
          clearPlaylists();
          updateAuthUI();
          throw new Error('Please log in to manage playlists');
        }
        if (res.status === 400) {
          throw new Error(data?.error || 'Cannot export empty playlist');
        }
        if (!res.ok || !data?.ok) {
          const detail = typeof data?.detail === 'string' && data.detail.trim() ? data.detail.trim() : '';
          const message = typeof data?.error === 'string' && data.error.trim() ? data.error.trim() : 'Unable to export playlist';
          throw new Error(detail || message);
        }
        if (!data.code) {
          throw new Error('Server did not return export code');
        }
        // Show export modal with code
        showExportModal(data.code, data.json);
      } catch (err) {
        console.error('Export playlist failed', err);
        window.alert(err?.message || 'Unable to export playlist');
      } finally {
        if (exportPlaylistButton) {
          exportPlaylistButton.disabled = false;
        }
      }
    }

    async function importPlaylistFromCode() {
      const code = importCodeInput?.value?.trim() || '';
      if (!code && !importFileInput?.files?.[0]) {
        if (importStatus) importStatus.textContent = 'Please provide a code or select a file';
        return;
      }

      let importData = null;

      // Handle file upload
      if (importFileInput?.files?.[0]) {
        try {
          const file = importFileInput.files[0];
          const text = await file.text();
          importData = { code: text };
        } catch (err) {
          if (importStatus) importStatus.textContent = 'Failed to read file';
          return;
        }
      } else {
        importData = { code };
      }

      if (importSubmitBtn) importSubmitBtn.disabled = true;
      if (importStatus) importStatus.textContent = 'Importing...';

      try {
        const res = await fetch('/api/playlists/import', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(importData)
        });
        const data = await res.json().catch(() => ({}));
        if (res.status === 401) {
          currentUser = null;
          clearPlaylists();
          updateAuthUI();
          throw new Error('Please log in to import playlists');
        }
        if (!res.ok || !data?.ok) {
          const message = typeof data?.error === 'string' && data.error.trim() ? data.error.trim() : 'Unable to import playlist';
          throw new Error(message);
        }
        if (!data.playlist) {
          throw new Error('Server did not return playlist data');
        }

        // Add imported playlist to local list
        playlists.push(data.playlist);
        renderPlaylistsPanel();
        closeImportModal();

        const imported = data.imported || 0;
        const skipped = data.skipped || 0;
        window.alert(`Imported playlist "${data.playlist.name}" with ${imported} track${imported !== 1 ? 's' : ''}` + (skipped > 0 ? ` (${skipped} skipped)` : ''));
      } catch (err) {
        console.error('Import playlist failed', err);
        if (importStatus) {
          importStatus.textContent = err?.message || 'Import failed';
        } else {
          window.alert(err?.message || 'Unable to import playlist');
        }
      } finally {
        if (importSubmitBtn) importSubmitBtn.disabled = false;
      }
    }

    function buildPlaylistTrackPayload(album, track, playableSrc){
      const recordId = track?.recordId;
      return {
        recordId: typeof recordId === 'string' ? recordId : recordId ? String(recordId) : '',
        name: track?.name || '',
        albumTitle: album?.title || '',
        albumArtist: album?.artist || '',
        catalogue: album?.catalogue || '',
        year: album?.year || '',
        trackArtist: track?.trackArtist || '',
        seq: Number.isFinite(track?.seq) ? Number(track.seq) : null,
        mp3: track?.mp3 || track?.S3_URL || track?.rawUrl || '',
        resolvedSrc: playableSrc || track?.resolvedSrc || track?.S3_URL || '',
        artwork: album?.picture || '',
        audioField: track?.mp3Field || track?.audioField || '',
        artworkField: album?.pictureField || track?.pictureField || '',
        producer: track?.producer || '',
        genre: track?.genre || '',
        language: track?.language || '',
        isrc: track?.isrc || '',
        composer1: track?.composer1 || '',
        composer2: track?.composer2 || '',
        composer3: track?.composer3 || '',
        composer4: track?.composer4 || '',
        composers: track?.composers || []
      };
    }

    async function resolvePlaylistForAdd(){
      console.log('[resolvePlaylistForAdd] Called');
      if (!currentUser) {
        console.log('[resolvePlaylistForAdd] No current user, opening auth');
        openAuth('login');
        return null;
      }

      console.log('[resolvePlaylistForAdd] Ensuring playlists loaded');
      await ensurePlaylistsLoaded();
      playlists = Array.isArray(playlists) ? playlists : [];
      console.log('[resolvePlaylistForAdd] Playlists loaded:', playlists.length);

      // Always show the selector to let user choose
      console.log('[resolvePlaylistForAdd] Showing playlist selector');
      const selection = await showPlaylistSelector(playlists);
      console.log('[resolvePlaylistForAdd] Selection result:', selection);
      if (!selection) return null;

      let playlist;
      if (selection.type === 'existing') {
        playlist = playlists.find(p => p.id === selection.id);
      } else if (selection.type === 'new') {
        try {
          playlist = await createPlaylistOnServer(selection.name);
        } catch (err) {
          window.alert(err?.message || 'Unable to create playlist');
          return null;
        }
      }

      if (!playlist) return null;

      /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
      const playlistId = playlist?.id || null;
      if (playlistId && playlistId !== activePlaylistId) {
        setActivePlaylist(playlistId);
      } else {
        renderPlaylistsPanel();
      }

      return playlist;
    }

    function showPlaylistSelector(playlistsArray) {
      console.log('[showPlaylistSelector] Opening modal with', playlistsArray?.length || 0, 'playlists');
      return new Promise((resolve) => {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: flex; align-items: center; justify-content: center;';

        // Create modal content
        const modal = document.createElement('div');
        modal.style.cssText = 'background: var(--card); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.4);';

        // Title
        const title = document.createElement('h3');
        title.textContent = 'Add to Playlist';
        title.style.cssText = 'margin: 0 0 16px 0; color: var(--fg); font-size: 20px;';
        modal.appendChild(title);

        // Dropdown
        const select = document.createElement('select');
        select.style.cssText = 'width: 100%; padding: 10px; background: var(--bg); color: var(--fg); border: 1px solid var(--border); border-radius: 8px; font-size: 15px; margin-bottom: 12px;';

        // Add options
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '-- Select Playlist --';
        select.appendChild(defaultOption);

        if (Array.isArray(playlistsArray)) {
          playlistsArray.forEach(p => {
            const option = document.createElement('option');
            option.value = p.id;
            option.textContent = p.name;
            select.appendChild(option);
          });
        }

        const newOption = document.createElement('option');
        newOption.value = '__new__';
        newOption.textContent = '+ Create New Playlist';
        select.appendChild(newOption);
        modal.appendChild(select);

        // New playlist name input (hidden by default)
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = 'Enter new playlist name';
        nameInput.style.cssText = 'width: 100%; padding: 10px; background: var(--bg); color: var(--fg); border: 1px solid var(--border); border-radius: 8px; font-size: 15px; margin-bottom: 12px; display: none;';
        modal.appendChild(nameInput);

        // Show/hide name input based on selection
        select.addEventListener('change', () => {
          if (select.value === '__new__') {
            nameInput.style.display = 'block';
            nameInput.focus();
          } else {
            nameInput.style.display = 'none';
          }
        });

        // Buttons container
        const buttons = document.createElement('div');
        buttons.style.cssText = 'display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;';

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        console.log('[showPlaylistSelector] Modal created, adding event listeners');
        cancelBtn.className = 'btn secondary';
        cancelBtn.style.cssText = 'padding: 8px 16px;';
        cancelBtn.addEventListener('click', () => {
          console.log('[showPlaylistSelector] Cancel clicked');
          overlay.remove();
          resolve(null);
        });
        buttons.appendChild(cancelBtn);

        const addBtn = document.createElement('button');
        addBtn.textContent = 'Add';
        addBtn.className = 'btn';
        addBtn.style.cssText = 'padding: 8px 16px;';
        addBtn.addEventListener('click', () => {
          console.log('[showPlaylistSelector] Add clicked, select.value:', select.value);
          if (select.value === '__new__') {
            const name = nameInput.value.trim();
            console.log('[showPlaylistSelector] Creating new playlist:', name);
            if (!name) {
              nameInput.focus();
              return;
            }
            overlay.remove();
            resolve({ type: 'new', name });
          } else if (select.value) {
            console.log('[showPlaylistSelector] Using existing playlist:', select.value);
            overlay.remove();
            resolve({ type: 'existing', id: select.value });
          } else {
            console.warn('[showPlaylistSelector] No playlist selected');
            select.focus();
          }
        });
        buttons.appendChild(addBtn);

        modal.appendChild(buttons);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // Close on overlay click
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            overlay.remove();
            resolve(null);
          }
        });

        // Focus select
        setTimeout(() => select.focus(), 100);
      });
    }

    async function handleAddToPlaylist(album, track, playableSrc){
      console.log('[handleAddToPlaylist] Called for track:', track?.['Track Name'] || 'unknown');
      const playlist = await resolvePlaylistForAdd();
      console.log('[handleAddToPlaylist] Resolved playlist:', playlist?.name || 'none');
      if (!playlist) return;

      const payload = buildPlaylistTrackPayload(album, track, playableSrc);
      if (!payload.name) {
        window.alert('Track must have a name before it can be added.');
        return;
      }

      try {
        const { duplicate } = await addTrackToPlaylistOnServer(playlist.id, payload);
        if (duplicate) {
          window.alert('Track already in playlist.');
        } else {
          window.alert(`Added to "${playlist.name}"`);
        }
      } catch (err) {
        window.alert(err?.message || 'Unable to add track');
      }
    }

    async function handleAddAlbumToPlaylist(album){
      console.log('[handleAddAlbumToPlaylist] Called for album');
      const playlist = await resolvePlaylistForAdd();
      console.log('[handleAddAlbumToPlaylist] Resolved playlist:', playlist?.name || 'none');
      if (!playlist) return;

      const tracks = Array.isArray(album?.tracks) ? album.tracks.filter(t => t.hasValidAudio) : [];
      const payloads = tracks
        .map((track) => {
          const candidateSrc = track?.resolvedSrc || track?.S3_URL || track?.mp3 || track?.rawUrl || '';
          const candidate = resolvePlayableSrc(candidateSrc);
          const playableSrc = canValidateAudioSrc(candidate) ? candidate : '';
          return buildPlaylistTrackPayload(album, track, playableSrc);
        })
        .filter((payload) => payload.name);

      if (!payloads.length) {
        window.alert('No tracks on this album could be added.');
        return;
      }

      try {
        const result = await addAlbumToPlaylistOnServer(playlist.id, payloads);
        const addedCount = Number(result?.addedCount) || 0;
        const duplicateCount = Number(result?.duplicateCount) || 0;
        const skippedCount = Number(result?.skippedCount) || 0;

        let message = addedCount > 0
          ? `Added ${addedCount} track${addedCount === 1 ? '' : 's'} to "${playlist.name}".`
          : `No new tracks added to "${playlist.name}".`;
        if (duplicateCount > 0) message += ` ${duplicateCount} already in playlist.`;
        if (skippedCount > 0) message += ` ${skippedCount} skipped.`;
        window.alert(message);
      } catch (err) {
        window.alert(err?.message || 'Unable to add album to playlist');
      }
    }

    function openAuth(mode = authMode, trigger = null){
      setAuthMode(mode);
      clearAuthError();
      if (authOverlay) {
        authOverlay.hidden = false;
        authOverlay.classList.add('open');
      }
      authReturnFocus = trigger || document.activeElement;
      queueTask(() => {
        authEmail?.focus();
        authEmail?.select?.();
      });
    }

    function closeAuth(){
      if (authOverlay) {
        authOverlay.hidden = true;
        authOverlay.classList.remove('open');
      }
      setAuthBusy(false);
      clearAuthError();
      authForm?.reset();
      if (authReturnFocus && typeof authReturnFocus.focus === 'function') {
        authReturnFocus.focus();
      }
      authReturnFocus = null;
      setAuthMode('login');
    }

    function showShareModal(link) {
      const playlist = getActivePlaylist();
      const playlistName = playlist?.name || 'My Playlist';
      const trackCount = playlist?.tracks?.length || 0;

      // Build mailto link with pre-filled message
      const subject = encodeURIComponent(`Check out my playlist: ${playlistName}`);
      const body = encodeURIComponent(
        `I thought you might enjoy this playlist!\n\n` +
        `${playlistName} (${trackCount} track${trackCount !== 1 ? 's' : ''})\n\n` +
        `Listen here: ${link}\n\n` +
        `Shared via MASS Music`
      );
      const mailtoLink = `mailto:?subject=${subject}&body=${body}`;

      // Open email client
      window.location.href = mailtoLink;

      // Show confirmation message
      setTimeout(() => {
        if (confirm('Email client opened. Would you like to copy the link to your clipboard as well?')) {
          navigator.clipboard.writeText(link).then(() => {
            console.log('[Share] Link copied to clipboard');
          }).catch(err => {
            console.warn('[Share] Could not copy to clipboard:', err);
            // Fallback: show the link in a modal
            if (shareModal && shareLinkInput) {
              shareLinkInput.value = link;
              shareModal.classList.add('open');
              setTimeout(() => {
                shareLinkInput.focus();
                shareLinkInput.select();
              }, 100);
            }
          });
        }
      }, 500);
    }

    function closeShareModal() {
      if (!shareModal) return;
      shareModal.classList.remove('open');
      shareLinkInput.value = '';
    }

    // Export modal functions
    function showExportModal(compactCode, exportData) {
      if (!exportModal || !exportCodeInput) return;
      exportCodeInput.value = compactCode;
      exportCodeInput.dataset.exportJson = JSON.stringify(exportData, null, 2);
      exportModal.classList.add('open');
      setTimeout(() => {
        exportCodeInput.focus();
        exportCodeInput.select();
      }, 100);
    }

    function closeExportModal() {
      if (!exportModal) return;
      exportModal.classList.remove('open');
      exportCodeInput.value = '';
      delete exportCodeInput.dataset.exportJson;
    }

    // Import modal functions
    function showImportModal() {
      if (!importModal) return;
      importCodeInput.value = '';
      importFileInput.value = '';
      if (importStatus) importStatus.textContent = '';
      importModal.classList.add('open');
      setTimeout(() => importCodeInput.focus(), 100);
    }

    function closeImportModal() {
      if (!importModal) return;
      importModal.classList.remove('open');
      importCodeInput.value = '';
      importFileInput.value = '';
      if (importStatus) importStatus.textContent = '';
    }

    async function refreshCurrentUser(){
      // Derive user identity from access token email (set by token overlay in index.html)
      const email = localStorage.getItem('mass_token_email') || window.massAccessEmail || null;
      currentUser = email ? { email } : null;

      if (currentUser) {
        await loadUserPlaylists();
        // Also load featured playlists
        loadPublicPlaylistSummaries().catch(err => console.warn('Failed to load featured playlists:', err));
      } else {
        clearPlaylists();
      }
      updateAuthUI();
    }

    async function submitAuthForm(event){
      // Auth form no longer used — access is managed via token overlay
      if (event) event.preventDefault();
    }

    async function performLogout(){
      // Clear access token and user identity
      localStorage.removeItem('mass_access_token');
      localStorage.removeItem('mass_token_info');
      localStorage.removeItem('mass_token_email');
      window.massAccessReady = false;
      window.massAccessToken = null;
      window.massAccessEmail = null;
      currentUser = null;
      updateAuthUI();
      clearPlaylists();
      // Reload to show token overlay
      window.location.reload();
    }


    // Raw FM rows (cumulative as we lazy-load)
    let rawItems = [];
    let rawTotalFound = 0;
    let rawNextOffset = 0; // UI 0-based; server converts to FM 1-based

    // Grouped albums & album-page state
    let albumGroups = [];
    let albumPage = 0;
    let currentMode = 'landing';
    let currentExploreDecade = null; // Track current decade for reload
    let shouldScrollAlbums = false;
    let isRestoring = false;
    let showAlbumsWithoutAudio = true; // Show all albums, trust FileMaker data
    const normalizeSearchFilters = (filters = {}) => ({
      genre: typeof filters.genre === 'string' ? filters.genre.trim() : ''
    });
    let currentSearchFilters = normalizeSearchFilters();

    const randomSongsAutoplay = {
      active: false,
      loadingNextPage: false,
      pendingStart: false,
      retries: 0
    };

    const THEME_STORAGE_KEY = 'mass.altTheme';
    function applyTheme(isAlt){
      const body = document.body;
      if (!body) return;
      body.classList.toggle('alt-theme', Boolean(isAlt));
      if (themeToggle) {
        themeToggle.setAttribute('aria-pressed', isAlt ? 'true' : 'false');
        themeToggle.textContent = isAlt ? 'Classic View' : 'Modern View';
      }
    }
    (function initTheme(){
      let saved = true; // Default to Modern view (alt-theme)
      try {
        const storedValue = localStorage.getItem(THEME_STORAGE_KEY);
        // If user has a saved preference, use it
        if (storedValue !== null) {
          saved = storedValue === '1';
        }
      } catch {}
      applyTheme(saved);
    })();

    // Single audio UI state
    let currentBtn=null, currentRow=null, currentSrc='';

    // Audio validation caches
    const audioProbeCache = new Map(); // src -> { ok, reason, ts }
    const albumAudioState = new Map(); // albumKey -> { status, promise?, ts }
    const AUDIO_PROBE_TTL = 10 * 60 * 1000;
    const queueTask = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn);
    const containerCache = new Map(); // recordId|field -> cached container

    // Field helper mappings (adjust here if exact names differ)
    const AUDIO_FIELD_CANDIDATES = ['S3_URL', 'mp3', 'MP3', 'Audio File', 'Audio::mp3'];
    const ARTWORK_FIELD_CANDIDATES = [
      'Artwork_S3_URL',
      'Tape Files::Artwork_S3_URL',
      'Artwork::Picture',
      'Artwork Picture',
      'Picture',
      'CoverArtURL',
      'AlbumCover',
      'Cover Art',
      'CoverArt'
    ];
    const TRACK_TITLE_CANDIDATES = ['Track Name', 'Song Name', 'Title', 'Track Title', 'Song Title'];
    const PUBLIC_PLAYLIST_FIELD_CANDIDATES = [
      'PublicPlaylist',
      'Public Playlist',
      'Tape Files::PublicPlaylist',
      'Tape Files::Public Playlist',
      'Public_Playlist',
      'Playlist Name',
      'Playlist::Public'
    ];
    const CATALOGUE_FIELD_CANDIDATES = [
      'Album Catalogue Number',
      'Album Catalog Number',
      'Album Catalogue No',
      'Album Catalog No',
      'Catalogue',
      'Catalogue #',
      'Catalogue Number',
      'Catalog Number',
      'Catalog #',
      'Tape Files::Album Catalogue Number',
      'Tape Files::Catalogue',
      'Tape Files::Catalogue #',
      'Reference Catalogue Number',
      'Reference Catalog Number',
      'Reference Catalogue No',
      'Reference Catalog No',
      'Reference Catalogue #',
      'Reference Catalog #',
      'Tape Files::Reference Catalogue Number',
      'Tape Files::Reference Catalogue No',
      'Tape Files::Reference Catalogue #',
      'Tape Files::Reference Catalog Number',
      'Tape Files::Reference Catalog No',
      'Tape Files::Reference Catalog #'
    ];

    function pickFieldValue(source, candidates){
      if (!source) return { value: '', field: '' };
      const entries = Object.entries(source);
      const normalizeFieldName = (name) => typeof name === 'string' ? name.replace(/[^a-z0-9]/gi, '').toLowerCase() : '';
      for (const candidate of candidates) {
        for (const [key, raw] of entries) {
          if (key !== candidate) continue;
          if (raw === undefined || raw === null) continue;
          const str = typeof raw === 'string' ? raw.trim() : String(raw).trim();
          if (str) return { value: str, field: key };
        }
        const normalizedCandidate = normalizeFieldName(candidate);
        if (!normalizedCandidate) continue;
        for (const [key, raw] of entries) {
          if (key === candidate) continue;
          if (raw === undefined || raw === null) continue;
          if (normalizeFieldName(key) !== normalizedCandidate) continue;
          const str = typeof raw === 'string' ? raw.trim() : String(raw).trim();
          if (str) return { value: str, field: key };
        }
      }
      return { value: '', field: '' };
        }

    function fCatalogue(f){
      return pickFieldValue(f, CATALOGUE_FIELD_CANDIDATES).value || '';
        }
    function fPicture(f){
      return pickFieldValue(f, ARTWORK_FIELD_CANDIDATES).value;
        }
    const F_TRACK  = 'Track Name';
    const F_GENRE  = 'Local Genre';

    const TRACK_SEQUENCE_FIELDS = [
      'Track Number',
      'TrackNumber',
      'Track_Number',
      'Track No',
      'Track No.',
      'Track_No',
      'Track #',
      'Track#',
      'Track Sequence',
      'Track Sequence Number',
      'Track Seq',
      'Track Seq No',
      'Track Order',
      'Track Position',
      'TrackPosition',
      'Sequence',
      'Seq',
      'Sequence Number',
      'Sequence_Number',
      'Song Number',
      'Song No',
      'Song Seq',
      'Song Order',
      'Tape Files::Track Number',
      'Tape Files::Track_No'
    ];

    function composersFrom(f){
      const c = [
        f['Composer'],
        f['Composer 1'] ?? f['Composer1'],
        f['Composer 2'] ?? f['Composer2'],
        f['Composer 3'] ?? f['Composer3'],
        f['Composer 4'] ?? f['Composer4'],
      ].filter(Boolean);
      return c;
        }

    function parseTrackSequence(fields = {}) {
      for (const key of TRACK_SEQUENCE_FIELDS) {
        if (!Object.prototype.hasOwnProperty.call(fields, key)) continue;
        const raw = fields[key];
        if (raw === undefined || raw === null) continue;
        const str = String(raw).trim();
        if (!str) continue;
        const numeric = Number(str);
        if (Number.isFinite(numeric)) return numeric;
        const cleaned = Number(str.replace(/[^0-9.-]/g, ''));
        if (Number.isFinite(cleaned)) return cleaned;
      }
      for (const [key, value] of Object.entries(fields)) {
        if (value === undefined || value === null) continue;
        const lower = key.toLowerCase();
        if (!/(track|song)/.test(lower)) continue;
        if (!/(no|num|#|seq|order|pos)/.test(lower)) continue;
        const str = String(value).trim();
        if (!str) continue;
        const numeric = Number(str);
        if (Number.isFinite(numeric)) return numeric;
        const cleaned = Number(str.replace(/[^0-9.-]/g, ''));
        if (Number.isFinite(cleaned)) return cleaned;
      }
      return Number.POSITIVE_INFINITY;
        }

    
    // Flexible field accessors to match your layout keys
    function fTitle(f){
      return f['Album Title'] || f['Tape Files::Album_Title'] || f['Album_Title'] || f['Title'] || '';
        }
    function fArtist(f){
      return f['Album Artist'] || f['Tape Files::Album Artist'] || f['Track Artist'] || f['Artist'] || '';
        }
    function fMp3(f){
      return pickFieldValue(f, AUDIO_FIELD_CANDIDATES).value;
        }
    function fLang(f){
      return f['Language'] || f['Language Code'] || '';
        }

    function hasValidMp3(s){
      return canValidateAudioSrc(s);
        }

    function fmtTime(sec){
      const value = Number(sec);
      if (!Number.isFinite(value) || value <= 0) return '0:00';
      const clamped = Math.max(0, value);
      const minutes = Math.floor(clamped / 60);
      const seconds = Math.floor(clamped % 60);
      return `${minutes}:${String(seconds).padStart(2,'0')}`;
        }

    function formatDateForDisplay(iso){
      if (typeof iso !== 'string' || !iso.trim()) return '';
      try {
        const date = new Date(iso);
        if (!Number.isFinite(date.getTime())) return '';
        return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
      } catch {
        return '';
      }
        }

    const AUDIO_VALIDATE_TIMEOUT = 12000;
    const AUDIO_VALIDATE_MAX_RETRIES = 2;
    const MAX_AUDIO_PROBES_PER_ALBUM = 2;
    const MAX_ALBUMS_TO_PRIME = ALBUMS_PER_PAGE * 2;
    const MAX_CONCURRENT_AUDIO_PROBES = 6;
    const AUDIO_PRELOAD_LIMIT = 4;
    let activeAudioProbes = 0;
    const audioProbeWaiters = [];
    const audioPreloadCache = new Map();
    const audioPreloadOrder = [];
    function delay(ms){ return new Promise((resolve) => setTimeout(resolve, ms)); }
    function canValidateAudioSrc(src){
      if (typeof src !== 'string') return false;
      const trimmed = src.trim();
      if (!trimmed) return false;
      if (trimmed.startsWith('/')) return true;
      if (/^https?:\/\//i.test(trimmed)) return true;
      if (/^[^:?#]+\.(mp3|m4a|aac|wav|ogg|flac)$/i.test(trimmed)) return true;
      return false;
        }

    function resolvePlayableSrc(rawSrc){
      const src = typeof rawSrc === 'string' ? rawSrc.trim() : '';
      if (!src) return '';
      if (src.startsWith('/api/container?')) return src;
      if (/^https?:\/\/[^/]+\/api\/container\?/i.test(src)) return src;
      if (/^data:/i.test(src)) return src;
      // Check if it's an S3 URL - return directly without proxying
      if (/^https?:\/\/.*\.s3[.-]/.test(src)) return src;
      if (/^https?:\/\/s3[.-]/.test(src)) return src;
      if (/^https?:\/\//i.test(src)) return `/api/container?u=${encodeURIComponent(src)}`;
      if (src.startsWith('/')) return src;
      return `/api/container?u=${encodeURIComponent(src)}`;
        }

    function buildProxyContainerSrc(raw){
      const src = typeof raw === 'string' ? raw.trim() : '';
      if (!src || src.startsWith('/api/container?')) return '';
      if (/^data:/i.test(src)) return '';
      if (/^https?:\/\//i.test(src)) {
        return `/api/container?u=${encodeURIComponent(src)}`;
      }
      return '';
        }

    function buildFallbackAudioSrc(row, failedSrc){
      if (!row || !failedSrc) return '';
      const attempted = String(failedSrc || '').trim();
      if (!attempted) return '';
      if (attempted.startsWith('/api/container?')) return '';
      const meta = row._meta || {};
      const candidates = [
        attempted,
        row._src || '',
        row._lastAttemptedSrc || '',
        meta.src || '',
        meta.rawUrl || '',
        meta.S3_URL || '',
        meta.mp3 || ''
      ];
      for (const candidateRaw of candidates) {
        const proxied = buildProxyContainerSrc(candidateRaw);
        if (proxied && proxied !== attempted) {
          return proxied;
        }
      }
      return '';
        }

    function buildContainerSrc(recordId, field){
      const rid = typeof recordId === 'number' ? String(recordId) : (recordId || '').toString().trim();
      if (!rid) return '';
      const parts = [`rid=${encodeURIComponent(rid)}`];
      if (field) {
        parts.push(`field=${encodeURIComponent(field)}`);
      }
      return `/api/container?${parts.join('&')}`;
        }

    function isFresh(entry){
      if (!entry || typeof entry.ts !== 'number') return false;
      return (Date.now() - entry.ts) < AUDIO_PROBE_TTL;
        }

    async function acquireProbeSlot(){
      if (activeAudioProbes >= MAX_CONCURRENT_AUDIO_PROBES) {
        await new Promise((resolve) => audioProbeWaiters.push(resolve));
      }
      activeAudioProbes += 1;
    }

    function releaseProbeSlot(){
      activeAudioProbes = Math.max(0, activeAudioProbes - 1);
      const next = audioProbeWaiters.shift();
      if (next) next();
    }

    function releasePreloadedSrc(src){
      if (!src) return;
      const audio = audioPreloadCache.get(src);
      if (audio) {
        try {
          audio.src = '';
          audio.load();
        } catch {}
        audioPreloadCache.delete(src);
      }
      const idx = audioPreloadOrder.indexOf(src);
      if (idx !== -1) audioPreloadOrder.splice(idx, 1);
    }

    function preloadAudioSrc(src){
      if (!src || audioPreloadCache.has(src)) return;
      try {
        const audio = new Audio();
        audio.preload = 'auto';
        audio.src = src;
        try { audio.load(); } catch {}
        audioPreloadCache.set(src, audio);
        audioPreloadOrder.push(src);
      } catch {}
      while (audioPreloadOrder.length > AUDIO_PRELOAD_LIMIT) {
        const stale = audioPreloadOrder.shift();
        releasePreloadedSrc(stale);
      }
    }

    function updatePlaylistTrackEntry(meta, update){
      if (!meta || !meta.playlistId || !meta.playlistTrackId) return;
      const playlist = playlists.find((p) => p && p.id === meta.playlistId);
      if (!playlist || !Array.isArray(playlist.tracks)) return;
      const entry = playlist.tracks.find((t) => t && t.id === meta.playlistTrackId);
      if (!entry) return;
      if (update.resolvedSrc) {
        entry.resolvedSrc = update.resolvedSrc;
      }
      if (update.rawUrl) {
        entry.mp3 = update.rawUrl;
      }
      if (update.audioField) entry.audioField = update.audioField;
    }

        async function refreshTrackContainerSource(row, options = {}){
      const meta = row?._meta || {};
      const recordId = options.recordId || meta.trackRecordId || meta.recordId || '';
      if (!recordId) return null;

      const requestedField = options.audioField || meta.audioField || '';
      const cacheKey = `${recordId}::${requestedField || 'default'}`;
      const now = Date.now();
      const CACHE_TTL = 30 * 60 * 1000;
      const useCache = !options.forceRefresh;
      const cached = useCache ? containerCache.get(cacheKey) : null;
      if (cached && (now - cached.ts) < CACHE_TTL) {
        if (cached.notFound) return { notFound: true };
        if (row) {
          row._src = cached.resolvedSrc;
          if (row._meta) {
            row._meta.src = cached.resolvedSrc;
            if (cached.audioField) row._meta.audioField = cached.audioField;
            updatePlaylistTrackEntry(row._meta, { rawUrl: cached.rawUrl, resolvedSrc: cached.resolvedSrc, audioField: cached.audioField });
          }
          row._lastContainerRefresh = now;
        }
        return { ...cached };
      }

      if (options.forceRefresh) {
        containerCache.delete(cacheKey);
      }

      const params = new URLSearchParams();
      if (requestedField) {
        params.set('field', requestedField);
      } else if (Array.isArray(options.candidates) && options.candidates.length) {
        params.set('candidates', options.candidates.join(','));
      }

      try {
        const query = params.toString();
        const endpoint = query
          ? `/api/track/${encodeURIComponent(recordId)}/container?${query}`
          : `/api/track/${encodeURIComponent(recordId)}/container`;
        const res = await fetch(endpoint, { headers: { 'Accept': 'application/json' } });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json?.url) {
          return null;
        }
        const rawUrl = json.url;
        const field = json?.field || requestedField || '';
        const resolvedSrc = resolvePlayableSrc(rawUrl);

        if (row) {
          row._src = resolvedSrc;
          if (row._meta) {
            row._meta.src = resolvedSrc;
            if (field) row._meta.audioField = field;
            updatePlaylistTrackEntry(row._meta, { rawUrl, resolvedSrc, audioField: field });
          }
          row._lastContainerRefresh = now;
        }

        containerCache.set(cacheKey, { rawUrl, resolvedSrc, audioField: field, ts: now });
        return { src: resolvedSrc, rawUrl, audioField: field };
      } catch (err) {
        console.warn('[MASS] Failed to refresh container source', err);
        return null;
      }
    }

    function findNextPlayableRow(row){
      if (!row) return null;
      let pointer = row.nextElementSibling;
      while (pointer) {
        if (pointer._src) return pointer;
        pointer = pointer.nextElementSibling;
      }
      return null;
    }

    function scheduleNextTrackPreload(row){
      const nextRow = findNextPlayableRow(row);
      if (!nextRow) return;
      if (nextRow._src && !audioPreloadCache.has(nextRow._src)) {
        preloadAudioSrc(nextRow._src);
      }
      // Also preload the track after next
      const nextNext = findNextPlayableRow(nextRow);
      if (nextNext && nextNext._src && !audioPreloadCache.has(nextNext._src)) {
        preloadAudioSrc(nextNext._src);
      }
    }

    async function probeAudioSource(src, attempt = 0){
      const key = String(src || '').trim();
      if (!key) {
        const outcome = { ok: false, reason: 'Invalid link', ts: Date.now() };
        return outcome;
      }
      const cached = audioProbeCache.get(key);
      if (cached && isFresh(cached)) return cached;
      const isDirectS3 = /^https?:\/\/.*\.s3[.-]/i.test(key) || /^https?:\/\/s3[.-]/i.test(key);
      if (isDirectS3) {
        const outcome = { ok: true, reason: '', ts: Date.now() };
        audioProbeCache.set(key, outcome);
        return outcome;
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), AUDIO_VALIDATE_TIMEOUT);
      let response;
      let outcome;
      await acquireProbeSlot();
      try {
        // Check if it's an S3 URL - if so, don't send credentials (CORS issue)
        const isS3 = /^https?:\/\/.*\.s3[.-]/.test(src) || /^https?:\/\/s3[.-]/.test(src);
        response = await fetch(src, {
          method: 'GET',
          headers: { Range: 'bytes=0-4095' },
          signal: controller.signal,
          cache: 'no-store',
          credentials: isS3 ? 'omit' : 'include'
        });
      } catch (err) {
        outcome = { ok: false, reason: err?.name === 'AbortError' ? 'Timeout' : 'Unavailable', ts: Date.now() };
        if (outcome.reason === 'Timeout' && attempt < AUDIO_VALIDATE_MAX_RETRIES) {
          await delay(600 * (attempt + 1));
          releaseProbeSlot();
          clearTimeout(timeoutId);
          return probeAudioSource(src, attempt + 1);
        }
        audioProbeCache.set(key, outcome);
        return outcome;
      } finally {
        clearTimeout(timeoutId);
        releaseProbeSlot();
      }
      let buffer;
      try {
        if (!response || !response.ok) {
          if (response && response.status === 401) {
            console.warn('[MASS] Audio probe received 401', src);
          }
          outcome = { ok: false, reason: `HTTP ${response ? response.status : 'error'}`, ts: Date.now() };
        } else {
          const type = (response.headers.get('content-type') || '').toLowerCase();
          const len = response.headers.get('content-length');
          if (len === '0') {
            outcome = { ok: false, reason: 'Empty audio', ts: Date.now() };
          } else if (type && !/(audio|mpeg|mp3|ogg|wav|flac)/i.test(type)) {
            outcome = { ok: false, reason: 'Unexpected content', ts: Date.now() };
          } else {
            buffer = await response.arrayBuffer();
            if (!buffer || buffer.byteLength === 0) {
              outcome = { ok: false, reason: 'Empty audio', ts: Date.now() };
            } else {
              const bytes = new Uint8Array(buffer);
              if (!looksLikeAudio(bytes, type)) {
                outcome = { ok: false, reason: 'Unexpected content', ts: Date.now() };
              } else {
                outcome = { ok: true, ts: Date.now(), type, length: len ? Number(len) : undefined };
              }
            }
          }
        }
      } catch (err) {
        outcome = { ok: false, reason: 'Unavailable', ts: Date.now() };
      } finally {
        // Stream is already consumed by arrayBuffer() - no need to cancel
        // Attempting to cancel a locked stream causes errors
      }

      if (!outcome.ok && outcome.reason === 'Timeout' && attempt < AUDIO_VALIDATE_MAX_RETRIES) {
        await delay(600 * (attempt + 1));
        return probeAudioSource(src, attempt + 1);
      }
      audioProbeCache.set(key, outcome);
      return outcome;
        }

    function looksLikeAudio(bytes, type){
      if (!bytes || !bytes.length) return false;
      const first = bytes[0];
      const second = bytes.length > 1 ? bytes[1] : 0;
      const third = bytes.length > 2 ? bytes[2] : 0;
      const fourth = bytes.length > 3 ? bytes[3] : 0;
      const head = String.fromCharCode(first, second, third, fourth);
      const nextHead = bytes.length >= 8 ? String.fromCharCode(bytes[4], bytes[5], bytes[6], bytes[7]) : '';

      const startsWith = (prefix) => head.startsWith(prefix);

      if (startsWith('ID3')) return true;
      if (startsWith('OggS')) return true;
      if (startsWith('fLaC')) return true;
      if (startsWith('RIFF')) return true;
      if (startsWith('FORM')) return true; // AIFF/AIFF-C
      if (head.startsWith('ftyp') || nextHead === 'ftyp') return true; // MP4/M4A

      if (first === 0xFF && (second & 0xE0) === 0xE0) return true; // MPEG frame sync
      if (first === 0xAD && second === 0xAF) return true; // ADPCM

      // Common non-audio signatures
      if (first === 0x3C /* < */ || first === 0x7B /* { */ || first === 0x5B /* [ */) return false;
      if (head.toLowerCase().startsWith('http')) return false;

      if (type && /(audio|mpeg|mp3|ogg|wav|flac|aac)/i.test(type)) return true;

      return false;
        }

    function updateAlbumCardState(album){
      if (!album) return;
      const card = album._card;
      if (!card || !card.isConnected) return;

      const hasPlayable = !!album.hasPlayable;
      const pending = !!album._pendingValidation;

      card.dataset.pendingTracks = pending ? '1' : '0';
      card.dataset.validTracks = hasPlayable ? '1' : '0';

      card.classList.toggle('pending-audio', pending);

      if (hasPlayable) {
        card.dataset.hasAudioCandidates = 'true';
        card.classList.remove('no-audio');
        if (card.title === 'No playable audio available') card.removeAttribute('title');
      } else if (!pending) {
        card.dataset.hasAudioCandidates = 'false';
        card.classList.add('no-audio');
        if (!card.title) card.title = 'No playable audio available';
      }

      syncCardAudioState(card);
        }

    function ensureAlbumAudioValidation(album){
      if (!album) return;
      const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
      album.key = key;
      const existing = albumAudioState.get(key);
      if (existing) {
        if (existing.status === 'pending') return;
        if ((existing.status === 'valid' || existing.status === 'invalid') && isFresh(existing)) return;
      }

      const validator = runAlbumAudioValidation(album);
      album._pendingValidation = true;
      albumAudioState.set(key, { status: 'pending', promise: validator });
      validator
        .then((ok) => {
          albumAudioState.set(key, { status: ok ? 'valid' : 'invalid', ts: Date.now() });
          album._pendingValidation = false;
          album.hasPlayable = !!ok;
          updateAlbumCardState(album);
        })
        .catch((err) => {
          console.warn('[MASS] Album audio validation failed', err);
          albumAudioState.set(key, { status: 'invalid', ts: Date.now(), error: err });
          album._pendingValidation = false;
          album.hasPlayable = false;
          updateAlbumCardState(album);
        });
        }

    function primeAlbumAudioValidation(albums, limit = MAX_ALBUMS_TO_PRIME){
      if (!Array.isArray(albums) || !albums.length || limit <= 0) return;
      let processed = 0;
      for (const album of albums) {
        if (!album) continue;
        const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
        album.key = key;
        ensureAlbumAudioValidation(album);
        processed += 1;
        if (processed >= limit) break;
      }
        }

    async function runAlbumAudioValidation(album){
      const tracks = Array.isArray(album.tracks) ? album.tracks : [];
      if (!tracks.length) return false;
      const sources = [];
      const seen = new Set();
      for (const track of tracks) {
        // Prefer S3_URL when present but fall back to other resolved audio candidates
        const audioSrc = track && (track.S3_URL || track.mp3 || track.resolvedSrc);
        const src = resolvePlayableSrc(audioSrc);
        if (!canValidateAudioSrc(src)) continue;
        if (seen.has(src)) continue;
        seen.add(src);
        sources.push(src);
        if (sources.length >= MAX_AUDIO_PROBES_PER_ALBUM) break;
      }
      if (!sources.length) return false;
      const results = await Promise.all(sources.map((src) => probeAudioSource(src)));
      const hasPlayableSource = results.some((outcome) => outcome && outcome.ok);
      if (!hasPlayableSource) {
        console.warn('[MASS] Audio probes inconclusive, keeping album visible', {
          title: album?.title || null,
          artist: album?.artist || null,
          catalogue: album?.catalogue || null
        });
      }
      return hasPlayableSource || sources.length > 0;
        }

    async function validateAudio(row, src, options = {}){
      const btn = row && row._btn;
      const card = row && row._card;
      if (!btn) return;
      const token = Symbol('audio-validate');
      row._validationToken = token;
      const { optimistic = false } = options;

      const applyIfCurrent = (fn) => {
        if (row._validationToken !== token) return false;
        fn();
        return true;
      };

      const finalizeCard = (isValid) => {
        if (!card) return;
        let pending = Number(card.dataset.pendingTracks || '0');
        if (pending > 0) pending -= 1;
        card.dataset.pendingTracks = String(pending);
        if (isValid) {
          const valid = Number(card.dataset.validTracks || '0') + 1;
          card.dataset.validTracks = String(valid);
        }
        syncCardAudioState(card);
      };

      const setInvalid = (label) => {
        const applied = applyIfCurrent(() => {
          if (optimistic && currentRow === row && currentSrc === src) {
            player.pause();
            updateButtonsForStop();
          }
          btn.disabled = true;
          btn.textContent = label || 'Unavailable';
          btn.classList.add('btn-error');
          btn.classList.remove('btn-accent');
          btn.title = label || 'Audio unavailable';
          row._valid = false;
          row._validated = true;
          releasePreloadedSrc(src);
        });
        if (applied) finalizeCard(false);
      };

      const setValid = () => {
        const applied = applyIfCurrent(() => {
          if (!(currentRow === row && !player.paused)) {
            const playLabel = btn.dataset?.playLabel || '▶ Play';
            btn.textContent = playLabel;
            if (btn.dataset?.playAria) btn.setAttribute('aria-label', btn.dataset.playAria);
          }
          btn.disabled = false;
          btn.classList.remove('btn-error');
          btn.removeAttribute('title');
          row._valid = true;
          row._validated = true;
        });
        if (applied) finalizeCard(true);
      };

      if (!canValidateAudioSrc(src)) {
        if (card) card.dataset.hasAudioCandidates = 'true';
        setInvalid('Invalid link');
        return;
      }

      if (card) card.dataset.hasAudioCandidates = 'true';

      const key = typeof src === 'string' ? src.trim() : '';
      const cachedOutcome = key ? audioProbeCache.get(key) : null;
      if (cachedOutcome && isFresh(cachedOutcome) && cachedOutcome.reason !== 'Timeout') {
        if (cachedOutcome.ok) {
          setValid();
        } else {
          setInvalid(cachedOutcome.reason || 'Unavailable');
        }
        return;
      }

      const applied = applyIfCurrent(() => {
        if (!optimistic) {
          btn.disabled = true;
          btn.textContent = 'Checking…';
          btn.title = 'Validating audio…';
        }
        btn.classList.remove('btn-error');
        row._validating = true;
        if (card) {
          const pending = Number(card.dataset.pendingTracks || '0') + 1;
          card.dataset.pendingTracks = String(pending);
          syncCardAudioState(card);
        }
      });
      if (!applied) return;

      let currentSrcKey = key;
      let outcome = await probeAudioSource(src);

      if (!outcome.ok && /401/.test(String(outcome.reason || '')) && row) {
        const refreshed = await refreshTrackContainerSource(row, {
          recordId: row._meta?.trackRecordId || row._meta?.recordId,
          audioField: row._meta?.audioField || row._audioField || '',
          candidates: AUDIO_FIELD_CANDIDATES,
          forceRefresh: true
        });
        if (refreshed?.notFound) {
          row._src = '';
          setInvalid('Unavailable');
          row._validating = false;
          return;
        }
        if (refreshed && refreshed.src) {
          const newSrc = refreshed.src;
          currentSrcKey = String(newSrc || '').trim();
          audioProbeCache.delete(key);
          key = currentSrcKey;
          src = newSrc;
          outcome = await probeAudioSource(newSrc);
        }
      }

      if (outcome.ok) {
        setValid();
        if (optimistic && currentRow === row && player.paused && row._src) {
          queueTask(() => {
            if (row._btn) handlePlay(row._btn, row, row._src);
          });
        }
      } else {
        setInvalid(outcome.reason || 'Unavailable');
      }
      row._validating = false;
        }

    function syncCardAudioState(card){
      if (!card) return;
      const hasCandidates = card.dataset.hasAudioCandidates === 'true';
      const valid = Number(card.dataset.validTracks || '0');
      const pending = Number(card.dataset.pendingTracks || '0');
      if (valid > 0) {
        card.classList.remove('no-audio');
        if (card.title === 'No playable audio available') card.removeAttribute('title');
      } else if (!hasCandidates || pending === 0) {
        card.classList.add('no-audio');
        if (!card.title) card.title = 'No playable audio available';
      }
        }

    function abortInFlight(){ if(inFlight){ inFlight.abort(); inFlight=null; } }

    function snapshotState(overrides = {}){
      return {
        groups: albumGroups.slice(),
        page: albumPage,
        rawItems: rawItems.slice(),
        rawTotalFound,
        rawNextOffset,
        lastQ,
        searchValue: searchEl ? searchEl.value : '',
        mode: currentMode,
        searchFilters: { ...currentSearchFilters },
        ...overrides
      };
        }

    function applySnapshot(snapshot){
      if (!snapshot) return;
      albumGroups = Array.isArray(snapshot.groups) ? snapshot.groups.slice() : [];
      rawItems = Array.isArray(snapshot.rawItems) ? snapshot.rawItems.slice() : [];
      rawTotalFound = typeof snapshot.rawTotalFound === 'number' ? snapshot.rawTotalFound : rawItems.length;
      rawNextOffset = typeof snapshot.rawNextOffset === 'number' ? snapshot.rawNextOffset : rawItems.length;
      albumPage = typeof snapshot.page === 'number' ? snapshot.page : 0;
      lastQ = typeof snapshot.lastQ === 'string' ? snapshot.lastQ : '';
      currentMode = snapshot.mode || 'search';
      currentSearchFilters = snapshot.searchFilters ? normalizeSearchFilters(snapshot.searchFilters) : normalizeSearchFilters();
      activePublicPlaylist = null;
      primeAlbumAudioValidation(albumGroups);
      refreshPublicPlaylists();
      if (searchEl && typeof snapshot.searchValue === 'string') {
        searchEl.value = snapshot.searchValue;
      }
      hideLanding();
      errorEl.hidden = true;
        }

    function restorePreviousSearch(){
      if (!prevSearch) return;
      const restore = prevSearch;
      prevSearch = null;

      const source = restore.snapshot || restore.paging || restore.original;
      if (source) {
        const snapshot = { ...source };
        if (restore.type === 'search' && typeof restore.term === 'string') {
          snapshot.lastQ = restore.term;
          snapshot.searchValue = restore.term;
        }
        isRestoring = true;
        applySnapshot(snapshot);
        renderAlbumPage();

        const needsRefetch = albumGroups.length <= 1 && ((restore.type === 'search' && typeof restore.term === 'string' && restore.term.trim()) || (restore.type === 'explore' && restore.start));
        if (needsRefetch) {
            if (restore.type === 'search') {
              if (searchEl) searchEl.value = restore.term;
              const filters = snapshot.searchFilters || {};
              run(restore.term, filters);
              return;
            } else if (restore.type === 'explore') {
              const startYear = Number(restore.start) || 0;
            if (startYear) {
              runExplore(startYear);
              return;
            }
          }
          isRestoring = false;
          return;
        }

        isRestoring = false;
        return;
      }

      if (restore.type === 'explore' && restore.start) {
        const startYear = Number(restore.start) || 0;
        if (startYear) {
          isRestoring = true;
          runExplore(startYear);
          return;
        }
      }

      if (restore.type === 'search' && typeof restore.term === 'string' && restore.term.trim()) {
        if (searchEl) searchEl.value = restore.term;
        isRestoring = true;
        const filters = (restore.snapshot && restore.snapshot.searchFilters) || {};
        run(restore.term, filters);
        return;
      }
        }

    // Show placeholder graphic from /img/* until user searches
    function showLanding(){
      // Leaving explore/search: remove explore layout class
      try {
        const contentCol = document.querySelector('.content-column');
        contentCol && contentCol.classList.remove('exploring');
      } catch {}

      // Restore playlists when leaving search (landing)
      try {
        ensurePlaylistColumnVisible();
      if (publicFeaturedRow) publicFeaturedRow.removeAttribute('hidden');
    } catch {}

    if (sharedPlaylistActive) { clearSharedPlaylistState(); }
    currentMode = 'landing';
    currentExploreDecade = null;
    prevSearch = null;
    currentSearchFilters = normalizeSearchFilters();
    rawItems = [];
      albumsEl.classList.remove('single-album');
      pagerEl.hidden = true;
      if (shuffleBtn) shuffleBtn.hidden = true;
      if (shufflePlayBtn) {
        shufflePlayBtn.hidden = true;
        shufflePlayBtn.disabled = false;
        shufflePlayBtn.setAttribute('aria-pressed', 'false');
      }
      stopRandomSongsAutoplay({ updateButton: false });
      countEl.textContent = '';
      errorEl.hidden = true;
      // Placeholder graphic removed; nothing else to show here.
    }

    function updateRandomSongsControlState(){
      const albumChildren = albumsEl && albumsEl.children ? albumsEl.children.length : 0;
      const hasActiveRow = Boolean(currentRow && currentRow._btn && currentRow._src);
      const hasSongs = currentMode === 'songs' && (albumChildren > 0 || hasActiveRow || randomSongsAutoplay.pendingStart);

      if (randomStopBtn) {
        const playbackActive = hasSongs && ((!player || !player.paused) || randomSongsAutoplay.active || randomSongsAutoplay.pendingStart || hasActiveRow);
        randomStopBtn.hidden = !hasSongs;
        randomStopBtn.disabled = !playbackActive;
      }

      if (randomSkipBtn) {
        let canSkip = false;
        if (hasSongs) {
          if (randomSongsAutoplay.active || randomSongsAutoplay.pendingStart) {
            canSkip = true;
          } else {
            const anchor = hasActiveRow ? currentRow : findFirstRandomSongRow();
            if (anchor && anchor._btn && anchor._src) {
              if (!hasActiveRow) {
                canSkip = true;
              } else {
                const nextRow = findNextPlayableRow(anchor);
                canSkip = Boolean(nextRow && nextRow._btn && nextRow._src);
              }
            }
          }
        }
        randomSkipBtn.hidden = !hasSongs;
        randomSkipBtn.disabled = !canSkip;
      }
    }

    function updateRandomSongsAutoplayButton(){
      if (!shufflePlayBtn) return;
      const loadingLabel = 'Loading…';
      if (randomSongsAutoplay.active) {
        const label = randomSongsAutoplay.loadingNextPage ? loadingLabel : '⏹ Stop Shuffle';
        shufflePlayBtn.textContent = label;
        shufflePlayBtn.disabled = randomSongsAutoplay.loadingNextPage;
        shufflePlayBtn.setAttribute('aria-pressed', 'true');
      } else {
        shufflePlayBtn.textContent = '▶ Shuffle Play';
        shufflePlayBtn.disabled = false;
        shufflePlayBtn.setAttribute('aria-pressed', 'false');
      }
      updateRandomSongsControlState();
    }

    function stopRandomSongsAutoplay(options = {}){
      const { updateButton = true } = options || {};
      randomSongsAutoplay.active = false;
      randomSongsAutoplay.loadingNextPage = false;
      randomSongsAutoplay.pendingStart = false;
      randomSongsAutoplay.retries = 0;
      if (updateButton) updateRandomSongsAutoplayButton();
      else updateRandomSongsControlState();
    }

    function findFirstRandomSongRow(){
      if (!albumsEl) return null;
      let pointer = albumsEl.firstElementChild;
      while (pointer) {
        if (pointer._src && pointer._btn) return pointer;
        pointer = pointer.nextElementSibling;
      }
      return null;
    }

    function scheduleRandomSongsAutoplayCheck(){
      if (!randomSongsAutoplay.active) return;
      if (typeof queueTask === 'function') {
        queueTask(() => kickOffRandomSongsAutoplay());
      } else {
        setTimeout(() => kickOffRandomSongsAutoplay(), 0);
      }
    }

    function kickOffRandomSongsAutoplay(){
      if (!randomSongsAutoplay.active) return;
      const candidate = findFirstRandomSongRow();
      if (candidate && candidate._btn && candidate._src) {
        randomSongsAutoplay.pendingStart = false;
        randomSongsAutoplay.retries = 0;
        handlePlay(candidate._btn, candidate, candidate._src);
        updateRandomSongLabels();
        return;
      }
      triggerRandomSongsAutoplayNextPage();
    }

    function triggerRandomSongsAutoplayNextPage(options = {}){
      const { skipRetryIncrement = false } = options || {};
      if (!randomSongsAutoplay.active || randomSongsAutoplay.loadingNextPage) return;
      if (randomSongsAutoplay.retries >= 5) {
        console.warn('[randomSongsAutoplay] Stopping after multiple failed attempts to find playable tracks.');
        stopRandomSongsAutoplay();
        return;
      }
      randomSongsAutoplay.pendingStart = true;
      randomSongsAutoplay.loadingNextPage = true;
      if (!skipRetryIncrement) {
        randomSongsAutoplay.retries += 1;
      }
      updateRandomSongsAutoplayButton();
      loadRandomSongs({ autoplayResume: true })
        .catch((err) => {
          console.warn('[randomSongsAutoplay] Failed to load next random songs set:', err);
          stopRandomSongsAutoplay();
        })
        .finally(() => {
          randomSongsAutoplay.loadingNextPage = false;
          updateRandomSongsAutoplayButton();
          if (randomSongsAutoplay.active && randomSongsAutoplay.pendingStart) {
            scheduleRandomSongsAutoplayCheck();
          }
        });
    }

    const RANDOM_SONGS_TARGET = 3; // Show current + next up + 1 in queue for sliding
    const RANDOM_SONGS_FETCH_BATCH = 6; // Fetch extras for buffer
    const RANDOM_SONGS_MAX_ATTEMPTS = 3;

    function buildRandomSongContext(song){
      if (!song || typeof song !== 'object') return null;
      if (song._randomContext) return song._randomContext;
      const fields = song.fields || {};
      const titleInfo = pickFieldValue(fields, TRACK_TITLE_CANDIDATES);
      const trackTitle = titleInfo.value || fields['Track Name'] || 'Unknown Track';
      const albumArtistInfo = pickFieldValue(fields, ['Album Artist', 'Artist', 'Tape Files::Album Artist']);
      const albumArtist = albumArtistInfo.value || 'Unknown Artist';
      const pictureInfo = pickFieldValue(fields, ARTWORK_FIELD_CANDIDATES);
      const picture = pictureInfo.value || '';
      const audioFieldInfo = pickFieldValue(fields, AUDIO_FIELD_CANDIDATES);
      const rawMp3 = audioFieldInfo.value || '';
      const albumTitleInfo = pickFieldValue(fields, ['Album', 'Tape Files::Album']);
      const albumTitle = albumTitleInfo.value || '';
      const catalogueInfo = pickFieldValue(fields, CATALOGUE_FIELD_CANDIDATES);
      const catalogue = catalogueInfo.value || '';
      const trackArtistInfo = pickFieldValue(fields, ['Artist', 'Track Artist']);
      const trackArtist = trackArtistInfo.value || albumArtist;
      const trackSeqInfo = pickFieldValue(fields, ['Track #', 'Track Number', 'Seq']);
      const trackSeqRaw = trackSeqInfo.value || null;
      const trackSeq = Number.isFinite(Number(trackSeqRaw)) ? Number(trackSeqRaw) : null;
      const visibilityRaw = String(fields.Visibility || fields['Tape Files::Visibility'] || '').trim().toLowerCase();
      const isVisible = !visibilityRaw || visibilityRaw === 'show';
      const trim = (value) => {
        if (value === undefined || value === null) return '';
        return String(value).trim();
      };
      const producerInfo = pickFieldValue(fields, ['Producer', 'Tape Files::Producer']);
      const producer = trim(producerInfo.value);
      const languageRaw = fLang(fields) || pickFieldValue(fields, ['Language', 'Tape Files::Language']).value || '';
      const language = trim(languageRaw);
      const genreInfo = pickFieldValue(fields, ['Genre', F_GENRE, 'Tape Files::Genre']);
      const genre = trim(genreInfo.value);
      const isrc = trim(pickFieldValue(fields, ['ISRC']).value);
      const composerValues = composersFrom(fields).map(trim).filter(Boolean);
      const composer1 = trim(fields['Composer']);
      const composer2 = trim(fields['Composer 2'] || fields['Composer2']);
      const composer3 = trim(fields['Composer 3'] || fields['Composer3']);
      const composer4 = trim(fields['Composer 4'] || fields['Composer4']);
      const yearInfo = pickFieldValue(fields, ['Year', 'Year Recorded', 'Year_Recorded', 'Release Year', 'Release_Year', 'Date', 'Tape Files::Year']);
      const year = trim(yearInfo.value);
      let playableSrc = resolvePlayableSrc(rawMp3);
      if ((!playableSrc || !playableSrc.startsWith('/api/container?')) && song.recordId && audioFieldInfo.field) {
        playableSrc = buildContainerSrc(song.recordId, audioFieldInfo.field);
      }
      const context = {
        song,
        fields,
        titleInfo,
        trackTitle,
        albumArtistInfo,
        albumArtist,
        pictureInfo,
        picture,
        audioFieldInfo,
        rawMp3,
        albumTitleInfo,
        albumTitle,
        catalogueInfo,
        catalogue,
        trackArtistInfo,
        trackArtist,
        trackSeqInfo,
        trackSeqRaw,
        trackSeq,
        visibility: visibilityRaw,
        isVisible,
        playableSrc,
        isPlayable: isVisible && Boolean(playableSrc),
        producer,
        language,
        genre,
        isrc,
        composers: composerValues,
        composer1,
        composer2,
        composer3,
        composer4,
        year
      };
      song._randomContext = context;
      return context;
    }

    function removePlayedRandomSongCards(){
      if (!albumsEl || currentMode !== 'songs' || !currentRow) return;
      let pointer = albumsEl.firstElementChild;
      while (pointer && pointer !== currentRow) {
        const next = pointer.nextElementSibling;
        if (!pointer.classList.contains('playing') && !pointer.classList.contains('loading')) {
          pointer.remove();
        }
        pointer = next;
      }
    }

    function updateRandomSongLabels() {
      console.log('[updateRandomSongLabels] Called - albumsEl:', !!albumsEl, 'currentMode:', currentMode);
      if (!albumsEl || currentMode !== 'songs') return;
      const cards = Array.from(albumsEl.querySelectorAll('.card'));
      console.log('[updateRandomSongLabels] Found', cards.length, 'cards, autoplay active:', randomSongsAutoplay.active);

      // Debug: log what's in each card
      cards.forEach((card, i) => {
        const albumTitle = card.querySelector('.album')?.textContent || 'unknown';
        const trackTitle = card.querySelector('.heading')?.textContent || 'unknown';
        console.log(`[updateRandomSongLabels] Card ${i}: ${albumTitle} - ${trackTitle}`);
      });

      // Debug: log what's currently playing
      if (nowPlayingInfo && nowPlayingInfo.meta) {
        console.log('[updateRandomSongLabels] Currently playing:', nowPlayingInfo.meta.trackName || 'unknown', 'from', nowPlayingInfo.meta.albumTitle || 'unknown');
      }

      // Find which card is currently playing
      let playingIndex = -1;
      if (currentRow) {
        cards.forEach((card, idx) => {
          if (card === currentRow) {
            playingIndex = idx;
            console.log('[updateRandomSongLabels] Found currently playing card at index', idx);
          }
        });
      }

      // If we couldn't find by currentRow, try matching by track name
      if (playingIndex === -1 && nowPlayingInfo && nowPlayingInfo.meta) {
        const playingTrackName = nowPlayingInfo.meta.trackName;
        cards.forEach((card, idx) => {
          const cardTrackText = card.querySelector('.heading')?.textContent || '';
          // Extract just the track name from the card text (it may have artist appended)
          const cardTrackName = cardTrackText.split(/[•·]/)[0]?.trim() || cardTrackText.trim();
          if (cardTrackName === playingTrackName) {
            playingIndex = idx;
            console.log('[updateRandomSongLabels] Matched playing card by track name at index', idx);
          }
        });
      }

      // Remove cards BEFORE the currently playing one if we have 3+ cards
      if (cards.length >= 3 && randomSongsAutoplay.active && playingIndex > 0) {
        console.log('[updateRandomSongLabels] Removing', playingIndex, 'card(s) before currently playing card');
        const cardsToRemove = cards.slice(0, playingIndex);

        cardsToRemove.forEach(card => {
          card.style.transition = 'opacity 0.4s ease-out, transform 0.4s ease-out';
          card.style.opacity = '0';
          card.style.transform = 'translateX(-100px)';
        });

        // Also animate remaining cards shifting left
        for (let i = playingIndex; i < cards.length; i++) {
          cards[i].style.transition = 'transform 0.4s ease-out';
          cards[i].style.transform = 'translateX(-20px)';
        }

        setTimeout(() => {
          cardsToRemove.forEach(card => card.remove());
          // Reset transform on remaining cards
          const remainingCards = Array.from(albumsEl.querySelectorAll('.card'));
          remainingCards.forEach(card => {
            card.style.transform = '';
          });
          // Update labels on remaining cards after removal
          refreshLabelsAfterShift();
        }, 400);
      } else {
        console.log('[updateRandomSongLabels] Not removing cards - playingIndex:', playingIndex, 'cards.length:', cards.length);
        refreshLabelsAfterShift();
      }
    }

    function refreshLabelsAfterShift() {
      console.log('[refreshLabelsAfterShift] Called');
      if (!albumsEl || currentMode !== 'songs') return;
      const cards = Array.from(albumsEl.querySelectorAll('.card'));
      console.log('[refreshLabelsAfterShift] Processing', cards.length, 'cards');

      // Find which card is actually playing by matching with currentRow
      let playingIndex = -1;
      if (currentRow) {
        cards.forEach((card, idx) => {
          if (card === currentRow) {
            playingIndex = idx;
            console.log('[refreshLabelsAfterShift] Found currently playing card at index', idx);
          }
        });
      }

      // If we couldn't find by currentRow, check by track data
      if (playingIndex === -1 && nowPlayingInfo && nowPlayingInfo.meta) {
        const playingTrackName = nowPlayingInfo.meta.trackName;
        const playingAlbumTitle = nowPlayingInfo.meta.albumTitle;
        cards.forEach((card, idx) => {
          const cardTrack = card.querySelector('.heading')?.textContent || '';
          const cardAlbum = card.querySelector('.album')?.textContent || '';
          if (cardTrack === playingTrackName && cardAlbum === playingAlbumTitle) {
            playingIndex = idx;
            console.log('[refreshLabelsAfterShift] Matched playing card by track/album at index', idx);
          }
        });
      }

      // Default to first card if we still can't find it
      if (playingIndex === -1) {
        playingIndex = 0;
        console.warn('[refreshLabelsAfterShift] Could not find playing card, defaulting to index 0');
      }

      cards.forEach((card, index) => {
        // Remove existing label if any
        const existingLabel = card.querySelector('.random-song-status');
        if (existingLabel) {
          existingLabel.remove();
        }

        // Add labels based on position relative to playing card
        if (index === playingIndex) {
          const statusLabel = document.createElement('div');
          statusLabel.className = 'random-song-status';
          statusLabel.style.cssText = 'font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; opacity: 0.7;';
          statusLabel.textContent = '▶ Now Playing';
          console.log('[refreshLabelsAfterShift] Adding "Now Playing" label to card', index);
          const heading = card.querySelector('.heading');
          if (heading) {
            card.insertBefore(statusLabel, heading);
          }
        } else if (index === playingIndex + 1) {
          const statusLabel = document.createElement('div');
          statusLabel.className = 'random-song-status';
          statusLabel.style.cssText = 'font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; opacity: 0.7;';
          statusLabel.textContent = '⏭ Up Next';
          console.log('[refreshLabelsAfterShift] Adding "Up Next" label to card', index);
          const heading = card.querySelector('.heading');
          if (heading) {
            card.insertBefore(statusLabel, heading);
          }
        }
      });
    }

    function advanceRandomSongsAutoplayFrom(anchor){
      if (!randomSongsAutoplay.active || currentMode !== 'songs') return false;
      let nextRow = anchor ? findNextPlayableRow(anchor) : findFirstRandomSongRow();
      while (nextRow && (!nextRow._src || !nextRow._btn || nextRow === anchor)) {
        nextRow = findNextPlayableRow(nextRow);
      }
    if (nextRow && nextRow._btn && nextRow._src) {
      randomSongsAutoplay.pendingStart = false;
      randomSongsAutoplay.retries = 0;
      console.log('[advanceRandomSongsAutoplayFrom] About to play next song');
      handlePlay(nextRow._btn, nextRow, nextRow._src);
      updateRandomSongsControlState();
      console.log('[advanceRandomSongsAutoplayFrom] Calling updateRandomSongLabels after playing next song');
      // Add slight delay to ensure DOM is updated after play starts
      setTimeout(() => {
        updateRandomSongLabels();
      }, 100);

      // Check if we need to load more songs (count remaining cards after current position)
      if (albumsEl && nextRow) {
        const allCards = Array.from(albumsEl.querySelectorAll('.card'));
        const currentIndex = allCards.indexOf(nextRow);
        const cardsAfterCurrent = allCards.length - currentIndex - 1;
        if (cardsAfterCurrent <= 1 && !randomSongsAutoplay.loadingNextPage) {
          console.log('[advanceRandomSongsAutoplayFrom] Only', cardsAfterCurrent, 'cards after current, loading more');
          triggerRandomSongsAutoplayNextPage({ skipRetryIncrement: true });
        }
      }

      return true;
    }
    if (!randomSongsAutoplay.loadingNextPage) {
      triggerRandomSongsAutoplayNextPage();
    }
    updateRandomSongsControlState();
    return true;
  }

    async function loadFeaturedAlbums(options = {}) {
      const { refresh = false } = options || {};
      console.log('[loadFeaturedAlbums] Loading featured albums');

      if (randomSongsAutoplay.active) {
        stopRandomSongsAutoplay();
      }
      const params = new URLSearchParams();
      params.set('limit', '100');  // Fetch enough tracks to get all featured albums
      if (refresh) params.set('refresh', '1');
      showBusy('Loading featured albums…');
      let success = false;
      try {
        if (loadingIndicator) loadingIndicator.hidden = true;
        if (albumsEl) albumsEl.style.display = '';
        const resp = await fetch(`/api/featured-albums?${params.toString()}`);
        if (!resp.ok) {
          throw new Error(`HTTP ${resp.status}`);
        }
        const payload = await resp.json();
        const items = Array.isArray(payload?.items) ? payload.items : [];
        rawItems = items;
        rawTotalFound = Number(payload?.total || items.length);
        rawNextOffset = items.length;
        lastQ = '';
        albumGroups = groupAlbums(items);
        albumPage = 0;
        currentMode = 'featured';
        currentExploreDecade = null;
        // Don't clear activePublicPlaylist if tracks are currently loading (prevents race condition)
        if (!publicPlaylistTracksLoading) {
          activePublicPlaylist = null;
        } else {
          console.log('[loadFeaturedAlbums] Not clearing activePublicPlaylist because playlist tracks are loading');
        }
        shouldScrollAlbums = true;
        renderAlbumPage();
        updateAuthUI();
        success = true;
        if (!items.length) {
          errorEl.hidden = false;
          errorEl.textContent = 'No featured albums flagged yet. Use "Choose Some Random Tracks" to explore randomly.';
        } else {
          errorEl.hidden = true;
        }
      } catch (err) {
        console.error('[loadFeaturedAlbums] Failed', err);
        rawItems = [];
        rawTotalFound = 0;
        rawNextOffset = 0;
        albumGroups = [];
        albumPage = 0;
        currentMode = 'featured';
        renderAlbumPage();
        errorEl.hidden = false;
        errorEl.textContent = `Failed to load featured albums: ${err.message || err}`;
      } finally {
        hideBusy();
        if (loadingIndicator) loadingIndicator.hidden = true;
        if (albumsEl) albumsEl.style.display = '';
        if (!success && shuffleBtn) {
          shuffleBtn.hidden = false;
          shuffleBtn.removeAttribute('hidden');
        }
        updateRandomSongsControlState();
      }
    }

    // Load stored genre preferences from Modern View
    function getStoredGenrePreferences() {
      try {
        const raw = localStorage.getItem('madmusic.genrePreferences');
        console.log('[getStoredGenrePreferences] Raw localStorage value:', raw);
        if (!raw) {
          console.log('[getStoredGenrePreferences] No genres found in localStorage');
          return [];
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          console.warn('[getStoredGenrePreferences] Parsed value is not an array:', parsed);
          return [];
        }
        const filtered = parsed
          .map((value) => (typeof value === 'string' ? value.trim() : ''))
          .filter(Boolean)
          .slice(0, 5); // Max 5 genres
        console.log('[getStoredGenrePreferences] Loaded genres from localStorage:', filtered);
        return filtered;
      } catch (err) {
        console.warn('[getStoredGenrePreferences] Failed to load genre preferences', err);
        return [];
      }
    }

    async function loadRandomSongs(options = {}) {
      const { autoplayResume = false, genres = null } = options || {};
      const effectiveGenres = genres !== null ? genres : getStoredGenrePreferences();
      console.log('[loadRandomSongs] Starting...', autoplayResume ? '(autoplay resume)' : '', effectiveGenres.length ? `with genres: ${effectiveGenres.join(', ')}` : '(no genre filter)');
      const perfStart = performance.now();

      // Don't show full-screen loading indicator for lazy load
      // Just ensure albums area is visible and show subtle loading state
      if (loadingIndicator) loadingIndicator.hidden = true;
      if (albumsEl) albumsEl.style.display = '';

      // Show subtle busy state
      showBusy(autoplayResume ? 'Loading next songs…' : 'Loading songs...');

      try {
        let totalCandidates = 0;
        const playableContexts = [];
        const seenKeys = new Set();
        let attempts = 0;

        while (playableContexts.length < RANDOM_SONGS_TARGET && attempts < RANDOM_SONGS_MAX_ATTEMPTS) {
          attempts += 1;
          const params = new URLSearchParams();
          params.set('count', String(RANDOM_SONGS_FETCH_BATCH));
          // Only send _t timestamp when loading more during shuffle (tells server to use buffer)
          // On initial load, omit _t to force fresh FileMaker query for true randomness
          if (autoplayResume) {
            params.set('_t', String(Date.now()));
          }
          params.set('attempt', String(attempts));
          if (Array.isArray(effectiveGenres) && effectiveGenres.length > 0) {
            effectiveGenres
              .map((value) => (typeof value === 'string' ? value.trim() : ''))
              .filter(Boolean)
              .slice(0, 5)
              .forEach((genre) => params.append('genre', genre));
          }
          const url = `/api/random-songs?${params.toString()}`;
          console.log('[loadRandomSongs] Fetching from', url);
          const attemptStart = performance.now();
          const resp = await fetch(url);
          const fetchTime = performance.now() - attemptStart;
          if (!resp.ok) {
            console.error('[loadRandomSongs] API returned error:', resp.status, resp.statusText);
            errorEl.hidden = false;
            errorEl.textContent = `Failed to load songs: ${resp.statusText || resp.status}`;
            break;
          }

          const parseStart = performance.now();
          const payload = await resp.json();
          const parseTime = performance.now() - parseStart;

          const items = Array.isArray(payload?.items) ? payload.items : [];
          if (!items.length) {
            console.warn('[loadRandomSongs] Attempt returned no items');
          }

          for (const item of items) {
            const context = buildRandomSongContext(item);
            if (!context) continue;
            const key = item.recordId || `${context.trackTitle}|${context.albumArtist}|${context.catalogue}`;
            if (key && seenKeys.has(key)) continue;
            if (key) seenKeys.add(key);
            totalCandidates += 1;
            if (context.isPlayable) playableContexts.push(context);
          }

          console.log(`[loadRandomSongs] attempt=${attempts} fetched=${items.length} playable=${playableContexts.length} (batchFetch=${fetchTime.toFixed(0)}ms parse=${parseTime.toFixed(0)}ms)`);
        }

        if (!playableContexts.length) {
          console.warn('[loadRandomSongs] No playable songs after filtering', { totalFetched: totalCandidates, attempts });
          renderSongsGrid([]);
          return;
        }

        const selectedContexts = playableContexts.slice(0, RANDOM_SONGS_TARGET);
        const selectedSongs = selectedContexts.map((ctx) => ctx.song);

        const totalTime = performance.now() - perfStart;
        console.log(`[loadRandomSongs] Selected ${selectedSongs.length} playable songs in ${totalTime.toFixed(0)}ms (attempts=${attempts}, considered=${totalCandidates})`);

        // Set mode
        currentMode = 'songs';
        activePublicPlaylist = null;

        // Hide public playlists row
        try {
          if (publicFeaturedRow) publicFeaturedRow.setAttribute('hidden', '');
        } catch {}

        // Render songs
        renderSongsGrid(selectedSongs, { autoplayResume });
        updateAuthUI();

        // Show playlists column even for guests when playback is active
        try {
          ensurePlaylistColumnVisible();
        } catch {}

      } catch (err) {
        console.error('[loadRandomSongs] Exception:', err);
        errorEl.hidden = false;
        errorEl.textContent = `Error loading songs: ${err.message || err}`;
      } finally {
        // Always hide loading indicator and restore albumsEl display
        hideBusy();
        if (loadingIndicator) loadingIndicator.hidden = true;
        if (albumsEl) albumsEl.style.display = '';
        updateRandomSongsControlState();
      }
    }
    window.loadRandomSongs = loadRandomSongs;


    function renderSongsGrid(songs, options = {}) {
      const { autoplayResume = false } = options;
      console.log('[renderSongsGrid] Called with', songs.length, 'songs, autoplayResume:', autoplayResume);
      console.log('[renderSongsGrid] shuffleBtn exists:', !!shuffleBtn, 'current hidden state:', shuffleBtn?.hidden);
      if (loadingIndicator) loadingIndicator.hidden = true;
      if (albumsEl) albumsEl.style.display = '';

      // Only clear the grid on initial load, not when loading more songs during autoplay
      if (!autoplayResume) {
        albumsEl.innerHTML = '';
      }
      pagerEl.hidden = true;
      if (shuffleBtn) {
        shuffleBtn.hidden = false;
        console.log('[renderSongsGrid] Set shuffleBtn.hidden = false');
      }

      if (errorEl) {
        errorEl.hidden = true;
        errorEl.textContent = '';
      }

      let renderedCount = 0;

      let allowedAutoplayAppend = Infinity;
      if (autoplayResume) {
        removePlayedRandomSongCards();
        const visibleCards = albumsEl ? albumsEl.querySelectorAll('.card').length : 0;
        allowedAutoplayAppend = Math.max(0, RANDOM_SONGS_TARGET - visibleCards);
        console.log('[renderSongsGrid] Autoplay resume detected existing cards:', visibleCards, 'slots available:', allowedAutoplayAppend);
      }

      for (const song of songs) {
        if (autoplayResume && allowedAutoplayAppend <= 0) {
          console.log('[renderSongsGrid] Reached target card count during autoplay resume, skipping extra songs');
          break;
        }
        const context = buildRandomSongContext(song);
        if (!context || !context.isPlayable) {
          console.log('[renderSongsGrid] Skipping non-playable song context');
          continue;
        }
        try {
          const trackTitle = context.trackTitle;
          const albumArtist = context.albumArtist;
          const pictureInfo = context.pictureInfo;
          const picture = context.picture;
          const audioField = context.audioFieldInfo;
          const albumTitle = context.albumTitle;
          const catalogue = context.catalogue;
          const trackArtist = context.trackArtist;
          const trackSeqRaw = context.trackSeqRaw;
          const rawMp3 = context.rawMp3;
          const playableSrc = context.playableSrc;

          const card = document.createElement('article');
          card.className = 'card';

          console.log('[renderSongsGrid] Track:', trackTitle, 'Artist:', albumArtist, 'Audio:', !!audioField.value, 'Picture:', !!picture);

          card._src = playableSrc;
          card._btn = null;
          if (context.year) card.dataset.year = context.year;
          card._meta = {
            trackName: trackTitle,
            trackArtist,
            albumTitle,
            albumArtist,
            playlistId: null,
            playlistName: '',
            picture: picture || '',
            source: 'random',
            catalogue,
            audioField: audioField.field || '',
            trackRecordId: song.recordId || '',
            pictureField: pictureInfo.field || '',
            mp3: rawMp3,
            rawUrl: rawMp3,
            S3_URL: audioField.field === 'S3_URL' ? rawMp3 : '',
            seq: context.trackSeq,
            src: playableSrc,
            producer: context.producer,
            language: context.language,
            genre: context.genre,
            isrc: context.isrc,
            composer1: context.composer1,
            composer2: context.composer2,
            composer3: context.composer3,
            composer4: context.composer4,
            composers: Array.isArray(context.composers) ? context.composers.slice() : []
          };

          const wrap = document.createElement('div');
          wrap.className = 'cover-wrap';
          const img = document.createElement('img');
          if (picture) {
            img.src = `/api/container?u=${encodeURIComponent(picture)}`;
            img.onerror = () => {
              img.src = '/img/placeholder.png';
              img.classList.add('placeholder-image');
            };
          } else {
            img.src = '/img/placeholder.png';
            img.classList.add('placeholder-image');
          }
          img.alt = 'Cover';
          img.loading = 'lazy';
          wrap.appendChild(img);

          wrap.addEventListener('click', () => {
            console.log('[Cover Click] Searching for artist:', albumArtist);
            if (searchEl) searchEl.value = albumArtist;
            run(albumArtist);
          });
          wrap.title = `Search for ${albumArtist}`;

          card.appendChild(wrap);

          const heading = document.createElement('div');
          heading.className = 'heading';
          heading.style.cursor = 'pointer';

          const h3 = document.createElement('h3');
          h3.textContent = trackTitle;
          heading.appendChild(h3);

          const artistDiv = document.createElement('div');
          artistDiv.className = 'card-artist';
          artistDiv.textContent = albumArtist;
          heading.appendChild(artistDiv);

          // Make heading clickable to play track and store references for skip button
          if (audioField.value && playableSrc) {
            const tempBtn = document.createElement('button');
            tempBtn.dataset.loadingLabel = 'Loading…';
            tempBtn.dataset.playLabel = '▶ Play';
            tempBtn.dataset.pauseLabel = '⏸ Pause';
            tempBtn.dataset.playAria = 'Play track';
            tempBtn.dataset.pauseAria = 'Pause playback';

            heading.addEventListener('click', () => {
              handlePlay(tempBtn, card, playableSrc);
            });
            heading.title = 'Click to play';

            // Store references for skip button functionality
            card._btn = tempBtn;
            card._src = playableSrc;
          }

          card.appendChild(heading);

          const buttonContainer = document.createElement('div');
          buttonContainer.className = 'card-buttons';

          const addBtn = document.createElement('button');
          addBtn.className = 'btn secondary small';
          addBtn.textContent = '+ Playlist';
          addBtn.addEventListener('click', () => {
            const albumData = {
              title: albumTitle,
              artist: albumArtist,
              catalogue,
              picture,
              pictureField: pictureInfo.field || ''
            };

            const trackData = {
              recordId: song.recordId || '',
              name: trackTitle,
              trackArtist,
              seq: trackSeqRaw,
              mp3: rawMp3,
              mp3Field: audioField.field || '',
              audioField: audioField.field || ''
            };

            handleAddToPlaylist(albumData, trackData, playableSrc);
          });
          buttonContainer.appendChild(addBtn);

          card.appendChild(buttonContainer);

          albumsEl.appendChild(card);

          // Autoplay the first track and engage shuffle play (only on initial load, not when resuming)
          if (!autoplayResume && renderedCount === 0 && card._btn && card._src) {
            setTimeout(() => {
              console.log('[renderSongsGrid] Autoplaying first track and engaging shuffle play:', trackTitle);
              handlePlay(card._btn, card, card._src);
              // Enable shuffle play mode
              randomSongsAutoplay.active = true;
              randomSongsAutoplay.retries = 0;
              randomSongsAutoplay.pendingStart = false;
              updateRandomSongsAutoplayButton();
            }, 300);
          }

          renderedCount += 1;
          if (autoplayResume) {
            allowedAutoplayAppend -= 1;
          }
          console.log('[renderSongsGrid] Card added for', trackTitle);
        } catch (err) {
          console.error('[renderSongsGrid] Error rendering song:', err);
        }
      }

      if (countEl) {
        const totalVisible = albumsEl ? albumsEl.querySelectorAll('.card').length : 0;
        countEl.textContent = totalVisible ? `${totalVisible} Random Songs` : 'No playable songs';
      }
      // Only show error if no songs were rendered AND there are no existing cards in the grid
      const totalVisible = albumsEl ? albumsEl.querySelectorAll('.card').length : 0;
      if (!renderedCount && totalVisible === 0) {
        if (errorEl) {
          errorEl.hidden = false;
          errorEl.textContent = songs.length
            ? 'No playable songs available. Try loading another set.'
            : 'No songs available. Please try again.';
        }
      }
      if (shufflePlayBtn) {
        shufflePlayBtn.hidden = false;
        updateRandomSongsAutoplayButton();
      }
      updateRandomSongsControlState();
      // Only kick off autoplay check on initial load, not when appending during shuffle play
      if (!autoplayResume && randomSongsAutoplay.active && randomSongsAutoplay.pendingStart) {
        scheduleRandomSongsAutoplayCheck();
      }
      console.log('[renderSongsGrid] Finished rendering', albumsEl.children.length, 'cards');
    }

    async function loadRandomAlbums() {
      const perfStart = performance.now();
      // Show loading indicator
      if (loadingIndicator) loadingIndicator.hidden = false;
      if (albumsEl) albumsEl.style.display = 'none';

      try {
        // Pick a random decade from 1950s to 2020s
        const decades = [1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020];
        const randomDecade = decades[Math.floor(Math.random() * decades.length)];
        const start = randomDecade;
        const end = start + 9;

        const params = new URLSearchParams();
        params.set('start', String(start));
        params.set('end', String(end));
        params.set('limit', '150'); // Balanced: enough albums without timing out

        const fetchStart = performance.now();
        const r = await fetch(`/api/explore?${params}`);
        const fetchTime = performance.now() - fetchStart;
        if (!r.ok) {
          return;
        }

        const parseStart = performance.now();
        const j = await r.json();
        const parseTime = performance.now() - parseStart;

        if (!j || !Array.isArray(j.items) || j.items.length === 0) {
          return;
        }

        rawItems = j.items || [];
        rawTotalFound = Number(j.total || rawItems.length);

        const groupStart = performance.now();
        const groupedAlbums = groupAlbums(rawItems);
        const groupTime = performance.now() - groupStart;

        if (!groupedAlbums.length) {
          return;
        }

        // Shuffle and keep all albums for pagination
        const shuffleStart = performance.now();
        shuffleInPlace(groupedAlbums);
        const shuffleTime = performance.now() - shuffleStart;

        albumGroups = groupedAlbums;
        rawItems = albumGroups;
        rawTotalFound = albumGroups.length;
        rawNextOffset = albumGroups.length;

        const totalTime = performance.now() - perfStart;
        console.log(`[loadRandomAlbums] Loaded ${albumGroups.length} albums from ${j.items.length} tracks in ${totalTime.toFixed(0)}ms (fetch: ${fetchTime.toFixed(0)}ms)`);

        albumPage = 0;
        currentMode = 'explore';
        currentExploreDecade = null; // Random load, no specific decade
        activePublicPlaylist = null;

        // Set up explore layout
        try {
          const contentCol = document.querySelector('.content-column');
          if (contentCol) contentCol.classList.add('exploring');
        } catch {}

        // Skip expensive audio validation on initial load
        // primeAlbumAudioValidation(albumGroups);
        refreshPublicPlaylists();
        renderAlbumPage();
        updateAuthUI(); // Show featured playlists panel

        // Show playlists
        try {
          ensurePlaylistColumnVisible();
          if (publicFeaturedRow) publicFeaturedRow.removeAttribute('hidden');
        } catch {}

      } catch (err) {
        console.warn('[loadRandomAlbums]', err);
      } finally {
        // Always hide loading indicator
        if (loadingIndicator) loadingIndicator.hidden = true;
        if (albumsEl) albumsEl.style.display = '';
      }
    }
function hideLanding(){ /* no-op: placeholder removed */ }function doSearch(q, options = {}){
      abortInFlight();
      const ctrl = new AbortController();
      inFlight = ctrl;
      const params = new URLSearchParams();
      if (q) params.set('q', q);
      const genreValue = typeof options.genre === 'string' ? options.genre.trim() : '';
      if (genreValue) params.set('genre', genreValue);
      params.set('offset', 0);
      params.set('limit',  FM_FETCH_LIMIT);
      return fetch(`/api/search?${params}`, { signal: ctrl.signal })
        .then(async r => {
          if (!r.ok) throw new Error(await r.text().catch(() => `HTTP ${r.status}`));
          return r.json();
        })
        .finally(() => { if (inFlight === ctrl) inFlight = null; });
        }

    function prepareSearchLayout(){
      try {
        const contentCol = document.querySelector('.content-column');
        contentCol && contentCol.classList.remove('exploring');
      } catch {}
      try {
        if (playlistColumn) playlistColumn.setAttribute('hidden','');
        if (publicFeaturedRow) publicFeaturedRow.setAttribute('hidden','');
      } catch {}
      if (errorEl) {
        errorEl.hidden = true;
        errorEl.textContent = '';
      }
    }

    function beginSearchSession(term){
      if (sharedPlaylistActive) {
        clearSharedPlaylistState();
      }
      const restoringThisRun = isRestoring;
      if (!isRestoring) {
        const hasPrevious = albumGroups.length || rawItems.length;
        if (hasPrevious) {
          const previousTerm = lastQ;
          const snapshot = snapshotState({ lastQ: previousTerm, searchValue: previousTerm });
          prevSearch = { type: snapshot.mode || currentMode, term: previousTerm, snapshot };
        } else {
          prevSearch = null;
        }
      }
      lastQ = term;
      albumsEl.classList.remove('single-album');
      hideLanding();
      shouldScrollAlbums = true;
      return restoringThisRun;
    }

    function finalizeSearch(restoringThisRun){
      hideBusy();
      if (restoringThisRun) isRestoring = false;
    }

    function clearAiInterpretation(){
      if (!aiSearchInterpretation) return;
      aiSearchInterpretation.hidden = true;
      aiSearchInterpretation.textContent = '';
    }

    function setAiStatus(message, visible = true){
      if (!aiSearchStatus) return;
      if (visible) {
        aiSearchStatus.hidden = false;
        if (aiSearchStatusText) aiSearchStatusText.textContent = message || 'Asking AI…';
      } else {
        aiSearchStatus.hidden = true;
      }
    }

    function showAiInterpretation(criteria, query){
      if (!aiSearchInterpretation) return;
      if (!criteria || typeof criteria !== 'object') {
        clearAiInterpretation();
        return;
      }
      const normalize = (value) => {
        const str = String(value || '').trim();
        if (!str || str.toLowerCase() === 'null') return '';
        return str;
      };
      const parts = [];
      const artist = normalize(criteria.artist);
      if (artist) parts.push(`Artist: ${artist}`);
      const album = normalize(criteria.album);
      if (album) parts.push(`Album: ${album}`);
      const track = normalize(criteria.track);
      if (track) parts.push(`Track: ${track}`);
      const genre = normalize(criteria.genre);
      if (genre) parts.push(`Genre: ${genre}`);
      const year = normalize(criteria.year);
      if (year) parts.push(`Year: ${year}`);
      const language = normalize(criteria.language);
      if (language) parts.push(`Language: ${language}`);
      const keywords = normalize(criteria.queryText || criteria.keywords || criteria.q);
      if (keywords) parts.push(`Keywords: ${keywords}`);
      aiSearchInterpretation.textContent = parts.length
        ? `AI interpreted "${query}" as → ${parts.join(' • ')}`
        : `AI interpreted "${query}" but no structured filters were returned. Showing the best matches it found.`;
      aiSearchInterpretation.hidden = false;
    }

    function applySearchResults(json, q, options = {}){
      rawItems = json?.items || [];
      rawTotalFound = Number(json?.total || rawItems.length);
      const rawReturned = typeof json?.rawReturnedCount === 'number' ? json.rawReturnedCount : rawItems.length;
      rawNextOffset = Number(json?.offset || 0) + rawReturned;

      activePublicPlaylist = null;
      currentMode = 'search';
      currentExploreDecade = null;
      albumGroups = groupAlbums(rawItems);
      const source = options.source || 'search';
      console.log(`[${source}] Found ${albumGroups.length} unique albums from ${rawItems.length} tracks (query: "${q}")`);
      refreshPublicPlaylists();
      albumPage = 0;
      renderAlbumPage();

      if (options.aiInterpretation) {
        showAiInterpretation(options.aiInterpretation, q);
      } else if (!options.keepAiInterpretation) {
        clearAiInterpretation();
      }
    }


    // Strong normalization to reduce bogus “same album different title”
    function normTitle(s){
      return String(s||'')
        .replace(/\s+/g,' ')
        .replace(/[\u2018\u2019]/g,"'")
        .replace(/[\u201C\u201D]/g,'"')
        .replace(/^\W+|\W+$/g,'') // trim leading/trailing punctuation
        .trim();
        }
    function keyTitle(s){ return normTitle(s).toLowerCase(); }

    function makeAlbumKey(catalogue, title, artist){
      const cat = String(catalogue || '').trim();
      if (cat) return `cat:${cat.toLowerCase()}`;
      const normT = normTitle(title || '').toLowerCase();
      const normA = normTitle(artist || '').toLowerCase();
      return `title:${normT}|artist:${normA}`;
        }

    function groupAlbums(items){
      const byCat = new Map();

      for (const rec of items) {
        const f = rec.fields || {};
        const cat = fCatalogue(f) || '__NO_CAT__';
        const title = normTitle(fTitle(f) || '(no album)');
        const artist= normTitle(fArtist(f) || '');
        const trackArtist = normTitle(f['Track Artist'] || f['Tape Files::Track Artist'] || '');
        const pictureInfo = pickFieldValue(f, ARTWORK_FIELD_CANDIDATES);
        const pic   = String(pictureInfo.value || '').trim();
        const pictureField = pictureInfo.field || '';
        const track = normTitle(f[F_TRACK] || '');
        const mp3Info = pickFieldValue(f, AUDIO_FIELD_CANDIDATES);
        const mp3   = mp3Info.value || '';
        const mp3Field = mp3Info.field || '';
        const s3Url = typeof f['S3_URL'] === 'string' ? f['S3_URL'].trim() : '';
        const publicPlaylistInfo = pickFieldValue(f, PUBLIC_PLAYLIST_FIELD_CANDIDATES);
        const publicPlaylistRaw = publicPlaylistInfo.value || '';
        const playlistNames = publicPlaylistRaw
          ? publicPlaylistRaw.split(/[,;|\n\r]/).map((value) => value.trim()).filter(Boolean)
          : [];
        const genre = normTitle(f[F_GENRE] || '');
        const comps = composersFrom(f).map(value => normTitle(value || ''));
        const prod  = normTitle(f['Producer'] || '');
        const lang  = normTitle(fLang(f) || '');
        const composer1 = normTitle(f['Composer'] || f['Composer 1'] || f['Composer1'] || '');
        const composer2 = normTitle(f['Composer 2'] || f['Composer2'] || '');
        const composer3 = normTitle(f['Composer 3'] || f['Composer3'] || '');
        const composer4 = normTitle(f['Composer 4'] || f['Composer4'] || '');
        const isrc = (f['ISRC'] || '').trim();
        const yearInfo = pickFieldValue(f, ['Year', 'Year Recorded', 'Year_Recorded', 'Release Year', 'Release_Year', 'Date', 'Tape Files::Year']);
        const year = normTitle(yearInfo.value || '');
        // Check Audio Test field for invalid/bad audio markers
        const audioTest = String(f['songfiles:Audio Test'] || f['Songfiles::Audio Test'] || f['songfiles::Audio Test'] || f['Audio Test'] || '').toLowerCase();
        const hasValidAudio = audioTest ? !audioTest.includes('invalid') : true;

        if(!byCat.has(cat)){
          byCat.set(cat, {
            catalogue: cat === '__NO_CAT__' ? '' : cat,
            titles: new Map(), // keyTitle -> {raw,count}
            artist,
            picture: pic || '',
            pictureField: pictureField || '',
            tracks: [],
            year: year || ''
          });
        }
        const g = byCat.get(cat);

        const kt = keyTitle(title);
        const entry = g.titles.get(kt) || { raw: title, count: 0 };
        entry.count += 1; g.titles.set(kt, entry);

        if(!g.picture && pic) {
          g.picture = pic;
          g.pictureField = pictureField;
        }
        if(!g.artist && artist) g.artist = artist;
        if(!g.year && year) g.year = year;

        // keep all tracks for title logic; mp3 validity filtered later
        if(track){
          const orderIndex = g.tracks.length;
          g.tracks.push({
            name: track,
            mp3,
            mp3Field,
            genre,
            composers: comps,
            producer: prod,
            language: lang,
            trackArtist,
            pictureField,
            composer1,
            composer2,
            composer3,
            composer4,
            isrc,
            publicPlaylists: playlistNames,
            seq: parseTrackSequence(f),
            recordId: rec.recordId || '',
            _order: orderIndex,
            hasValidAudio,
            S3_URL: s3Url
          });
        }
      }

      const groups = [];
      for(const g of byCat.values()){
        const trimmedPicture = (g.picture || '').trim();
        // Removed hard filter for missing pictures - let toggle control this
        // if (!trimmedPicture) continue;

        if (!g.tracks.length) continue;

        const playableTracks = g.tracks.filter(t => hasValidMp3(t.S3_URL || t.mp3) && t.hasValidAudio);
        // Removed hard filter for no playable tracks - let toggle control this
        // if (!playableTracks.length) continue;

        // Only show tracks with valid audio
        const tracksForDisplay = playableTracks.map(track => ({ ...track }));

        const albumPlaylistMap = new Map();
        for (const track of g.tracks) {
          if (!Array.isArray(track.publicPlaylists)) continue;
          for (const name of track.publicPlaylists) {
            const trimmed = String(name || '').trim();
            if (!trimmed) continue;
            const key = trimmed.toLowerCase();
            if (!albumPlaylistMap.has(key)) albumPlaylistMap.set(key, trimmed);
          }
        }
        const albumPublicPlaylists = Array.from(albumPlaylistMap.values());

        // Ignore title candidates that equal any track name (prevents “Sunday Afternoon” issue)
        const trackKeys = new Set(g.tracks.map(t => keyTitle(t.name)));
        const candidates = Array.from(g.titles.entries()); // [keyTitle, {raw,count}]
        const filtered = candidates.filter(([kt]) => !trackKeys.has(kt));

        const pickFrom = (arr) => arr.reduce((best, cur) => (!best || cur[1].count > best[1].count) ? cur : best, null);
        const pickedPair = pickFrom(filtered.length ? filtered : candidates);
        const displayTitle = pickedPair ? pickedPair[1].raw : '(no album)';

        // Sort playable tracks (replace with Track No if available)
        tracksForDisplay.sort((a, b) => {
          const aSeq = Number(a.seq);
          const bSeq = Number(b.seq);
          const aFinite = Number.isFinite(aSeq);
          const bFinite = Number.isFinite(bSeq);
          if (aFinite && bFinite && aSeq !== bSeq) return aSeq - bSeq;
          if (aFinite && !bFinite) return -1;
          if (!aFinite && bFinite) return 1;
          const aOrder = Number.isFinite(a._order) ? a._order : Number.POSITIVE_INFINITY;
          const bOrder = Number.isFinite(b._order) ? b._order : Number.POSITIVE_INFINITY;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
        });

        const albumKey = makeAlbumKey(g.catalogue, displayTitle, g.artist);
        const hasPlayable = playableTracks.length > 0;
        groups.push({
          catalogue: g.catalogue,
          title: displayTitle,
          artist: g.artist,
          picture: trimmedPicture,
          pictureField: g.pictureField || '',
          tracks: tracksForDisplay,
          hasPlayable,
          publicPlaylists: albumPublicPlaylists,
          key: albumKey,
          year: g.year || ''
        });
      }

      groups.sort((a,b)=> a.title.localeCompare(b.title, undefined, { sensitivity:'base' }) || a.artist.localeCompare(b.artist, undefined, { sensitivity:'base' }));
      return groups;
        }

    function computePublicPlaylistsFromAlbums(albums){
      const summaryMap = new Map();
      for (const album of albums || []) {
        if (!album) continue;
        const albumKey = album.key || '';
        const tracks = Array.isArray(album.tracks) ? album.tracks : [];
        const trackCount = tracks.length;
        const names = Array.isArray(album.publicPlaylists) ? album.publicPlaylists : [];
        if (!names.length) continue;
        for (const rawName of names) {
          const trimmed = String(rawName || '').trim();
          if (!trimmed) continue;
          const key = trimmed.toLowerCase();
          let entry = summaryMap.get(key);
          if (!entry) {
            entry = { name: trimmed, albumKeys: new Set(), albumCount: 0, trackCount: 0 };
            summaryMap.set(key, entry);
          }
          if (!entry.albumKeys.has(albumKey)) {
            entry.albumKeys.add(albumKey);
            entry.albumCount += 1;
            entry.trackCount += trackCount;
          }
        }
      }
      const summary = Array.from(summaryMap.values()).map(({ name, albumCount, trackCount, image }) => ({ name, albumCount, trackCount, image: image || '' }));
      summary.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      return summary;
        }

    function setActivePublicPlaylist(nextName, imageHint = ''){
      if (!publicPlaylistsLoaded && !publicPlaylistsLoading) {
        loadPublicPlaylistSummaries();
      }
      const name = typeof nextName === 'string' ? nextName.trim() : '';
      const currentKey = activePublicPlaylist ? activePublicPlaylist.toLowerCase() : '';
      const nextKey = name.toLowerCase();
      const summaryEntry = publicPlaylistsSummary.find((entry) => entry && typeof entry.name === 'string' && entry.name.toLowerCase() === nextKey) || null;
      const summaryImage = summaryEntry?.image || imageHint || '';

      if (!name || (currentKey && currentKey === nextKey && !publicPlaylistTracksLoading)) {
        activePublicPlaylist = null;
        activePublicPlaylistImage = '';
        activePublicPlaylistTracks = [];
        publicPlaylistTracksError = null;
        albumPage = 0;
        currentMode = 'featured';
        renderPublicPlaylists();
        renderPublicPlaylistView();
        loadFeaturedAlbums({ refresh: true });
        return;
      }

      activePublicPlaylist = name;
      activePublicPlaylistImage = summaryImage;
      currentMode = 'public-playlist';
      publicPlaylistTracksError = null;
      albumPage = 0;

      const cached = publicPlaylistTracksCache.get(nextKey);
      if (cached) {
        const cachedTracks = Array.isArray(cached.tracks) ? cached.tracks.slice() : [];
        console.log(`[setActivePublicPlaylist] Using cached ${cachedTracks.length} tracks for "${name}"`);
        activePublicPlaylistTracks = cachedTracks;
        renderPublicPlaylists();
        renderPublicPlaylistView();
        renderAlbumPage();
        return;
      }

      console.log(`[setActivePublicPlaylist] No cache for "${name}", loading from API`);
      activePublicPlaylistTracks = [];
      renderPublicPlaylists();
      renderPublicPlaylistView();
      renderAlbumPage();
      loadPublicPlaylistTracks(name);
        }

    function refreshPublicPlaylists(source = albumGroups){
      if (!publicPlaylistsLoaded && source) {
        publicPlaylistsSummary = computePublicPlaylistsFromAlbums(source || []);
      }
      if (activePublicPlaylist) {
        const activeKey = activePublicPlaylist.toLowerCase();
        const stillExists = publicPlaylistsSummary.some((entry) => entry.name.toLowerCase() === activeKey);
        if (!stillExists) activePublicPlaylist = null;
      }
      renderPublicPlaylists();
      renderPublicPlaylistView();
      updateAuthUI();
        }

    function renderPublicPlaylists(){
      if (publicPlaylistsEmpty) {
        if (publicPlaylistsLoading) {
          publicPlaylistsEmpty.textContent = 'Loading curated playlists…';
          publicPlaylistsEmpty.hidden = false;
        } else if (publicPlaylistsError) {
          publicPlaylistsEmpty.textContent = publicPlaylistsError;
          publicPlaylistsEmpty.hidden = false;
        } else {
          publicPlaylistsEmpty.textContent = 'No curated playlists yet.';
          publicPlaylistsEmpty.hidden = (publicPlaylistsSummary.length > 0);
        }
      }

      if (!publicPlaylistsList) return;
      publicPlaylistsList.innerHTML = '';
      const items = Array.isArray(publicPlaylistsSummary) ? publicPlaylistsSummary : [];
      const activeKey = activePublicPlaylist ? activePublicPlaylist.toLowerCase() : '';
      if (!items.length) {
        syncPublicFeaturedVisibility();
        return;
      }

      items.forEach((item) => {
        const li = document.createElement('li');
        li.className = 'public-playlist-item';
        const button = document.createElement('button');
        button.type = 'button';
        button.dataset.playlistName = item.name || '';
        if (item.image) button.dataset.image = item.image;

        const thumb = document.createElement('span');
        thumb.className = 'public-playlist-thumb';
        const initialChar = (item.name || '').trim().charAt(0);
        thumb.textContent = initialChar || '♪';
        button.appendChild(thumb);

        const label = document.createElement('span');
        label.className = 'public-playlist-label';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'public-playlist-name';
        nameSpan.textContent = item.name || 'Playlist';
        label.appendChild(nameSpan);
        const countSpan = document.createElement('span');
        countSpan.className = 'public-playlist-count';
        const countParts = [];
        countParts.push(`${item.albumCount} album${item.albumCount === 1 ? '' : 's'}`);
        if (item.trackCount > 0) {
          countParts.push(`${item.trackCount} track${item.trackCount === 1 ? '' : 's'}`);
        }
        countSpan.textContent = countParts.join(' • ');
        label.appendChild(countSpan);
        button.appendChild(label);

        if (item.name && item.name.toLowerCase() === activeKey) {
          button.classList.add('active');
        }
        button.addEventListener('click', () => setActivePublicPlaylist(item.name, item.image || button.dataset.image || ''));
        applyPlaylistThumbArtwork(thumb, item.name, item.image || button.dataset.image || '');
        li.appendChild(button);
        publicPlaylistsList.appendChild(li);
      });

      syncPublicFeaturedVisibility();
        }

    // Main accordion toggle for My Playlists panel
    if (playlistsHeader) {
      console.log('[Accordion] Setting up click handler for playlistsHeader');
      playlistsHeader.addEventListener('click', function(e) {
        console.log('[Accordion] My Playlists header clicked');
        if (playlistsPanel) {
          playlistsPanel.classList.toggle('collapsed');
          console.log('[Accordion] My Playlists toggled, now:', playlistsPanel.classList.contains('collapsed') ? 'COLLAPSED' : 'EXPANDED');
        } else {
          console.error('[Accordion] playlistsPanel not found');
        }
      });
    } else {
      console.error('[Accordion] playlistsHeader not found');
    }

    // Main accordion toggle for Featured Playlists panel
    if (publicPlaylistsHeader) {
      console.log('[Accordion] Setting up click handler for publicPlaylistsHeader');
      publicPlaylistsHeader.addEventListener('click', function(e) {
        console.log('[Accordion] Featured Playlists header clicked');
        if (publicPlaylistsPanel) {
          publicPlaylistsPanel.classList.toggle('collapsed');
          console.log('[Accordion] Featured Playlists toggled, now:', publicPlaylistsPanel.classList.contains('collapsed') ? 'COLLAPSED' : 'EXPANDED');
        } else {
          console.error('[Accordion] publicPlaylistsPanel not found');
        }
      });
    } else {
      console.error('[Accordion] publicPlaylistsHeader not found');
    }

    async function loadPublicPlaylistSummaries(){
      if (publicPlaylistsLoaded || publicPlaylistsLoading) return;
      publicPlaylistsLoading = true;
      publicPlaylistsError = null;
      renderPublicPlaylists();
      updateAuthUI();
      try {
        const res = await fetch('/api/public-playlists', { headers: { 'Accept': 'application/json' } });
        if (!res.ok) {
          const text = await res.text().catch(() => `HTTP ${res.status}`);
          throw new Error(text || 'Unable to load curated playlists');
        }
        const data = await res.json().catch(() => ({}));
        if (Array.isArray(data?.playlists)) {
          publicPlaylistsSummary = data.playlists;
        } else {
          publicPlaylistsSummary = [];
        }
        publicPlaylistsLoaded = true;
        // Don't auto-select any playlist - let user click to view
      } catch (err) {
        publicPlaylistsError = err?.message || 'Unable to load curated playlists';
      } finally {
        publicPlaylistsLoading = false;
        renderPublicPlaylists();
        renderPublicPlaylistView();
        updateAuthUI();
      }
        }

    async function loadPublicPlaylistTracks(name){
      const key = name.toLowerCase();
      publicPlaylistTracksLoading = true;
      publicPlaylistTracksError = null;
      renderPublicPlaylistView();
      try {
        console.log(`[loadPublicPlaylistTracks] Fetching tracks for "${name}"`);
        const res = await fetch(`/api/public-playlists?name=${encodeURIComponent(name)}`, {
          headers: { 'Accept': 'application/json' }
        });
        if (!res.ok) {
          const text = await res.text().catch(() => `HTTP ${res.status}`);
          throw new Error(text || 'Unable to load playlist');
        }
        const data = await res.json().catch(() => ({}));
        console.log(`[loadPublicPlaylistTracks] API returned ${data?.tracks?.length || 0} tracks for "${name}"`, data);
        if (Array.isArray(data?.playlists)) {
          publicPlaylistsSummary = data.playlists;
          publicPlaylistsLoaded = true;
        }
        const tracks = Array.isArray(data?.tracks) ? data.tracks : [];
        console.log(`[loadPublicPlaylistTracks] Parsed ${tracks.length} tracks from API response`);
        const sortedTracks = tracks
          .slice()
          .sort((a, b) => {
            const aSeq = Number.isFinite(a?.seq) ? Number(a.seq) : Number.POSITIVE_INFINITY;
            const bSeq = Number.isFinite(b?.seq) ? Number(b.seq) : Number.POSITIVE_INFINITY;
            if (aSeq !== bSeq) return aSeq - bSeq;
            const aName = String(a?.name || '').toLowerCase();
            const bName = String(b?.name || '').toLowerCase();
            if (aName < bName) return -1;
            if (aName > bName) return 1;
            return 0;
          });
        publicPlaylistTracksCache.set(key, { tracks: sortedTracks.slice() });
        console.log(`[loadPublicPlaylistTracks] Set cache for "${key}" with ${sortedTracks.length} tracks`);
        // Always set tracks if this playlist is active, even if activePublicPlaylist was cleared by a race condition
        // The cache will be used next time the playlist is opened
        if (activePublicPlaylist && activePublicPlaylist.toLowerCase() === key) {
          activePublicPlaylistTracks = sortedTracks;
          console.log(`[loadPublicPlaylistTracks] Set activePublicPlaylistTracks to ${sortedTracks.length} tracks for "${name}"`);
        } else {
          console.log(`[loadPublicPlaylistTracks] Playlist "${name}" loaded but not active (activePublicPlaylist: "${activePublicPlaylist}")`);
        }
      } catch (err) {
        publicPlaylistTracksError = err?.message || 'Unable to load playlist tracks';
        if (activePublicPlaylist && activePublicPlaylist.toLowerCase() === key) {
          activePublicPlaylistTracks = [];
        }
      } finally {
        publicPlaylistTracksLoading = false;
        renderPublicPlaylists();
        renderPublicPlaylistView();
        renderAlbumPage();
      }
        }

    function createPublicPlaylistRow(track, idx, playlistId, playlistName){
      const li = document.createElement('li');
      li.className = 'track playlist-track public-playlist-track';

      const btnPlay = document.createElement('button');
      btnPlay.type = 'button';
      btnPlay.className = 'btn track-play';

      const srcCandidate = track?.resolvedSrc || track?.S3_URL || track?.mp3 || track?.rawUrl || '';
      const playableCandidate = resolvePlayableSrc(srcCandidate);
      const playableSrc = canValidateAudioSrc(playableCandidate) ? playableCandidate : '';
      const audioField = typeof track?.audioField === 'string' ? track.audioField.trim() : '';
      const artworkField = typeof track?.artworkField === 'string' ? track.artworkField.trim() : '';
      const playlistImage = activePublicPlaylistImage || '';

      li._src = playableSrc;
      li._btn = btnPlay;
      li._card = null;
      li._playlist = playlistId;
      li._audioField = audioField;
      li._valid = null;
      li._validated = false;
      li._validating = false;

      const trackId = track?.trackRecordId || track?.id || '';
      if (trackId) li.dataset.trackId = trackId;

      btnPlay.dataset.playLabel = '▶';
      btnPlay.dataset.pauseLabel = '⏸';

      const trackName = track?.name || 'Untitled track';
      const artist = (track?.trackArtist || track?.albumArtist || '').trim();
      const readable = artist ? `${artist} — ${trackName}` : trackName;
      btnPlay.dataset.playAria = `Play ${readable}`;
      btnPlay.dataset.pauseAria = `Pause ${readable}`;

      if (playableSrc) {
        btnPlay.textContent = btnPlay.dataset.playLabel;
        btnPlay.disabled = false;
        btnPlay.classList.remove('btn-error');
        btnPlay.setAttribute('aria-label', btnPlay.dataset.playAria);
      } else {
        btnPlay.textContent = 'No audio';
        btnPlay.disabled = true;
        btnPlay.classList.add('btn-error');
        btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
      }

      btnPlay.addEventListener('click', () => {
        if (!li._src) {
          window.alert('This track has no playable audio source.');
          return;
        }
        if (li._valid === false) {
          btnPlay.textContent = 'Unavailable';
          btnPlay.disabled = true;
          btnPlay.classList.add('btn-error');
          btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
          return;
        }
        handlePlay(btnPlay, li, li._src);
        if (li._valid === true || li._validating) return;
        li._validating = true;
        validateAudio(li, li._src, { optimistic: true }).finally(() => {
          li._validating = false;
        });
      });

      const wrapper = document.createElement('span');
      wrapper.className = 'track-name';

      if (artist) {
        const artistLine = document.createElement('span');
        artistLine.className = 'track-name-artist';
        artistLine.textContent = artist;
        wrapper.appendChild(artistLine);

        const titleLine = document.createElement('span');
        titleLine.className = 'track-name-title';
        titleLine.textContent = trackName;
        wrapper.appendChild(titleLine);
      } else {
        const titleLine = document.createElement('span');
        titleLine.className = 'track-name-title';
        titleLine.textContent = trackName;
        wrapper.appendChild(titleLine);
      }

      const tooltipParts = [artist, track?.albumTitle, track?.albumArtist].filter((part) => typeof part === 'string' && part.trim());
      if (tooltipParts.length) {
        const tooltip = tooltipParts.join(' • ');
        wrapper.title = tooltip;
        li.title = tooltip;
      }

      li.appendChild(btnPlay);
      li.appendChild(wrapper);

      const baseMeta = {
        trackName,
        trackArtist: track?.trackArtist || track?.albumArtist || '',
        albumTitle: track?.albumTitle || '',
        albumArtist: track?.albumArtist || '',
        catalogue: track?.catalogue || '',
        year: track?.year || '',
        playlistId,
        playlistName,
        playlistTrackId: trackId,
        trackRecordId: trackId,
        trackId,
        audioField,
        pictureField: artworkField || 'Artwork::Picture',
        picture: track?.picture || track?.albumPicture || playlistImage || '',
        albumPicture: track?.albumPicture || track?.picture || playlistImage || '',
        src: playableSrc,
        mp3: track?.mp3 || '',
        rawUrl: track?.rawUrl || '',
        S3_URL: track?.S3_URL || '',
        producer: track?.producer || '',
        language: track?.language || '',
        genre: track?.genre || '',
        isrc: track?.isrc || '',
        composer1: track?.composer1 || '',
        composer2: track?.composer2 || '',
        composer3: track?.composer3 || '',
        composer4: track?.composer4 || '',
        composers: Array.isArray(track?.composers) ? track.composers : [],
        albumKey: track?.albumKey || makeAlbumKey(track?.catalogue || '', track?.albumTitle || '', track?.albumArtist || ''),
        source: 'public-playlist'
      };
      li._meta = baseMeta;

      return { element: li, button: btnPlay, playableSrc };
        }

    function renderPublicPlaylistView(){
      if (!publicPlaylistView) return;
      const hasActive = Boolean(activePublicPlaylist);
      console.log(`[renderPublicPlaylistView] hasActive: ${hasActive}, activePublicPlaylist: "${activePublicPlaylist}", tracks: ${activePublicPlaylistTracks.length}`);

      if (!hasActive) {
        publicPlaylistView.hidden = true;
        if (publicPlaylistStatus) {
          publicPlaylistStatus.hidden = true;
          publicPlaylistStatus.textContent = '';
        }
        resetPlaylistArtwork(publicPlaylistArt, publicPlaylistHero);
        if (publicPlaylistTracks) publicPlaylistTracks.innerHTML = '';
        if (publicPlaylistEmpty) publicPlaylistEmpty.hidden = true;
        if (albumsEl) albumsEl.style.display = '';
        syncPublicFeaturedVisibility();
        return;
      }

      hideLanding();
      publicPlaylistView.hidden = false;
      hideLanding();
      if (albumsEl) albumsEl.style.display = 'none';
      if (pagerEl) pagerEl.hidden = true;
      if (errorEl) errorEl.hidden = true;

      const summaryEntry = publicPlaylistsSummary.find((entry) => entry && typeof entry.name === 'string' && entry.name.toLowerCase() === activePublicPlaylist.toLowerCase());
      const heroImage = activePublicPlaylistImage || summaryEntry?.image || '';
      if (!activePublicPlaylistImage && heroImage) activePublicPlaylistImage = heroImage;
      loadPlaylistArtwork(publicPlaylistArt, publicPlaylistHero, activePublicPlaylist, {
        preferredUrls: heroImage ? [heroImage] : [],
        altText: activePublicPlaylist ? `${activePublicPlaylist} artwork` : 'Playlist artwork'
      });
      if (publicPlaylistTitle) publicPlaylistTitle.textContent = summaryEntry?.name || activePublicPlaylist || 'Featured Playlist';

      const trackCount = activePublicPlaylistTracks.length;
      if (publicPlaylistMeta) {
        publicPlaylistMeta.textContent = '';
        publicPlaylistMeta.hidden = true;
      }

      if (publicPlaylistStatus) {
        if (publicPlaylistTracksLoading) {
          publicPlaylistStatus.textContent = 'Loading tracks…';
          publicPlaylistStatus.hidden = false;
        } else if (publicPlaylistTracksError) {
          publicPlaylistStatus.textContent = publicPlaylistTracksError;
          publicPlaylistStatus.hidden = false;
        } else {
          publicPlaylistStatus.textContent = '';
          publicPlaylistStatus.hidden = true;
        }
      }

      if (publicPlaylistTracks) {
        const previousState = (currentRow && currentRow._playlist === `public:${activePublicPlaylist.toLowerCase()}`)
          ? {
              playlistId: currentRow._playlist,
              src: currentRow._src,
              playing: !player.paused && currentSrc === currentRow._src
            }
          : null;
        let matchedPlayback = false;

        publicPlaylistTracks.innerHTML = '';

        if (!publicPlaylistTracksLoading && !publicPlaylistTracksError && trackCount > 0) {
          const playlistId = `public:${activePublicPlaylist.toLowerCase()}`;
          activePublicPlaylistTracks.forEach((track, idx) => {
            const { element, button, playableSrc } = createPublicPlaylistRow(track, idx, playlistId, activePublicPlaylist);
            publicPlaylistTracks.appendChild(element);

            if (
              playableSrc &&
              previousState &&
              previousState.src === playableSrc &&
              previousState.playlistId === playlistId
            ) {
              matchedPlayback = true;
              currentRow = element;
              currentBtn = button;
              if (previousState.playing) {
                element.classList.add('playing');
                button.textContent = button.dataset.pauseLabel || '⏸';
                button.classList.add('btn-accent');
                button.disabled = false;
                if (button.dataset.pauseAria) button.setAttribute('aria-label', button.dataset.pauseAria);
              } else {
                button.textContent = button.dataset.playLabel || '▶';
                button.classList.remove('btn-accent');
                if (button.dataset.playAria) button.setAttribute('aria-label', button.dataset.playAria);
              }
              setNowPlayingFromRow(element, previousState.playing);
            }
          });

          requestAnimationFrame(() => {
            if (!publicPlaylistTracks) return;
            const items = Array.from(publicPlaylistTracks.children);
            const maxVisible = 5;
            if (items.length <= maxVisible) {
              publicPlaylistTracks.style.maxHeight = '';
              return;
            }
            const first = items[0];
            const last = items[maxVisible - 1];
            if (!first || !last) {
              publicPlaylistTracks.style.maxHeight = '';
              return;
            }
            const firstRect = first.getBoundingClientRect();
            const lastRect = last.getBoundingClientRect();
            const height = Math.max(0, lastRect.bottom - firstRect.top + 4);
            publicPlaylistTracks.style.maxHeight = `${height}px`;
          });

          if (!previousState && nowPlayingInfo.meta && nowPlayingInfo.meta.playlistId === `public:${activePublicPlaylist.toLowerCase()}`) {
            const targetSrc = nowPlayingInfo.meta.src || nowPlayingInfo.meta.playlistSrc || '';
            const candidate = Array.from(publicPlaylistTracks.children).find((child) => child._src && child._src === targetSrc);
            if (candidate && candidate._btn) {
              currentRow = candidate;
              currentBtn = candidate._btn;
              candidate.classList.toggle('playing', nowPlayingInfo.isPlaying);
            }
          }

          if (previousState && previousState.playlistId === `public:${activePublicPlaylist.toLowerCase()}` && !matchedPlayback) {
            if (previousState.playing && !player.paused && currentSrc === previousState.src) {
              player.pause();
            }
            currentSrc = '';
            updateButtonsForStop();
          }
        }
      }

      if (publicPlaylistTracks && (publicPlaylistTracksLoading || publicPlaylistTracksError || trackCount <= 5)) {
        publicPlaylistTracks.style.maxHeight = trackCount > 0 ? '' : '0px';
      }

      if (publicPlaylistEmpty) {
        const showEmpty = !publicPlaylistTracksLoading && !publicPlaylistTracksError && trackCount === 0;
        publicPlaylistEmpty.hidden = !showEmpty;
      }
      syncPublicFeaturedVisibility();
        }

    function collectSharedPlaylistArtwork(playlist){
      if (!playlist || typeof playlist !== 'object') return [];
      const seen = new Set();
      const tracks = Array.isArray(playlist.tracks) ? playlist.tracks : [];
      const results = [];
      for (const track of tracks) {
        if (!track || typeof track !== 'object') continue;
        const candidates = [
          typeof track.artwork === 'string' ? track.artwork.trim() : '',
          typeof track.picture === 'string' ? track.picture.trim() : '',
          typeof track.albumPicture === 'string' ? track.albumPicture.trim() : ''
        ];
        for (const candidate of candidates) {
          if (!candidate || seen.has(candidate)) continue;
          seen.add(candidate);
          results.push(candidate);
        }
      }
      return results;
        }

    function getShareIdFromLocation(){
      try {
        const params = new URLSearchParams(window.location.search);
        const share = params.get('share');
        return typeof share === 'string' ? share.trim() : '';
      } catch {
        return '';
      }
        }

    function ensureShareQueryParam(shareId){
      try {
        const url = new URL(window.location.href);
        if (typeof shareId === 'string' && shareId.trim()) {
          url.searchParams.set('share', shareId.trim());
        } else {
          url.searchParams.delete('share');
        }
        url.hash = '';
        const query = url.searchParams.toString();
        const next = `${url.pathname}${query ? `?${query}` : ''}`;
        window.history.replaceState({}, '', next);
      } catch {
        // ignore URL update failures
      }
        }

    function clearShareQueryParam(){
      try {
        const url = new URL(window.location.href);
        url.searchParams.delete('share');
        url.hash = '';
        const query = url.searchParams.toString();
        const next = `${url.pathname}${query ? `?${query}` : ''}`;
        window.history.replaceState({}, '', next);
      } catch {
        const path = (window.location && window.location.pathname) || '/';
        window.history.replaceState({}, '', path);
      }
        }

    function createSharedPlaylistRow(track, idx, options = {}){
      const playlistId = options.playlistId || 'shared';
      const playlistName = options.playlistName || 'Playlist';
      const playlistArt = options.playlistArt || '';
      const shareId = options.shareId || '';
      const li = document.createElement('li');
      li.className = 'track playlist-track public-playlist-track';

      const btnPlay = document.createElement('button');
      btnPlay.type = 'button';
      btnPlay.className = 'btn track-play';

      const srcCandidate = track?.resolvedSrc || track?.S3_URL || track?.mp3 || track?.rawUrl || '';
      const playableCandidate = resolvePlayableSrc(srcCandidate);
      const playableSrc = canValidateAudioSrc(playableCandidate) ? playableCandidate : '';
      const audioField = typeof track?.audioField === 'string' ? track.audioField.trim() : '';
      const artworkField = typeof track?.artworkField === 'string' ? track.artworkField.trim() : '';

      li._src = playableSrc;
      li._btn = btnPlay;
      li._card = null;
      li._playlist = playlistId;
      li._audioField = audioField;
      li._valid = null;
      li._validated = false;
      li._validating = false;

      const trackId = track?.trackRecordId || track?.id || '';
      if (trackId) li.dataset.trackId = trackId;

      btnPlay.dataset.playLabel = '▶';
      btnPlay.dataset.pauseLabel = '⏸';

      const trackName = track?.name || `Track ${idx + 1}`;
      const artist = (track?.trackArtist || track?.albumArtist || '').trim();
      const readable = artist ? `${artist} — ${trackName}` : trackName;
      btnPlay.dataset.playAria = `Play ${readable}`;
      btnPlay.dataset.pauseAria = `Pause ${readable}`;

      if (playableSrc) {
        btnPlay.textContent = btnPlay.dataset.playLabel;
        btnPlay.disabled = false;
        btnPlay.classList.remove('btn-error');
        btnPlay.setAttribute('aria-label', btnPlay.dataset.playAria);
      } else {
        btnPlay.textContent = 'No audio';
        btnPlay.disabled = true;
        btnPlay.classList.add('btn-error');
        btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
      }

      btnPlay.addEventListener('click', () => {
        if (!li._src) {
          window.alert('This track has no playable audio source.');
          return;
        }
        if (li._valid === false) {
          btnPlay.textContent = 'Unavailable';
          btnPlay.disabled = true;
          btnPlay.classList.add('btn-error');
          btnPlay.setAttribute('aria-label', `Audio unavailable for ${readable}`);
          return;
        }
        handlePlay(btnPlay, li, li._src);
        if (li._valid === true || li._validating) return;
        li._validating = true;
        validateAudio(li, li._src, { optimistic: true }).finally(() => {
          li._validating = false;
        });
      });

      const wrapper = document.createElement('span');
      wrapper.className = 'track-name';

      if (artist) {
        const artistLine = document.createElement('span');
        artistLine.className = 'track-name-artist';
        artistLine.textContent = artist;
        wrapper.appendChild(artistLine);

        const titleLine = document.createElement('span');
        titleLine.className = 'track-name-title';
        titleLine.textContent = trackName;
        wrapper.appendChild(titleLine);
      } else {
        const titleLine = document.createElement('span');
        titleLine.className = 'track-name-title';
        titleLine.textContent = trackName;
        wrapper.appendChild(titleLine);
      }

      const tooltipParts = [artist, track?.albumTitle, track?.albumArtist].filter((part) => typeof part === 'string' && part.trim());
      if (tooltipParts.length) {
        const tooltip = tooltipParts.join(' • ');
        wrapper.title = tooltip;
        li.title = tooltip;
      }

      li.appendChild(btnPlay);
      li.appendChild(wrapper);

      const baseMeta = {
        trackName,
        trackArtist: track?.trackArtist || track?.albumArtist || '',
        albumTitle: track?.albumTitle || '',
        albumArtist: track?.albumArtist || '',
        catalogue: track?.catalogue || '',
        year: track?.year || '',
        playlistId,
        playlistName,
        playlistTrackId: trackId,
        trackRecordId: trackId,
        trackId,
        audioField,
        pictureField: artworkField || 'Artwork::Picture',
        picture: track?.artwork || track?.picture || track?.albumPicture || playlistArt || '',
        albumPicture: track?.albumPicture || track?.artwork || track?.picture || playlistArt || '',
        src: playableSrc,
        mp3: track?.mp3 || '',
        rawUrl: track?.rawUrl || '',
        S3_URL: track?.S3_URL || '',
        producer: track?.producer || '',
        language: track?.language || '',
        genre: track?.genre || '',
        isrc: track?.isrc || '',
        composer1: track?.composer1 || '',
        composer2: track?.composer2 || '',
        composer3: track?.composer3 || '',
        composer4: track?.composer4 || '',
        composers: Array.isArray(track?.composers) ? track.composers : [],
        albumKey: track?.albumKey || makeAlbumKey(track?.catalogue || '', track?.albumTitle || '', track?.albumArtist || ''),
        shareId,
        source: 'shared-playlist'
      };
      li._meta = baseMeta;

      return li;
        }

    function renderSharedPlaylistView(){
      if (!sharedPlaylistView) return;
      if (!sharedPlaylistActive) {
        sharedPlaylistView.hidden = true;
        if (sharedPlaylistStatus) {
          sharedPlaylistStatus.hidden = true;
          sharedPlaylistStatus.textContent = '';
        }
        resetPlaylistArtwork(sharedPlaylistArt, sharedPlaylistHero);
        if (sharedPlaylistTracks) sharedPlaylistTracks.innerHTML = '';
        if (sharedPlaylistEmpty) sharedPlaylistEmpty.hidden = true;
        if (sharedPlaylistMeta) {
          sharedPlaylistMeta.textContent = '';
          sharedPlaylistMeta.hidden = true;
        }
        if (sharedPlaylistCopyButton) sharedPlaylistCopyButton.disabled = true;
        if (albumsEl) albumsEl.style.display = '';
        if (pagerEl) pagerEl.hidden = false;
        syncPublicFeaturedVisibility();
        return;
      }

      hideLanding();
      sharedPlaylistView.hidden = false;
      if (albumsEl) albumsEl.style.display = 'none';
      if (pagerEl) pagerEl.hidden = true;
      if (errorEl) errorEl.hidden = true;
      syncPublicFeaturedVisibility();

      const playlistName = sharedPlaylistData?.name || 'Playlist';
      if (sharedPlaylistTitle) sharedPlaylistTitle.textContent = playlistName;

      if (sharedPlaylistStatus) {
        if (sharedPlaylistLoading) {
          sharedPlaylistStatus.hidden = false;
          sharedPlaylistStatus.textContent = 'Loading playlist…';
        } else if (sharedPlaylistError) {
          sharedPlaylistStatus.hidden = false;
          sharedPlaylistStatus.textContent = sharedPlaylistError;
        } else {
          sharedPlaylistStatus.hidden = true;
          sharedPlaylistStatus.textContent = '';
        }
      }

      if (sharedPlaylistCopyButton) {
        sharedPlaylistCopyButton.disabled = !sharedPlaylistShareUrl;
      }

      if (sharedPlaylistLoading || sharedPlaylistError || !sharedPlaylistData) {
        resetPlaylistArtwork(sharedPlaylistArt, sharedPlaylistHero);
        if (sharedPlaylistTracks) sharedPlaylistTracks.innerHTML = '';
        if (sharedPlaylistEmpty) sharedPlaylistEmpty.hidden = true;
        if (sharedPlaylistMeta) {
          sharedPlaylistMeta.textContent = '';
          sharedPlaylistMeta.hidden = true;
        }
        return;
      }

      const tracks = Array.isArray(sharedPlaylistData.tracks) ? sharedPlaylistData.tracks : [];
      const shareKey = activeSharedShareId ? `shared:${activeSharedShareId}` : 'shared:playlist';
      const artCandidates = collectSharedPlaylistArtwork(sharedPlaylistData);
      const fallbackArt = artCandidates[0] || '';

      loadPlaylistArtwork(sharedPlaylistArt, sharedPlaylistHero, playlistName, {
        preferredUrls: artCandidates,
        altText: playlistName ? `${playlistName} artwork` : 'Playlist artwork'
      });

      if (sharedPlaylistMeta) {
        const pieces = [];
        pieces.push(`${tracks.length} track${tracks.length === 1 ? '' : 's'}`);
        const sharedAt = sharedPlaylistData.sharedAt || sharedPlaylistData.updatedAt || sharedPlaylistData.createdAt;
        const formatted = formatDateForDisplay(sharedAt);
        if (formatted) pieces.push(`Shared ${formatted}`);
        sharedPlaylistMeta.textContent = pieces.join(' • ');
        sharedPlaylistMeta.hidden = pieces.length === 0;
      }

      if (sharedPlaylistTracks) {
        const previousState = (currentRow && currentRow._playlist === shareKey)
          ? {
              playlistId: currentRow._playlist,
              src: currentRow._src,
              playing: !player.paused && currentSrc === currentRow._src
            }
          : null;
        let matchedPlayback = false;

        sharedPlaylistTracks.innerHTML = '';
        tracks.forEach((track, idx) => {
          const row = createSharedPlaylistRow(track, idx, {
            playlistId: shareKey,
            playlistName,
            playlistArt: fallbackArt,
            shareId: activeSharedShareId
          });
          sharedPlaylistTracks.appendChild(row);

          if (
            row._src &&
            previousState &&
            previousState.src === row._src &&
            previousState.playlistId === shareKey
          ) {
            matchedPlayback = true;
            currentRow = row;
            currentBtn = row._btn || null;
            if (previousState.playing) {
              row.classList.add('playing');
              if (row._btn) {
                row._btn.textContent = row._btn.dataset.pauseLabel || '⏸';
                row._btn.classList.add('btn-accent');
                row._btn.disabled = false;
                if (row._btn.dataset.pauseAria) row._btn.setAttribute('aria-label', row._btn.dataset.pauseAria);
              }
            } else if (row._btn) {
              row._btn.textContent = row._btn.dataset.playLabel || '▶';
              row._btn.classList.remove('btn-accent');
              if (row._btn.dataset.playAria) row._btn.setAttribute('aria-label', row._btn.dataset.playAria);
            }
            setNowPlayingFromRow(row, previousState.playing);
          }
        });

        if (!previousState && nowPlayingInfo.meta && nowPlayingInfo.meta.playlistId === shareKey) {
          const targetSrc = nowPlayingInfo.meta.src || '';
          const candidate = Array.from(sharedPlaylistTracks.children).find((child) => child._src && child._src === targetSrc);
          if (candidate && candidate._btn) {
            currentRow = candidate;
            currentBtn = candidate._btn;
            candidate.classList.toggle('playing', nowPlayingInfo.isPlaying);
          }
        }

        if (previousState && previousState.playlistId === shareKey && !matchedPlayback) {
          if (previousState.playing && !player.paused && currentSrc === previousState.src) {
            player.pause();
          }
          currentSrc = '';
          updateButtonsForStop();
        }
      }

      if (sharedPlaylistEmpty) {
        sharedPlaylistEmpty.hidden = tracks.length > 0;
      }
    }

    async function activateSharedPlaylist(shareId, options = {}){
      const normalized = typeof shareId === 'string' ? shareId.trim() : '';
      if (!normalized) return;
      activeSharedShareId = normalized;
      sharedPlaylistActive = true;
      sharedPlaylistLoading = true;
      sharedPlaylistError = null;
      sharedPlaylistData = null;
      sharedPlaylistShareUrl = '';
      currentMode = 'shared-playlist';
      if (options.updateUrl !== false) {
        ensureShareQueryParam(normalized);
      }
      renderSharedPlaylistView();
      try {
        const res = await fetch(`/api/shared-playlists/${encodeURIComponent(normalized)}`, {
          headers: { 'Accept': 'application/json' }
        });
        const data = await res.json().catch(() => ({}));
        if (res.status === 404) {
          sharedPlaylistError = 'This playlist link is no longer available.';
          return;
        }
        if (!res.ok || !data?.ok) {
          throw new Error(data?.error || 'Unable to load playlist');
        }
        sharedPlaylistData = data.playlist || null;
        sharedPlaylistShareUrl = typeof data.shareUrl === 'string' && data.shareUrl.trim()
          ? data.shareUrl.trim()
          : buildShareUrlFallback(normalized);
      } catch (err) {
        sharedPlaylistError = err?.message || 'Unable to load playlist';
      } finally {
        sharedPlaylistLoading = false;
        renderSharedPlaylistView();
      }
    }

    function clearSharedPlaylistState({ restoreLanding = false } = {}){
      sharedPlaylistActive = false;
      sharedPlaylistLoading = false;
      sharedPlaylistError = null;
      sharedPlaylistData = null;
      sharedPlaylistShareUrl = '';
      activeSharedShareId = '';
      if (restoreLanding) {
        currentMode = 'landing';
      }
      renderSharedPlaylistView();
    }

    /* ================= Modal behavior ================= */
    function closeTrackInfoModal(options = {}) {
      if (!trackInfoOverlay.classList.contains('open')) return;
      trackInfoOverlay.classList.remove('open');
      trackInfoOverlay.hidden = true;
      trackInfoBody.innerHTML = '';
      document.removeEventListener('keydown', handleTrackInfoKeydown, true);
      if (!options.suppressFocus && trackInfoReturnFocus && typeof trackInfoReturnFocus.focus === 'function') {
        trackInfoReturnFocus.focus();
      }
      trackInfoReturnFocus = null;
      trackInfoFocusables = [];
        }

    function collectTrackMetadata(track){
      if (!track) return [];
      const entries = [];
      const pushEntry = (label, value) => {
        if (value === undefined || value === null) return;
        const text = String(value).trim();
        if (text) entries.push({ label, value: text });
      };
      pushEntry('Producer', track.producer);
      pushEntry('Track Artist', track.trackArtist);
      const composerPartsSet = new Set([
        track.composer1,
        track.composer2,
        track.composer3,
        track.composer4
      ].filter(Boolean).map(value => String(value).trim()).filter(Boolean));
      if (!composerPartsSet.size && Array.isArray(track.composers)) {
        track.composers.forEach((value) => {
          const trimmed = String(value || '').trim();
          if (trimmed) composerPartsSet.add(trimmed);
        });
      }
      if (composerPartsSet.size) {
        pushEntry('Composer', Array.from(composerPartsSet).join(', '));
      }
      pushEntry('Language', track.language);
      pushEntry('Genre', track.genre);
      pushEntry('ISRC', track.isrc);
      return entries;
        }

    function openTrackInfoModal(track, trigger) {
      if (!track) return;
      closeTrackInfoModal({ suppressFocus: true });
      trackInfoReturnFocus = trigger || null;

      const entries = collectTrackMetadata(track);

      if (entries.length) {
        const dl = document.createElement('dl');
        entries.forEach(({ label, value }) => {
          const dt = document.createElement('dt'); dt.textContent = label;
          const dd = document.createElement('dd'); dd.textContent = value;
          dl.appendChild(dt); dl.appendChild(dd);
        });
        trackInfoBody.innerHTML = '';
        trackInfoBody.appendChild(dl);
      } else {
        trackInfoBody.innerHTML = '<p class="info-modal-empty">No additional metadata.</p>';
      }

      trackInfoOverlay.hidden = false;
      trackInfoOverlay.classList.add('open');
      trackInfoFocusables = Array.from(trackInfoDialog.querySelectorAll(trackInfoFocusableSelector));
      if (trackInfoFocusables.length === 0) {
        trackInfoDialog.setAttribute('tabindex', '-1');
        trackInfoFocusables = [trackInfoDialog];
      } else {
        trackInfoDialog.removeAttribute('tabindex');
      }
      const focusTarget = trackInfoFocusables[0] || trackInfoDialog;
      requestAnimationFrame(() => focusTarget.focus());
      document.addEventListener('keydown', handleTrackInfoKeydown, true);
        }

    function handleTrackInfoKeydown(e) {
      if (!trackInfoOverlay.classList.contains('open')) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        closeTrackInfoModal();
        return;
      }
      if (e.key === 'Tab' && trackInfoFocusables.length) {
        const first = trackInfoFocusables[0];
        const last = trackInfoFocusables[trackInfoFocusables.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault();
          last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
        }

    function closeTracksModal(){
      closeTrackInfoModal({ suppressFocus: true });
      // Don't stop playback when closing - let music continue playing
      // if (!player.paused) player.pause();
      // updateButtonsForStop();
      // currentSrc = '';
      overlay.classList.remove('open');
      overlay.setAttribute('aria-hidden', 'true');
      modalContent.innerHTML = '';
      modalCover.innerHTML = '';
      const modalAlbumSleeve = document.getElementById('modalAlbumSleeve');
      if (modalAlbumSleeve) {
        modalAlbumSleeve.classList.remove('show');
        modalAlbumSleeve.innerHTML = '';
      }
      document.body.classList.remove('no-scroll');
        }

    async function openTracksModal(album, sourceCard=null){
      // Ensure only one window open: close any existing
      closeTracksModal();
      const albumCard = sourceCard || null;
      if (albumCard) {
        albumCard.dataset.validTracks = '0';
        albumCard.dataset.pendingTracks = '0';
        if (albumCard.dataset.hasAudioCandidates === 'true') {
          albumCard.classList.remove('no-audio');
          if (albumCard.title === 'No playable audio available') albumCard.removeAttribute('title');
        } else {
          albumCard.classList.add('no-audio');
          if (!albumCard.title) albumCard.title = 'No playable audio available';
        }
      }

      // Fetch complete album if we might not have all tracks
      let fullAlbum = album;
      const shouldFetchComplete = currentMode === 'explore' || currentMode === 'landing' || currentMode === 'featured' || currentMode === 'search';

      if (shouldFetchComplete && album.title) {
        try {
          let response;

          // For search mode, use /api/search with album filter to get all tracks
          if (currentMode === 'search') {
            const params = new URLSearchParams();
            params.set('album', album.title);
            if (album.artist) params.set('artist', album.artist);
            params.set('limit', '100'); // Get up to 100 tracks from the album

            response = await fetch(`/api/search?${params}`);
            console.log(`[openTracksModal] Fetching complete album via search: "${album.title}"`);
          } else {
            // For other modes, use /api/album endpoint
            const params = new URLSearchParams();
            if (album.catalogue) params.set('cat', album.catalogue);
            if (album.title) params.set('title', album.title);
            if (album.artist) params.set('artist', album.artist);

            response = await fetch(`/api/album?${params}`);
          }

          if (response.ok) {
            const data = await response.json();
            if (data.items && data.items.length > 0) {
              // For search results, group by album and use tracks from the matching album
              if (currentMode === 'search') {
                const grouped = groupAlbums(data.items);
                const matchingAlbum = grouped.find(g =>
                  g.title.toLowerCase() === album.title.toLowerCase() &&
                  (!album.artist || g.artist.toLowerCase() === album.artist.toLowerCase())
                );
                if (matchingAlbum && matchingAlbum.tracks.length > 0) {
                  fullAlbum = { ...album, tracks: matchingAlbum.tracks };
                  console.log(`[openTracksModal] Fetched ${matchingAlbum.tracks.length} complete tracks for "${album.title}"`);
                }
              } else {
                // For other modes, transform API items to track format
                const transformedTracks = data.items.map(item => {
                  const f = item.fields || {};
                  const mp3Info = pickFieldValue(f, AUDIO_FIELD_CANDIDATES);
                  return {
                    name: f['Track Name'] || f['Tape Files::Track Name'] || '',
                    mp3: mp3Info.value || '',
                    mp3Field: mp3Info.field || '',
                    S3_URL: f['S3_URL'] || f['Tape Files::S3_URL'] || '',
                    trackArtist: f['Track Artist'] || f['Tape Files::Track Artist'] || '',
                    recordId: item.recordId || '',
                    seq: parseTrackSequence(f),
                    hasValidAudio: true
                  };
                });
                fullAlbum = { ...album, tracks: transformedTracks };
                console.log(`[openTracksModal] Fetched ${transformedTracks.length} complete tracks for "${album.title}"`);
              }
            }
          }
        } catch (err) {
          console.warn('[openTracksModal] Failed to fetch complete album:', err);
          // Continue with partial album
        }
      }

      // Fill header
      modalTitle.textContent = fullAlbum.title || '(no album)';
      modalArtist.textContent = fullAlbum.artist || '';
      const modalYear = document.getElementById('modalYear');
      if (modalYear) {
        const yearValue = fullAlbum.year || fullAlbum['Year'] || fullAlbum['Year Recorded'] || fullAlbum['Year_Recorded'] || fullAlbum['Release Year'] || fullAlbum['Release_Year'] || '';
        modalYear.textContent = yearValue;
        if (!yearValue) modalYear.style.display = 'none'; else modalYear.style.display = 'inline-block';
      }
      modalCat.textContent = fullAlbum.catalogue || '';
      if (!fullAlbum.catalogue) modalCat.style.display = 'none'; else modalCat.style.display = 'inline-block';

      // Cover
      const modalAlbumSleeve = document.getElementById('modalAlbumSleeve');
      if (fullAlbum.picture) {
        const wrap = document.createElement('div');
        wrap.className = 'cover-wrap';
        const img = document.createElement('img');
        img.src = `/api/container?u=${encodeURIComponent(fullAlbum.picture)}`;
        img.alt = 'Cover';
        img.loading = 'lazy';
        img.onerror = () => {
          img.src = '/img/placeholder.png';
          img.classList.add('placeholder-image');
        };
        wrap.appendChild(img);
        modalCover.innerHTML = '';
        modalCover.appendChild(wrap);
        modalCover.style.display = 'block';
        // Set large album sleeve
        if (modalAlbumSleeve) {
          const sleeveImg = document.createElement('img');
          sleeveImg.src = `/api/container?u=${encodeURIComponent(fullAlbum.picture)}`;
          sleeveImg.alt = fullAlbum.title || 'Album artwork';
          sleeveImg.loading = 'lazy';
          sleeveImg.onerror = () => {
            sleeveImg.src = '/img/placeholder.png';
          };
          modalAlbumSleeve.innerHTML = '';
          modalAlbumSleeve.appendChild(sleeveImg);
          modalAlbumSleeve.classList.add('show');
        }
      } else {
        // Show placeholder when no album picture
        const wrap = document.createElement('div');
        wrap.className = 'cover-wrap';
        const img = document.createElement('img');
        img.src = '/img/placeholder.png';
        img.alt = 'No cover';
        img.classList.add('placeholder-image');
        wrap.appendChild(img);
        modalCover.innerHTML = '';
        modalCover.appendChild(wrap);
        modalCover.style.display = 'block';
        // Set large album sleeve to placeholder
        if (modalAlbumSleeve) {
          const sleeveImg = document.createElement('img');
          sleeveImg.src = '/img/placeholder.png';
          sleeveImg.alt = 'No cover';
          modalAlbumSleeve.innerHTML = '';
          modalAlbumSleeve.appendChild(sleeveImg);
          modalAlbumSleeve.classList.add('show');
        }
      }

      // Build track list
      const ul = document.createElement('ul');
      ul.className = 'tracks';

      const validTracks = (fullAlbum.tracks || []).filter(t => t.hasValidAudio !== false);
      validTracks.forEach((t, idx) => {
        const li = document.createElement('li');
        li.className = 'track';

        const top = document.createElement('div');
        top.className = 'track-top';

        const titleWrap = document.createElement('div');
        titleWrap.className = 'track-title';
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = t.name || 'Untitled track';
        titleWrap.appendChild(name);
        if (t.trackArtist) {
          const artistLine = document.createElement('div');
          artistLine.className = 'artist';
          artistLine.textContent = t.trackArtist;
          titleWrap.appendChild(artistLine);
        }

        top.appendChild(titleWrap);

        const controls = document.createElement('div');
        controls.className = 'controls';

        const btnPlay = document.createElement('button');
        btnPlay.className = 'btn small';
        const candidateSrc = t.S3_URL || t.resolvedSrc || t.mp3 || t.rawUrl || '';
        const playableCandidate = resolvePlayableSrc(candidateSrc);
        const canPlay = canValidateAudioSrc(playableCandidate);
        const playableSrc = canPlay ? playableCandidate : '';
        li._src = playableSrc;
        li._btn = btnPlay;
        li._card = albumCard;
        li._playlist = null;
        li._audioField = t.mp3Field || '';
        const baseMetaAlbum = { ...t };
        baseMetaAlbum.trackName = t.name || 'Untitled track';
        baseMetaAlbum.trackArtist = t.trackArtist || fullAlbum.artist || '';
        baseMetaAlbum.albumTitle = fullAlbum.title || '';
        baseMetaAlbum.albumArtist = fullAlbum.artist || '';
        baseMetaAlbum.playlistId = null;
        baseMetaAlbum.playlistName = '';
        baseMetaAlbum.picture = fullAlbum.picture || '';
        baseMetaAlbum.source = 'album';
        baseMetaAlbum.catalogue = fullAlbum.catalogue || '';
        baseMetaAlbum.audioField = t.mp3Field || '';
        baseMetaAlbum.trackRecordId = t.recordId || '';
        baseMetaAlbum.pictureField = fullAlbum.pictureField || t.pictureField || '';
        baseMetaAlbum.src = playableSrc;
        baseMetaAlbum.rawUrl = t.rawUrl || t.mp3 || '';
        baseMetaAlbum.S3_URL = t.S3_URL || '';
        li._meta = baseMetaAlbum;
        li._validated = false;
        li._valid = null;
        li._validating = false;
        if (canPlay) {
          btnPlay.textContent = '▶ Play';
          btnPlay.disabled = false;
          btnPlay.classList.remove('btn-error');
          btnPlay.removeAttribute('title');
        } else if (t.S3_URL || t.mp3) {
          btnPlay.textContent = 'Invalid audio';
          btnPlay.disabled = true;
          btnPlay.classList.add('btn-error');
          btnPlay.title = 'Invalid audio link';
        } else {
          btnPlay.textContent = 'No audio';
          btnPlay.disabled = true;
          btnPlay.classList.add('btn-error');
          btnPlay.title = 'Audio missing';
        }
        btnPlay.addEventListener('click', async () => {
          if (!li._src) return;
          if (li._valid === false) {
            btnPlay.textContent = 'Unavailable';
            btnPlay.disabled = true;
            btnPlay.classList.add('btn-error');
            return;
          }

          handlePlay(btnPlay, li, li._src);

          if (li._valid === true || li._validating) return;

          li._validating = true;
          validateAudio(li, li._src, { optimistic: true }).finally(() => {
            li._validating = false;
          });
        });
        controls.appendChild(btnPlay);

        const btnAdd = document.createElement('button');
        btnAdd.type = 'button';
        btnAdd.className = 'btn small';
        btnAdd.textContent = 'Add to playlist';
        btnAdd.addEventListener('click', () => handleAddToPlaylist(album, t, playableSrc));
        controls.appendChild(btnAdd);

        const hasInfo = Boolean(
          t.producer ||
          t.trackArtist ||
          t.composer1 ||
          t.composer2 ||
          t.composer3 ||
          t.composer4 ||
          (Array.isArray(t.composers) && t.composers.some(value => String(value || '').trim())) ||
          t.language ||
          t.genre ||
          t.isrc
        );
        if (hasInfo) {
          const infoBtn = document.createElement('button');
          infoBtn.type = 'button';
          infoBtn.className = 'btn small info-more';
          infoBtn.setAttribute('aria-label', 'More info');
          infoBtn.innerHTML = '<span aria-hidden="true">⋮</span>';
          infoBtn.addEventListener('click', () => openTrackInfoModal(t, infoBtn));
          controls.appendChild(infoBtn);
        }

        top.appendChild(controls);

        li.appendChild(top);

        // Progress UI (non-destructive)
        const progWrap = document.createElement('div');
        progWrap.className = 'progress';
        const seek = document.createElement('input');
        seek.type = 'range'; seek.className = 'seek'; seek.min = 0; seek.max = 100; seek.value = 0;
        const time = document.createElement('div');
        time.className = 'time'; time.textContent = '0:00 / 0:00';
        progWrap.appendChild(seek); progWrap.appendChild(time);
        li.appendChild(progWrap);
        li._seek = seek; li._time = time; li._seeking = false;

        // Preload audio duration without playing
        if (playableSrc) {
          const preloadAudio = new Audio();
          preloadAudio.preload = 'metadata';
          preloadAudio.src = playableSrc;
          preloadAudio.addEventListener('loadedmetadata', () => {
            const dur = preloadAudio.duration;
            if (dur && isFinite(dur)) {
              const mins = Math.floor(dur / 60);
              const secs = Math.floor(dur % 60).toString().padStart(2, '0');
              time.textContent = `0:00 / ${mins}:${secs}`;
              li._duration = dur;
            }
            preloadAudio.src = ''; // Release resource
          }, { once: true });
          preloadAudio.addEventListener('error', () => {
            preloadAudio.src = ''; // Release resource on error
          }, { once: true });
        }
        // Seek while dragging (works while playing or paused)
        seek.addEventListener('input', () => {
          if (currentRow === li && player.duration && isFinite(player.duration)) {
            const pct = Number(seek.value) / 100;
            player.currentTime = pct * player.duration;
          }
        });
        seek.addEventListener('change', () => {
          if (currentRow === li && player.duration && isFinite(player.duration)) {
            const pct = Number(seek.value) / 100;
            player.currentTime = pct * player.duration;
          }
          li._seeking = false;
        });
        seek.addEventListener('pointerdown', () => { if (currentRow === li) li._seeking = true; });
        seek.addEventListener('pointerup',   () => { if (currentRow === li) li._seeking = false; });

        ul.appendChild(li);
      });

      modalContent.innerHTML = '';
      if (Array.isArray(fullAlbum?.tracks) && fullAlbum.tracks.length) {
        const albumActions = document.createElement('div');
        albumActions.className = 'album-actions';
        const btnAddAlbum = document.createElement('button');
        btnAddAlbum.type = 'button';
        btnAddAlbum.className = 'btn small btn-accent';
        btnAddAlbum.textContent = `Add album to playlist (${fullAlbum.tracks.length} tracks)`;
        btnAddAlbum.addEventListener('click', async () => {
          const previousLabel = btnAddAlbum.textContent;
          btnAddAlbum.disabled = true;
          btnAddAlbum.textContent = 'Adding…';
          try {
            await handleAddAlbumToPlaylist(fullAlbum);
          } finally {
            btnAddAlbum.disabled = false;
            btnAddAlbum.textContent = previousLabel;
          }
        });
        albumActions.appendChild(btnAddAlbum);
        modalContent.appendChild(albumActions);
      }
      modalContent.appendChild(ul);

      // Open
      overlay.classList.add('open');
      overlay.setAttribute('aria-hidden', 'false');
      document.body.classList.add('no-scroll');
        }

    modalClose.addEventListener('click', closeTracksModal);
    overlay.addEventListener('click', (e) => {
      // Close if clicking backdrop (but not clicks inside the dialog)
      if (e.target === overlay) closeTracksModal();
        });
    document.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      if (overlay.classList.contains('open')) {
        closeTracksModal();
        return;
      }
      if (authOverlay && !authOverlay.hidden) {
        closeAuth();
      }
        });

    trackInfoOverlay.addEventListener('click', (e) => {
      if (e.target === trackInfoOverlay) closeTrackInfoModal();
        });
    trackInfoClose.addEventListener('click', () => closeTrackInfoModal());

    if (authOverlay) {
      authOverlay.addEventListener('click', (event) => {
        if (event.target === authOverlay) closeAuth();
      });
    }
    if (authClose) authClose.addEventListener('click', () => closeAuth());
    if (shareModalClose) shareModalClose.addEventListener('click', () => closeShareModal());
    if (shareModal) {
      shareModal.addEventListener('click', (e) => {
        if (e.target === shareModal) closeShareModal();
      });
    }

    // Export modal event listeners
    if (exportModalClose) exportModalClose.addEventListener('click', () => closeExportModal());
    if (exportModal) {
      exportModal.addEventListener('click', (e) => {
        if (e.target === exportModal) closeExportModal();
      });
    }
    if (exportCopyBtn) {
      exportCopyBtn.addEventListener('click', async () => {
        const code = exportCodeInput?.value || '';
        if (!code) return;
        const copied = await copyTextToClipboard(code);
        if (copied) {
          window.alert('Export code copied to clipboard');
        } else {
          window.alert('Failed to copy code');
        }
      });
    }
    if (exportDownloadBtn) {
      exportDownloadBtn.addEventListener('click', () => {
        const jsonStr = exportCodeInput?.dataset?.exportJson || '';
        if (!jsonStr) return;
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const playlist = getActivePlaylist();
        const filename = playlist?.name ? `${playlist.name.replace(/[^a-zA-Z0-9_-]/g, '_')}.json` : 'playlist.json';
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    // Import modal event listeners
    if (importModalClose) importModalClose.addEventListener('click', () => closeImportModal());
    if (importModal) {
      importModal.addEventListener('click', (e) => {
        if (e.target === importModal) closeImportModal();
      });
    }
    if (importSubmitBtn) {
      importSubmitBtn.addEventListener('click', () => {
        if (importSubmitBtn.disabled) return;
        importPlaylistFromCode();
      });
    }

    if (authForm) authForm.addEventListener('submit', submitAuthForm);
    if (authSwitch) {
      authSwitch.addEventListener('click', () => {
        const nextMode = authMode === 'login' ? 'register' : 'login';
        setAuthMode(nextMode);
        queueTask(() => authEmail?.focus());
      });
    }
    if (loginTrigger) {
      loginTrigger.addEventListener('click', () => openAuth('login', loginTrigger));
    }
    if (signupTrigger) {
      signupTrigger.addEventListener('click', () => openAuth('register', signupTrigger));
    }
    if (logoutButton) {
      logoutButton.addEventListener('click', performLogout);
    }
    if (playlistCreateForm) {
      playlistCreateForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        if (!currentUser) {
          openAuth('login', playlistCreateForm.querySelector('button'));
          return;
        }
        const name = (playlistNameInput?.value || '').trim();
        if (!name) return;
        try {
          const playlist = await createPlaylistOnServer(name);
          if (playlistNameInput) playlistNameInput.value = '';
          if (playlist?.id) setActivePlaylist(playlist.id);
        } catch (err) {
          window.alert(err?.message || 'Unable to create playlist');
        }
      });
    }
    if (deletePlaylistButton) {
      deletePlaylistButton.addEventListener('click', () => {
        if (deletePlaylistButton.disabled) return;
        deleteActivePlaylist();
      });
    }
    if (sharePlaylistButton) {
      sharePlaylistButton.addEventListener('click', () => {
        if (sharePlaylistButton.disabled) return;
        copyActivePlaylistShareLink();
      });
    }
    if (exportPlaylistButton) {
      exportPlaylistButton.addEventListener('click', () => {
        if (exportPlaylistButton.disabled) return;
        exportActivePlaylist();
      });
    }
    if (importPlaylistButton) {
      importPlaylistButton.addEventListener('click', () => {
        showImportModal();
      });
    }
    if (shareLinkOutput) {
      shareLinkOutput.addEventListener('click', async () => {
        const raw = shareLinkOutput.dataset.url || '';
        const url = raw.trim();
        if (!url) return;
        const copied = await copyTextToClipboard(url);
        if (copied) {
          window.alert('Share link copied to your clipboard.');
        } else {
          window.alert(`Share link:\n${url}`);
        }
      });
    }
    if (sharedPlaylistBackButton) {
      sharedPlaylistBackButton.addEventListener('click', () => {
        // If user is not logged in, show subscribe modal first
        if (!currentUser) {
          openAuth('signup');

          // Wait for auth modal to close, then return to homepage
          const observer = new MutationObserver(() => {
            if (authOverlay && authOverlay.hidden) {
              observer.disconnect();
              clearShareQueryParam();
              clearSharedPlaylistState({ restoreLanding: false });
              loadFeaturedAlbums({ refresh: true });
            }
          });

          if (authOverlay) {
            observer.observe(authOverlay, { attributes: true, attributeFilter: ['hidden'] });
          }
        } else {
          // User is logged in, just return to homepage
          clearShareQueryParam();
          clearSharedPlaylistState({ restoreLanding: false });
          loadFeaturedAlbums({ refresh: true });
        }
      });
    }
    if (sharedPlaylistCopyButton) {
      sharedPlaylistCopyButton.addEventListener('click', () => {
        if (sharedPlaylistCopyButton.disabled) return;
        const link = sharedPlaylistShareUrl || buildShareUrlFallback(activeSharedShareId);
        if (!link) {
          window.alert('No share link available');
          return;
        }
        showShareModal(link);
      });
    }
    if (togglePlaylistTracksButton) {
      togglePlaylistTracksButton.addEventListener('click', () => {
        playlistTracksCollapsed = !playlistTracksCollapsed;
        if (playlistTracksCollapsed && playlistTracksSection) playlistTracksSection.classList.remove('only-current');
        renderPlaylistTracks();
      });
    }
    if (nowPlayingCollapseButton) {
      nowPlayingCollapseButton.addEventListener('click', () => {
        nowPlayingCollapsed = !nowPlayingCollapsed;
        updateNowPlayingUI();
      });
    }
    if (nowPlayingAddButton) {
      nowPlayingAddButton.addEventListener('click', async () => {
        const meta = nowPlayingInfo.meta;
        if (!meta) return;
        const payload = prepareNowPlayingAdd(meta);
        if (!payload) {
          window.alert('Unable to add this track to a playlist right now.');
          return;
        }
        nowPlayingAddBusy = true;
        updateNowPlayingUI();
        try {
          await handleAddToPlaylist(payload.album, payload.track, payload.playableSrc);
        } finally {
          nowPlayingAddBusy = false;
          updateNowPlayingUI();
        }
      });
    }
    if (nowPlayingToggleButton) {
      nowPlayingToggleButton.addEventListener('click', () => {
        if (!nowPlayingInfo.meta) {
          // Fallback: direct player control when track was started outside handlePlay
          if (player.src && player.src !== window.location.href) {
            if (player.paused) {
              player.play().catch(err => console.warn('[Toggle] Playback failed:', err));
            } else {
              player.pause();
            }
          }
          return;
        }
        const meta = nowPlayingInfo.meta;
        if (player.paused) {
          if (!currentRow && meta.playlistId && meta.playlistTrackId && playlistTracksList) {
            const candidate = playlistTracksList.querySelector(`[data-track-id="${meta.playlistTrackId}"]`);
            if (candidate) {
              currentRow = candidate;
              currentBtn = candidate._btn || null;
            }
          }
          if (meta.src && player.src !== meta.src) {
            player.src = meta.src;
            currentSrc = meta.src;
          }
          player.play()
            .then(() => {
              if (currentRow) {
                setNowPlayingFromRow(currentRow, true);
                if (currentRow._btn) {
                  currentBtn = currentRow._btn;
                  currentBtn.disabled = false;
                  const pauseLabel = currentBtn.dataset?.pauseLabel || 'Pause';
                  currentBtn.textContent = pauseLabel;
                  if (currentBtn.dataset?.pauseAria) currentBtn.setAttribute('aria-label', currentBtn.dataset.pauseAria);
                  currentBtn.classList.add('btn-accent');
                }
                currentRow.classList.remove('loading');
                currentRow.classList.add('playing');
                updateProgressUI();
              } else {
                setNowPlayingFromRow({ _meta: meta, _src: meta.src }, true);
              }
            })
            .catch((err) => {
              console.warn('Resume playback failed:', err);
              window.alert('Unable to resume playback.');
            });
        } else {
          console.log('[Pause] Button clicked, pausing player');
          player.pause();
          nowPlayingInfo.isPlaying = false;
          console.log('[Pause] Set isPlaying to false, calling updateNowPlayingUI');
          updateNowPlayingUI();
          console.log('[Pause] updateNowPlayingUI called, button should show Play');
        }
      });
    }

    setAuthMode('login');
    updateAuthUI();
    refreshCurrentUser();
    loadPublicPlaylistSummaries();

    // Listen for access token ready event (fired by token overlay after validation)
    window.addEventListener('mass:access-ready', (e) => {
      const email = e.detail?.email || localStorage.getItem('mass_token_email') || null;
      if (email) {
        currentUser = { email };
        updateAuthUI();
        loadUserPlaylists().catch(err => console.warn('Failed to load playlists after token ready:', err));
        loadPublicPlaylistSummaries().catch(err => console.warn('Failed to load featured playlists:', err));
      }
    });

    /* ================= Rendering albums (cards) ================= */
    function renderAlbumPage(){
      if (shufflePlayBtn) {
        shufflePlayBtn.hidden = true;
        shufflePlayBtn.disabled = false;
        shufflePlayBtn.setAttribute('aria-pressed', 'false');
      }
      if (randomStopBtn) {
        randomStopBtn.hidden = true;
        randomStopBtn.disabled = true;
      }
      if (randomSkipBtn) {
        randomSkipBtn.hidden = true;
        randomSkipBtn.disabled = true;
      }
      if (randomSongsAutoplay.active && currentMode !== 'songs') {
        stopRandomSongsAutoplay();
      }
      // Skip album rendering when in songs mode - songs have their own renderer
      if (currentMode === 'songs') {
        console.log('[renderAlbumPage] Skipping - in songs mode');
        return;
      }

      // Hide loading indicator when rendering
      if (loadingIndicator) loadingIndicator.hidden = true;
      if (albumsEl) albumsEl.style.display = '';

      // Set data-mode attribute for CSS styling
      if (albumsEl) albumsEl.setAttribute('data-mode', currentMode);

      albumsEl.innerHTML = '';

      // In explore mode, trust backend filtering (already filtered for valid audio + GMVi artwork)
      // In search mode, do frontend audio validation
      let displayAlbums;
      let pendingAlbums = 0;
      let pendingQueue = []; // Declare at function scope so it's accessible in activePublicPlaylist check below

      if (currentMode === 'explore' || currentMode === 'landing' || currentMode === 'featured') {
        // Skip frontend validation for explore mode - backend already filtered
        displayAlbums = albumGroups.filter(a => a);
        console.log(`[renderAlbumPage] EXPLORE mode: skipping frontend validation, showing all ${displayAlbums.length} backend-filtered albums`);
      } else {
        // Search mode: do frontend audio validation
        const validAlbums = [];
        pendingQueue = []; // Reset the queue for search mode
        const invalidAlbums = [];

        for (const album of albumGroups) {
          if (!album) continue;
          const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
          album.key = key;
          const state = albumAudioState.get(key);
          if (!state) {
            ensureAlbumAudioValidation(album);
            pendingAlbums += 1;
            pendingQueue.push(album);
            continue;
          }
          if (state.status === 'pending') {
            album._pendingValidation = true;
            pendingAlbums += 1;
            pendingQueue.push(album);
            continue;
          }
          if (state.status === 'valid') {
            if (isFresh(state)) {
              album._pendingValidation = false;
              validAlbums.push(album);
            } else {
              albumAudioState.delete(key);
              ensureAlbumAudioValidation(album);
              pendingAlbums += 1;
              pendingQueue.push(album);
            }
            continue;
          }
          if (state.status === 'invalid') {
            if (!isFresh(state)) {
              albumAudioState.delete(key);
              ensureAlbumAudioValidation(album);
              pendingAlbums += 1;
              pendingQueue.push(album);
            } else {
              // Invalid but fresh - add to invalidAlbums if toggle is on
              album._noAudio = true;
              invalidAlbums.push(album);
            }
          }
        }

        pendingAlbums = pendingQueue.length;

        displayAlbums = validAlbums.concat(pendingQueue);
        if (showAlbumsWithoutAudio) {
          displayAlbums = displayAlbums.concat(invalidAlbums);
        }
      }
      if (activePublicPlaylist) {
        const activeKey = activePublicPlaylist.toLowerCase();
        const matchesActivePlaylist = (album) => Array.isArray(album?.publicPlaylists)
          && album.publicPlaylists.some((name) => String(name || '').toLowerCase() === activeKey);
        displayAlbums = displayAlbums.filter(matchesActivePlaylist);
        pendingAlbums = pendingQueue.filter(matchesActivePlaylist).length;
      }

      const totalAlbums = displayAlbums.length;
      const availableAlbums = activePublicPlaylist ? totalAlbums : (albumGroups.length || totalAlbums);

      if (availableAlbums > 0) {
        errorEl.hidden = true;
      } else if (activePublicPlaylist) {
        errorEl.hidden = true;
      } else if (pendingAlbums === 0 && albumGroups.length > 0) {
        if (!showAlbumsWithoutAudio && invalidAlbums.length > 0) {
          errorEl.hidden = false;
          errorEl.textContent = `Found ${invalidAlbums.length} album${invalidAlbums.length !== 1 ? 's' : ''} but audio is unavailable. Enable "Show all" to view.`;
        } else {
          errorEl.hidden = false;
          errorEl.textContent = 'No albums with complete audio and artwork are available right now.';
        }
      } else if (pendingAlbums > 0) {
        errorEl.hidden = true;
      }

      if (totalAlbums === 0) {
        albumsEl.classList.remove('single-album');
      }

      if (totalAlbums === 0 && pendingAlbums > 0) {
        countEl.textContent = 'Validating audio…';
      } else if (activePublicPlaylist) {
        countEl.textContent = '';
      } else {
        countEl.textContent = availableAlbums ? `Albums: ${availableAlbums}` : (lastQ ? 'No albums' : '');
      }

      const totalPool = Math.max(availableAlbums, displayAlbums.length);
      const maxPage = Math.max(1, Math.ceil(Math.max(totalPool, 1) / ALBUMS_PER_PAGE));
      albumPage = Math.min(albumPage, maxPage - 1);

      // Show shuffle button for explore/landing/songs mode, pagination for search mode
      const shouldShowShuffle = currentMode === 'explore' || currentMode === 'landing' || currentMode === 'songs' || currentMode === 'featured';
      console.log(`[renderAlbumPage] mode=${currentMode}, shouldShowShuffle=${shouldShowShuffle}, shuffleBtn=${!!shuffleBtn}`);
      if (shouldShowShuffle) {
        pagerEl.hidden = true;
        if (shuffleBtn) {
          console.log('[renderAlbumPage] Setting shuffleBtn.hidden = false (shouldShowShuffle=true)');
          shuffleBtn.hidden = false;
        }
      } else {
        pagerEl.hidden = totalPool <= ALBUMS_PER_PAGE;
        if (shuffleBtn) {
          console.log('[renderAlbumPage] Setting shuffleBtn.hidden = true (shouldShowShuffle=false)');
          shuffleBtn.hidden = true;
        }
        pageInfo.textContent = `Page ${albumPage + 1} / ${maxPage}`;
        prevEl.disabled = albumPage <= 0;
        nextEl.disabled = albumPage >= maxPage - 1 && rawItems.length >= rawTotalFound;
      }

      // Debug pagination
      if (totalPool > ALBUMS_PER_PAGE && !shouldShowShuffle) {
        console.log(`[PAGINATION] Showing pager: ${totalPool} albums (${maxPage} pages)`);
      }

      if (totalAlbums === 0 && pendingAlbums > 0) {
        const wait = document.createElement('div');
        wait.className = 'muted';
        wait.textContent = 'Validating audio availability…';
        albumsEl.appendChild(wait);
        return;
      }

      if (totalAlbums === 0) {
        // Don't show error message for public playlists
        return;
      }

      let pageAlbums;

      // In explore/genre mode, show one page of 8 albums based on current page
      if (currentMode === 'explore' || currentMode === 'landing' || currentMode === 'featured') {
        const start = exploreCurrentPage * ALBUMS_PER_PAGE;
        const end = Math.min(start + ALBUMS_PER_PAGE, totalAlbums);
        pageAlbums = displayAlbums.slice(start, end);
        console.log(`[renderAlbumPage] EXPLORE mode: page=${exploreCurrentPage}, totalAlbums=${totalAlbums}, start=${start}, end=${end}, showing ${pageAlbums.length} albums`);

        // If we have no albums on this page, go back to the last page with albums
        if (pageAlbums.length === 0 && exploreCurrentPage > 0 && totalAlbums > 0) {
          exploreCurrentPage = Math.max(0, Math.floor((totalAlbums - 1) / ALBUMS_PER_PAGE));
          const newStart = exploreCurrentPage * ALBUMS_PER_PAGE;
          const newEnd = Math.min(newStart + ALBUMS_PER_PAGE, totalAlbums);
          pageAlbums = displayAlbums.slice(newStart, newEnd);
          console.log(`[renderAlbumPage] Empty page detected, adjusted to page=${exploreCurrentPage}, showing ${pageAlbums.length} albums`);
        }

        if (pageAlbums.length > 0) {
          console.log(`[renderAlbumPage] Albums:`, pageAlbums.map(a => a?.title + ' (' + a?.catalogue + ')'));
        }
      } else if (currentMode === 'genre') {
        const start = genreCurrentPage * ALBUMS_PER_PAGE;
        const end = Math.min(start + ALBUMS_PER_PAGE, totalAlbums);
        pageAlbums = displayAlbums.slice(start, end);
        console.log(`[renderAlbumPage] GENRE mode: page=${genreCurrentPage}, totalAlbums=${totalAlbums}, start=${start}, end=${end}, showing ${pageAlbums.length} albums`);

        // If we have no albums on this page, go back to the last page with albums
        if (pageAlbums.length === 0 && genreCurrentPage > 0 && totalAlbums > 0) {
          genreCurrentPage = Math.max(0, Math.floor((totalAlbums - 1) / ALBUMS_PER_PAGE));
          const newStart = genreCurrentPage * ALBUMS_PER_PAGE;
          const newEnd = Math.min(newStart + ALBUMS_PER_PAGE, totalAlbums);
          pageAlbums = displayAlbums.slice(newStart, newEnd);
          console.log(`[renderAlbumPage] Empty page detected, adjusted to page=${genreCurrentPage}, showing ${pageAlbums.length} albums`);
        }

        if (pageAlbums.length > 0) {
          console.log(`[renderAlbumPage] Albums:`, pageAlbums.map(a => a?.title + ' (' + a?.catalogue + ')'));
        }
      } else {
        // In search mode, use traditional pagination
        const start = albumPage * ALBUMS_PER_PAGE;
        const end = Math.min(start + ALBUMS_PER_PAGE, totalAlbums);
        pageAlbums = displayAlbums.slice(start, end);

        // Pad to 8 slots for consistent layout in search mode
        if (pageAlbums.length < ALBUMS_PER_PAGE) {
          pageAlbums = pageAlbums.concat(Array(ALBUMS_PER_PAGE - pageAlbums.length).fill(null));
        }
      }

      if (currentMode !== 'search' && pageAlbums.filter(a => a).length === 1) {
        albumsEl.classList.add('single-album');
      } else {
        albumsEl.classList.remove('single-album');
      }

      pageAlbums.forEach(album => {
        const card = document.createElement('div');

        // Handle empty slots
        if (!album) {
          card.className = 'card';
          card.style.visibility = 'hidden';
          albumsEl.appendChild(card);
          return;
        }

        const key = album.key || makeAlbumKey(album.catalogue, album.title, album.artist);
        album.key = key;
        card.className = 'card';
        card.dataset.albumKey = key;
        const albumYear = album.year || album['Year'] || album['Year Recorded'] || album['Year_Recorded'] || album['Release Year'] || album['Release_Year'] || '';
        if (albumYear) card.dataset.year = albumYear;
        album._card = card;
        const candidateTracks = Array.isArray(album.tracks) ? album.tracks.filter(track => hasValidMp3(track.S3_URL || track.mp3) && track.hasValidAudio) : [];
        const hasPlayable = album && album.hasPlayable;
        const hasCandidates = hasPlayable !== undefined ? hasPlayable : candidateTracks.length > 0;
        card.dataset.hasAudioCandidates = hasCandidates ? 'true' : 'false';
        card.dataset.validTracks = hasPlayable ? '1' : '0';
        card.dataset.pendingTracks = album._pendingValidation ? '1' : '0';
        if (hasCandidates) {
          card.classList.remove('no-audio');
          card.removeAttribute('title');
        } else {
          card.classList.add('no-audio');
          card.title = 'No playable audio available';
        }

        if (album._pendingValidation) {
          card.classList.add('pending-audio');
          if (!card.title) card.title = 'Validating audio availability…';
        }

        if (totalAlbums === 1 && prevSearch) {
          const backWrap = document.createElement('div');
          backWrap.className = 'back-row';
          const backBtn = document.createElement('button');
          backBtn.type = 'button';
          backBtn.className = 'btn small';
          backBtn.textContent = prevSearch.type === 'explore' ? 'Back to explore results' : 'Back to search results';
          backBtn.addEventListener('click', () => restorePreviousSearch());
          backWrap.appendChild(backBtn);
          card.appendChild(backWrap);
        }



        // Always show album cover (or placeholder)
        const proxied = album.picture ? `/api/container?u=${encodeURIComponent(album.picture)}` : '/img/placeholder.png';
        const wrap = document.createElement('div');
        wrap.className = 'cover-wrap';
        const img = document.createElement('img');
        img.src = proxied;
        img.alt = 'Cover';
        img.loading = 'lazy';
        if (!album.picture) {
          img.classList.add('placeholder-image');
        }
        img.onerror = () => {
          // Show bold placeholder if image fails to load
          img.src = '/img/placeholder.png';
          img.classList.add('placeholder-image');
        };
        wrap.appendChild(img);
        wrap.tabIndex = 0;
        wrap.setAttribute('role','button');
        try { wrap.setAttribute('aria-label', `Open tracks for ${album.title}`); } catch {}
        const triggerSearch = () => {
          // In search mode, always open modal directly with grouped tracks
          // Don't trigger a new search
          if (currentMode === 'search') {
            openTracksModal(album, card);
          } else if (totalAlbums > 1) {
            const term = album.title || '';
            if (searchEl) searchEl.value = term;
            run(term);
          } else {
            openTracksModal(album, card);
          }
        };
        wrap.addEventListener('click', triggerSearch);
        wrap.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ' ) {
            e.preventDefault();
            triggerSearch();
          }
        });
        card.appendChild(wrap);

        const heading = document.createElement('div');
        heading.className = 'heading';

        // Album title
        const h3 = document.createElement('h3');
        h3.textContent = album.title;
        heading.appendChild(h3);

        // Artist name (below title)
        if (album.artist) {
          const artistDiv = document.createElement('div');
          artistDiv.className = 'card-artist';
          artistDiv.textContent = album.artist;
          heading.appendChild(artistDiv);
        }

        // Genre
        if (album.genre) {
          const genreEl = document.createElement('div');
          genreEl.className = 'card-genre';
          genreEl.textContent = album.genre;
          heading.appendChild(genreEl);
        }

        // Add "No Audio" badge for albums shown via toggle
        if (album._noAudio) {
          const noAudioBadge = document.createElement('span');
          noAudioBadge.className = 'badge badge-warning';
          noAudioBadge.textContent = 'No Audio';
          noAudioBadge.title = 'This album does not have playable audio files';
          heading.appendChild(noAudioBadge);
        }

        card.appendChild(heading);

        const toggle = document.createElement('button');
        toggle.className = 'card-expand-btn';
        toggle.textContent = '▼';
        toggle.title = `${album.tracks.length} tracks`;
        toggle.addEventListener('click', () => openTracksModal(album, card));
        wrap.appendChild(toggle);

        albumsEl.appendChild(card);
        updateAlbumCardState(album);
      });

      if (shouldScrollAlbums && currentMode === 'search') {
        if (albumsEl) {
          const targetEl = albumsEl.firstElementChild || albumsEl;
          if (targetEl && typeof targetEl.scrollIntoView === 'function') {
            shouldScrollAlbums = false;
            try {
              targetEl.scrollIntoView({ block: 'start', behavior: 'smooth' });
            } catch {
              targetEl.scrollIntoView();
            }
          } else if (typeof window !== 'undefined') {
            shouldScrollAlbums = false;
            try {
              window.scrollTo({ top: 0, behavior: 'smooth' });
            } catch {
              window.scrollTo(0, 0);
            }
          }
        } else {
          shouldScrollAlbums = false;
        }
      }

      // Removed performance logging overhead
    }

    function updateProgressUI(){
      if (!currentRow) return;
      const seek = currentRow._seek, time = currentRow._time;
      if (!seek || !time) return;
      const dur = player.duration, cur = player.currentTime;
      const pct = (dur && isFinite(dur)) ? Math.min(100, Math.max(0, (cur/dur)*100)) : 0;
      if (!(currentRow && currentRow._seeking)) { seek.value = String(pct); seek.style.setProperty('--fill', pct + '%'); }
      if (nowPlayingProgressFill) {
        nowPlayingProgressFill.style.width = pct + '%';
      }
      time.textContent = fmtTime(cur) + ' / ' + fmtTime(dur);
        }

    function updateCurrentCardToShowNext(row){
      // Only update in random play mode
      if (!randomSongsAutoplay.active || currentMode !== 'songs' || !row) return;

      // Find the next track
      const nextRow = findNextPlayableRow(row);
      if (!nextRow || !nextRow._meta) return;

      // Get the track info elements from the current row
      const nameEl = row.querySelector('.name');
      const artistEl = row.querySelector('.artist');
      const btn = row._btn;

      if (nameEl && nextRow._meta.trackName) {
        nameEl.textContent = nextRow._meta.trackName;
        nameEl.title = nextRow._meta.trackName;
      }
      if (artistEl && nextRow._meta.trackArtist) {
        artistEl.textContent = nextRow._meta.trackArtist;
      }
      if (btn) {
        btn.textContent = 'Next';
        btn.dataset.playLabel = 'Next';
      }
    }

    function handlePlay(btn, row, src){
      if (!src) return;
      if (currentSrc === src && !player.paused) {
        player.pause();
        return;
      }

      const resumingSameTrack = currentSrc === src && player.paused;
      if (row) {
        row._lastAttemptedSrc = src;
        if (row._src !== src) row._src = src;
      }
      if (currentSrc !== src) {
        player.src = src;
      }
      currentSrc = src;

      if (!resumingSameTrack) {
        updateButtonsForStop();
      }
      setNowPlayingFromRow(row, false);

      currentBtn = btn;
      currentRow = row;
      if (currentRow) {
        currentRow.classList.remove('playing');
        currentRow.classList.add('loading');
      }
      btn.disabled = true;
      btn.textContent = btn.dataset.loadingLabel || 'Loading…';
      if (btn.dataset.playAria) btn.setAttribute('aria-label', 'Loading track…');
      btn.classList.add('btn-accent');
      btn.classList.remove('btn-error');

      player.play()
        .then(() => {
          if (!resumingSameTrack) {
            updateButtonsForStop();
          }
          currentBtn = btn;
          currentRow = row;
          if (currentRow) {
            currentRow.classList.remove('loading');
            currentRow.classList.add('playing');
          }
          btn.disabled = false;
          btn.textContent = btn.dataset.pauseLabel || '⏸ Pause';
          if (btn.dataset.pauseAria) btn.setAttribute('aria-label', btn.dataset.pauseAria);
          btn.classList.add('btn-accent');
          updateProgressUI();
          scheduleNextTrackPreload(currentRow);
          setNowPlayingFromRow(row, true);
          updateCurrentCardToShowNext(row);
        })
        .catch((err) => {
          console.warn('Playback error:', err);
          try {
            player.removeAttribute('src');
            player.load();
          } catch {}
          currentSrc = '';
          updateButtonsForStop();
          markNowPlayingInactive();
          if (randomSongsAutoplay.active && currentMode === 'songs') {
            advanceRandomSongsAutoplayFrom(row);
          }
        });
    }
    function updateButtonsForStop(hideCard = false){
      if (currentRow) {
        currentRow.classList.remove('playing');
        currentRow.classList.remove('loading');
      }
      if (currentBtn) {
        currentBtn.disabled = false;
        const playLabel = currentBtn.dataset?.playLabel || 'Play';
        currentBtn.textContent = playLabel;
        if (currentBtn.dataset?.playAria) currentBtn.setAttribute('aria-label', currentBtn.dataset.playAria);
        currentBtn.classList.remove('btn-accent');
      }
      currentBtn = null; currentRow = null;
      markNowPlayingInactive();
      if (nowPlayingProgressFill) {
        nowPlayingProgressFill.style.width = '0%';
      }

      // Only hide and reset now playing card and video when explicitly requested
      if (hideCard) {
        const nowPlayingCard = document.getElementById('nowPlayingCard');
        const video = document.getElementById('nowPlayingVideo');
        if (nowPlayingCard) {
          nowPlayingCard.hidden = true;
          nowPlayingCard.classList.remove('playing');
        }
        if (video) {
          video.pause();
          video.currentTime = 0;
        }
      }

      updateRandomSongsControlState();
    }
    function playNextTrackFromPlaylistMeta(meta){
      if (!meta || !meta.playlistId) return false;
      const playlist = playlists.find((p) => p && p.id === meta.playlistId);
      if (!playlist) return false;
      const tracks = Array.isArray(playlist.tracks) ? playlist.tracks : [];
      if (!tracks.length) return false;

      const currentIdx = tracks.findIndex((t) => {
        if (!t) return false;
        if (meta.playlistTrackId && t.id === meta.playlistTrackId) return true;
        if (meta.trackRecordId && t.trackRecordId === meta.trackRecordId) return true;
        return false;
      });

      let nextCandidate = null;
      for (let i = currentIdx + 1; i < tracks.length; i++) {
        const candidate = tracks[i];
        if (!candidate) continue;
        const raw = candidate.resolvedSrc || candidate.S3_URL || candidate.mp3 || candidate.rawUrl || '';
        if (canValidateAudioSrc(resolvePlayableSrc(raw))) {
          nextCandidate = candidate;
          break;
        }
      }
      if (!nextCandidate) return false;

      if (activePlaylistId !== playlist.id) {
        activePlaylistId = playlist.id;
        /* keep collapsed by default */ playlistTracksCollapsed = playlistTracksCollapsed;
        renderPlaylistsPanel();
      } else if (!playlistTracksList || !playlistTracksList.children.length) {
        renderPlaylistTracks();
      }

      if (!playlistTracksList) return false;

      const selectors = [];
      if (nextCandidate.id) selectors.push('[data-track-id="' + nextCandidate.id + '"]');
      if (nextCandidate.trackRecordId) selectors.push('[data-track-id="' + nextCandidate.trackRecordId + '"]');

      let nextRow = null;
      for (const sel of selectors) {
        nextRow = playlistTracksList.querySelector(sel);
        if (nextRow) break;
      }
      if (!nextRow) {
        nextRow = playlistTracksList.querySelector('.playlist-track');
        while (nextRow && !nextRow._src) {
          nextRow = findNextPlayableRow(nextRow);
        }
      }

      if (nextRow && nextRow._btn && nextRow._src) {
        handlePlay(nextRow._btn, nextRow, nextRow._src);
        return true;
      }
      return false;
        }

    function playNextPlayableFrom(anchor){
      if (!anchor) return false;
      let candidate = findNextPlayableRow(anchor);
      while (candidate && !candidate._src) {
        candidate = findNextPlayableRow(candidate);
      }
      if (candidate && candidate._btn && candidate._src) {
        handlePlay(candidate._btn, candidate, candidate._src);
        return true;
      }
      return false;
        }

    player.addEventListener('seeking', () => {
      seekStartPosition = Number.isFinite(player.currentTime) ? player.currentTime : seekStartPosition;
    });
    player.addEventListener('seeked', () => {
      const to = Number.isFinite(player.currentTime) ? player.currentTime : 0;
      const delta = Math.abs(to - seekStartPosition);
      sendStreamEvent('SEEK', getCurrentTrackMeta(), to, player.duration, delta);
    });

    player.addEventListener('ended', () => {
      const meta = getCurrentTrackMeta();
      const duration = Number.isFinite(player.duration) ? player.duration : 0;
      const endedPosition = Number.isFinite(player.currentTime) ? player.currentTime : duration;
      const finalPosition = duration || endedPosition;
      const delta = Math.abs((finalPosition || 0) - lastStreamReportPos);
      sendStreamEvent('END', meta, finalPosition, duration || finalPosition, delta);
      updateRandomSongsControlState();
      if (randomSongsAutoplay.active && currentMode === 'songs') {
        if (advanceRandomSongsAutoplayFrom(currentRow)) {
          return;
        }
      }
      const allowAutoAdvance = currentMode !== 'songs' || randomSongsAutoplay.active;
      let nextLi = currentRow && allowAutoAdvance ? findNextPlayableRow(currentRow) : null;
      while (nextLi && (!nextLi._src || !nextLi._btn)) {
        nextLi = findNextPlayableRow(nextLi);
      }
      if (nextLi && nextLi._btn && nextLi._src) {
        handlePlay(nextLi._btn, nextLi, nextLi._src);
        return;
      }

      // Fallback: attempt to locate the next playlist item if the DOM was re-rendered
      if (!nextLi && nowPlayingInfo.meta?.playlistId && playlistTracksList) {
        const selector = nowPlayingInfo.meta.playlistTrackId
          ? `[data-track-id="${nowPlayingInfo.meta.playlistTrackId}"]`
          : null;
        let anchor = selector ? playlistTracksList.querySelector(selector) : null;
        if (!anchor && currentRow && currentRow._playlist === nowPlayingInfo.meta.playlistId) {
          anchor = currentRow;
        }
        if (!anchor) {
          const first = playlistTracksList.querySelector('.playlist-track');
          anchor = first || null;
        }
        if (anchor) {
          let candidate = findNextPlayableRow(anchor);
          while (candidate && !candidate._src) {
            candidate = findNextPlayableRow(candidate);
          }
          if (candidate && candidate._btn && candidate._src) {
            handlePlay(candidate._btn, candidate, candidate._src);
            return;
          }
        }
      }
      if (playNextTrackFromPlaylistMeta(nowPlayingInfo.meta)) {
        return;
      }

      const shouldAutoplayNextSet = randomSongsAutoplay.active && currentMode === 'songs';
      updateButtonsForStop();
      currentSrc = '';
      updateProgressUI();
      markNowPlayingInactive();
      if (nowPlayingProgressFill) nowPlayingProgressFill.style.width = '0%';
      if (shouldAutoplayNextSet) {
        triggerRandomSongsAutoplayNextPage();
      }
    });
    player.addEventListener('timeupdate', () => {
      updateProgressUI();
      const now = Date.now();
      if (!lastProgressAttemptTs || now - lastProgressAttemptTs >= STREAM_PROGRESS_INTERVAL_MS) {
        lastProgressAttemptTs = now;
        sendStreamEvent('PROGRESS', getCurrentTrackMeta());
      }
    });
    player.addEventListener('loadedmetadata', () => { updateProgressUI(); });
    player.addEventListener('pause', () => {
      console.log('[Pause Event] Pause event fired');
      if (!player.ended) {
        sendStreamEvent('PAUSE', getCurrentTrackMeta(), player.currentTime, player.duration);
      }
      if (currentBtn && currentSrc === player.src) {
        const playLabel = currentBtn.dataset?.playLabel || 'Play';
        currentBtn.textContent = playLabel;
        if (currentBtn.dataset?.playAria) currentBtn.setAttribute('aria-label', currentBtn.dataset.playAria);
        currentBtn.classList.remove('btn-accent');
        if (currentRow) currentRow.classList.remove('playing');
      }
      console.log('[Pause Event] Calling setNowPlayingFromRow with isPlaying=false');
      if (currentRow) setNowPlayingFromRow(currentRow, false);
      else markNowPlayingInactive();
      updateRandomSongsControlState();

      // Control video in now playing and hide card
      const nowPlayingCard = document.getElementById('nowPlayingCard');
      const video = document.getElementById('nowPlayingVideo');
      if (nowPlayingCard) {
        nowPlayingCard.classList.remove('playing');
        nowPlayingCard.hidden = true;
      }
      if (video) {
        video.pause();
        if (player.ended) video.currentTime = 0;
      }
      // Albums grid visibility managed by mode, not playback state
        });
    player.addEventListener('play', () => {
      sendStreamEvent('PLAY', getCurrentTrackMeta(), player.currentTime, player.duration);
      if (currentBtn && currentSrc === player.src) {
        const pauseLabel = currentBtn.dataset?.pauseLabel || 'Pause';
        currentBtn.textContent = pauseLabel;
        if (currentBtn.dataset?.pauseAria) currentBtn.setAttribute('aria-label', currentBtn.dataset.pauseAria);
        currentBtn.classList.add('btn-accent');
        if (currentRow) currentRow.classList.add('playing');
      }
      if (currentRow) setNowPlayingFromRow(currentRow, true);
      updateRandomSongsControlState();

      // Control video in now playing and show card
      const nowPlayingCard = document.getElementById('nowPlayingCard');
      const video = document.getElementById('nowPlayingVideo');
      if (nowPlayingCard) {
        nowPlayingCard.classList.add('playing');
        nowPlayingCard.hidden = false;
      }
      if (video) {
        video.play().catch(err => console.log('[VIDEO] Autoplay prevented:', err));
      }
      // Albums grid visibility managed by mode, not playback state
    });
    let audioErrorRetryCount = 0;
    const MAX_AUDIO_RETRIES = 2;
    const AUDIO_RETRY_DELAY = 1000; // 1 second

    player.addEventListener('error', () => {
      sendStreamEvent('ERROR', getCurrentTrackMeta(), player.currentTime, player.duration);
      const err = player.error;
      if (err) {
        console.warn('[MASS] Audio element error', { code: err.code, message: err.message, retryCount: audioErrorRetryCount });
      } else {
        console.warn('[MASS] Audio element encountered an unknown error', { retryCount: audioErrorRetryCount });
      }

      const fallbackRow = currentRow;
      const failedSrc = currentSrc;
      const proxySrc = buildFallbackAudioSrc(fallbackRow, failedSrc);
      if (fallbackRow && proxySrc && fallbackRow._btn) {
        console.warn('[MASS] Retrying playback via proxied source');
        queueTask(() => {
          handlePlay(fallbackRow._btn, fallbackRow, proxySrc);
        });
        return;
      }

      // Automatic retry on error (helps with idle/token expiration issues)
      if (audioErrorRetryCount < MAX_AUDIO_RETRIES && currentSrc) {
        audioErrorRetryCount++;
        console.log(`[MASS] Auto-retrying audio load (attempt ${audioErrorRetryCount}/${MAX_AUDIO_RETRIES})`);
        setTimeout(() => {
          if (player.src === currentSrc) {
            player.load(); // Reload the audio
            player.play().catch(err => {
              console.warn('[MASS] Auto-retry play failed:', err);
            });
          }
        }, AUDIO_RETRY_DELAY * audioErrorRetryCount); // Exponential backoff
        return;
      }

      // Reset retry count on final failure
      audioErrorRetryCount = 0;

      if (randomSongsAutoplay.active && currentMode === 'songs') {
        advanceRandomSongsAutoplayFrom(currentRow);
      }
    });

    // Reset retry count on successful play
    player.addEventListener('playing', () => {
      audioErrorRetryCount = 0;
    });

    /* ================= Lazy-load FM rows ================= */
    async function loadMore(q){
      showBusy('Loading more…');
      try {
        if (rawItems.length >= rawTotalFound) return false; // nothing left
        const params = new URLSearchParams();
        const advancedSearch = window.__jukeboxAdvancedSearch;
        const usingAdvanced =
          advancedSearch &&
          (advancedSearch.artist || advancedSearch.album || advancedSearch.track);
        if (usingAdvanced) {
          if (advancedSearch.artist) params.set('artist', advancedSearch.artist);
          if (advancedSearch.album) params.set('album', advancedSearch.album);
          if (advancedSearch.track) params.set('track', advancedSearch.track);
          if (advancedSearch.genre) params.set('genre', advancedSearch.genre);
        } else if (q) {
          params.set('q', q);
        }
        const activeGenre = currentSearchFilters && currentSearchFilters.genre ? currentSearchFilters.genre : '';
        if (!usingAdvanced && activeGenre) params.set('genre', activeGenre);
        params.set('offset', rawNextOffset);
        const advancedLimit = usingAdvanced ? Math.max(1, Math.min(500, Number(advancedSearch?.limit) || 200)) : FM_FETCH_LIMIT;
        params.set('limit', usingAdvanced ? advancedLimit : FM_FETCH_LIMIT);
        const r = await fetch(`/api/search?${params}`);
        if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`));
        const j = await r.json();
        const newItems = j.items || [];
        rawItems = rawItems.concat(newItems);
        rawTotalFound = Number(j.total || rawTotalFound);
        const rawReturned = typeof j.rawReturnedCount === 'number' ? j.rawReturnedCount : newItems.length;
        const returnedOffset = Number(j.offset || 0);
        rawNextOffset = returnedOffset + rawReturned;
        albumGroups = groupAlbums(rawItems);
        // Skip audio validation for faster loads
        // primeAlbumAudioValidation(albumGroups);
        refreshPublicPlaylists();
        return newItems.length > 0;
      } finally {
        hideBusy();
      }
        }
    /* ================= Search & paging ================= */
    function shuffleInPlace(arr){
      for(let i=arr.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; }
        }

    function closeExplorePanel(){
      if (explorePanel) explorePanel.setAttribute('hidden', '');
      if (exploreEl) exploreEl.setAttribute('aria-expanded', 'false');
    }

    function handleExploreSearch(term, options = {}){
      if (typeof term !== 'string' || !term.trim()) return;
      const value = term.trim();
      if (searchEl) searchEl.value = value;
      closeExplorePanel();
      run(value, options);
    }

    function syncPublicFeaturedVisibility(){
      if (!publicFeaturedRow) return;
      if (!currentUser) {
        publicFeaturedRow.setAttribute('hidden', '');
        return;
      }
      if (currentMode === 'search') {
        publicFeaturedRow.setAttribute('hidden', '');
        return;
      }
      if (sharedPlaylistActive) {
        publicFeaturedRow.setAttribute('hidden', '');
        return;
      }
      const panelHidden = !publicPlaylistsPanel || publicPlaylistsPanel.hidden;
      const viewHidden = !publicPlaylistView || publicPlaylistView.hidden;
      if (panelHidden && viewHidden) publicFeaturedRow.setAttribute('hidden', '');
      else publicFeaturedRow.removeAttribute('hidden');
    }

    // Pagination state for decade explore
    let exploreOffset = 0;
    let exploreHasMore = false;
    let exploreTotal = 0;
    let exploreCurrentPage = 0; // Which page we're viewing (0-based)

    // Pagination state for genre explore
    let genreOffset = 0;
    let genreHasMore = false;
    let genreTotal = 0;
    let genreCurrentPage = 0; // Which page we're viewing (0-based)
    let currentGenre = ''; // Currently browsing genre

    async function runExplore(startYear, options = {}){
      const isLoadMore = options.loadMore || false;

      // Ensure explore layout class is applied so Featured Playlists render below albums
      try {
        const contentCol = document.querySelector('.content-column');
        contentCol && contentCol.classList.add('exploring');
        if (publicFeaturedRow && currentUser) publicFeaturedRow.removeAttribute('hidden');
      } catch {}

      // Restore playlists when leaving search (explore)
      try {
        ensurePlaylistColumnVisible();
        if (publicFeaturedRow && currentUser) publicFeaturedRow.removeAttribute('hidden');
      } catch {}

      const restoringThisRun = isRestoring;
      if (!isRestoring && !isLoadMore) {
        if (albumGroups.length || rawItems.length) {
          const snapshot = snapshotState();
          prevSearch = { type: snapshot.mode || currentMode, start: startYear, snapshot };
        } else {
          prevSearch = null;
        }
      }

      if (isLoadMore) {
        showBusy(`Loading more ${startYear}s…`);
      } else {
        showBusy(`Loading ${startYear}s…`);
        // Reset pagination for new decade search
        exploreOffset = 0;
        exploreHasMore = false;
        exploreTotal = 0;
        exploreCurrentPage = 0;
        albumPage = 0;
      }

      if (!isLoadMore) {
        hideLanding();
        closeExplorePanel();
      }

      // small guard
      const start = Number(startYear)||0;
      if(!start){
        if (restoringThisRun) isRestoring = false;
        return;
      }
      const end = start + 9;
      const params = new URLSearchParams();
      params.set('start', String(start));
      params.set('end',   String(end));
      params.set('limit', '400'); // Load 400 tracks at a time (6.4% pass rate = ~24-32 albums per fetch, divides evenly into 8-album pages)
      params.set('pagination', 'true'); // Enable pagination mode
      params.set('offset', String(exploreOffset)); // Current offset
      if (options.refresh && !isLoadMore) {
        params.set('refresh', '1'); // Bypass cache for fresh random selection
      }
      try {
        const r = await fetch(`/api/explore?${params}`);
        if (!r.ok) {
          errorEl.hidden = false;
          errorEl.textContent = 'Explore error: ' + await r.text();
          return;
        }

        const j = await r.json();

        // Update pagination state
        exploreHasMore = j.hasMore || false;
        exploreTotal = j.total || 0;
        if (j.nextOffset !== null && j.nextOffset !== undefined) {
          exploreOffset = j.nextOffset;
        }

        if (!j || !Array.isArray(j.items) || j.items.length === 0){
          if (!isLoadMore) {
            errorEl.hidden = false;
            errorEl.textContent = `No albums found for the ${start}s.`;
            rawItems = [];
            rawTotalFound = 0;
            rawNextOffset = 0;
            albumGroups = [];
            albumPage = 0;
            activePublicPlaylist = null;
            refreshPublicPlaylists();
            renderAlbumPage();
            updateLoadMoreButton(false);
          }
          return;
        }

        const newItems = j.items || [];
        const groupedAlbums = groupAlbums(newItems);
        console.log(`[runExplore] Loaded ${groupedAlbums.length} unique albums from ${newItems.length} tracks for ${start}s (hasMore: ${exploreHasMore}, total: ${exploreTotal})`);

        if (isLoadMore) {
          // Append to existing albums
          const beforeCount = albumGroups.length;

          // Deduplicate by catalogue number to avoid showing same album twice
          const existingCatalogues = new Set(albumGroups.map(a => a.catalogue));
          const newUniqueAlbums = groupedAlbums.filter(a => !existingCatalogues.has(a.catalogue));

          albumGroups = albumGroups.concat(newUniqueAlbums);
          rawItems = rawItems.concat(newItems);

          // Don't auto-advance page - let the caller decide
          console.log(`[runExplore] LOAD MORE: before=${beforeCount}, added=${newUniqueAlbums.length} unique (${groupedAlbums.length} total), after=${albumGroups.length}, staying on page=${exploreCurrentPage}`);
        } else {
          // Replace albums for new search
          albumGroups = groupedAlbums;
          rawItems = newItems;
          albumPage = 0;
          activePublicPlaylist = null;
        }

        rawTotalFound = exploreTotal;
        rawNextOffset = 0;

        // Skip expensive audio validation - trust FileMaker data
        // primeAlbumAudioValidation(albumGroups);
        currentMode = 'explore';
        currentExploreDecade = start; // Save decade for reload

        if (!albumGroups.length && !isLoadMore) {
          errorEl.hidden = false;
          errorEl.textContent = `No albums with complete audio and artwork found for the ${start}s.`;
          rawItems = [];
          rawTotalFound = 0;
          refreshPublicPlaylists([]);
          renderAlbumPage();
          updateLoadMoreButton(false);
          return;
        }

        if (!isLoadMore) {
          refreshPublicPlaylists(groupedAlbums);
        }

        renderAlbumPage();
        updateLoadMoreButton(exploreHasMore, albumGroups.length, exploreTotal);
      } finally {
        hideBusy();
        if (restoringThisRun) isRestoring = false;
      }
        }

    async function runGenreExplore(genre, options = {}) {
      const isLoadMore = options.loadMore || false;

      // Ensure explore layout class is applied
      try {
        const contentCol = document.querySelector('.content-column');
        contentCol && contentCol.classList.add('exploring');
        if (publicFeaturedRow && currentUser) publicFeaturedRow.removeAttribute('hidden');
      } catch {}

      // Restore playlists when leaving search (explore)
      try {
        ensurePlaylistColumnVisible();
        if (publicFeaturedRow && currentUser) publicFeaturedRow.removeAttribute('hidden');
      } catch {}

      const restoringThisRun = isRestoring;
      if (!isRestoring && !isLoadMore) {
        if (albumGroups.length || rawItems.length) {
          const snapshot = snapshotState();
          prevSearch = { type: snapshot.mode || currentMode, start: genre, snapshot };
        } else {
          prevSearch = null;
        }
      }

      if (isLoadMore) {
        showBusy(`Loading more ${genre}…`);
      } else {
        showBusy(`Loading ${genre}…`);
        // Reset pagination for new genre search
        genreOffset = 0;
        genreHasMore = false;
        genreTotal = 0;
        genreCurrentPage = 0;
        albumPage = 0;
      }

      if (!isLoadMore) {
        hideLanding();
        closeExplorePanel();
      }

      // Validate genre
      if (!genre || typeof genre !== 'string') {
        if (restoringThisRun) isRestoring = false;
        return;
      }

      const params = new URLSearchParams();
      params.set('genre', genre);
      params.set('limit', '400'); // Load 400 tracks at a time (similar to decade)
      params.set('offset', String(genreOffset));

      try {
        const r = await fetch(`/api/search?${params}`);
        if (!r.ok) {
          errorEl.hidden = false;
          errorEl.textContent = 'Genre search error: ' + await r.text();
          return;
        }

        const j = await r.json();

        // Calculate if there's more data based on TRACKS from FileMaker, not albums
        const rawReturned = j.rawReturnedCount || 0; // Actual tracks FileMaker returned
        const totalTracks = j.total || 0;
        genreHasMore = (genreOffset + rawReturned) < totalTracks; // More tracks available?
        genreTotal = totalTracks;
        genreOffset += rawReturned; // Increment by tracks, not albums

        if (!j || !Array.isArray(j.items) || j.items.length === 0) {
          if (!isLoadMore) {
            errorEl.hidden = false;
            errorEl.textContent = `No albums found for ${genre}.`;
            rawItems = [];
            rawTotalFound = 0;
            rawNextOffset = 0;
            albumGroups = [];
            albumPage = 0;
            activePublicPlaylist = null;
            refreshPublicPlaylists();
            renderAlbumPage();
            updateLoadMoreButton(false);
          }
          return;
        }

        const newItems = j.items || [];
        const groupedAlbums = groupAlbums(newItems);
        console.log(`[runGenreExplore] Loaded ${groupedAlbums.length} unique albums from ${newItems.length} tracks for ${genre} (hasMore: ${genreHasMore}, offset: ${genreOffset})`);

        if (isLoadMore) {
          // Append to existing albums
          const beforeCount = albumGroups.length;

          // Deduplicate by catalogue number
          const existingCatalogues = new Set(albumGroups.map(a => a.catalogue));
          const newUniqueAlbums = groupedAlbums.filter(a => !existingCatalogues.has(a.catalogue));

          albumGroups = albumGroups.concat(newUniqueAlbums);
          rawItems = rawItems.concat(newItems);

          console.log(`[runGenreExplore] LOAD MORE: before=${beforeCount}, added=${newUniqueAlbums.length} unique (${groupedAlbums.length} total), after=${albumGroups.length}, staying on page=${genreCurrentPage}`);
        } else {
          // Replace albums for new search
          albumGroups = groupedAlbums;
          rawItems = newItems;
          albumPage = 0;
          activePublicPlaylist = null;
        }

        rawTotalFound = genreTotal;
        rawNextOffset = 0;

        currentMode = 'genre';
        currentGenre = genre; // Save genre for reload

        if (!albumGroups.length && !isLoadMore) {
          errorEl.hidden = false;
          errorEl.textContent = `No albums with complete audio and artwork found for ${genre}.`;
          rawItems = [];
          rawTotalFound = 0;
          refreshPublicPlaylists([]);
          renderAlbumPage();
          updateLoadMoreButton(false);
          return;
        }

        if (!isLoadMore) {
          refreshPublicPlaylists(groupedAlbums);
        }

        renderAlbumPage();
        updateLoadMoreButton(genreHasMore, albumGroups.length, genreTotal);
      } finally {
        hideBusy();
        if (restoringThisRun) isRestoring = false;
      }
    }

    // Build decade chips and toggle
    if (exploreDecadesEl){
      const decades = [1950,1960,1970,1980,1990,2000,2010,2020];
      exploreDecadesEl.innerHTML = '';
      for (const d of decades) {
        const b = document.createElement('button');
        b.textContent = d + 's';
        b.addEventListener('click', () => runExplore(d));
        exploreDecadesEl.appendChild(b);
      }
    }

    // Connect decade dropdown to explore functionality
    const searchDecadeDropdown = document.getElementById('searchDecade');
    if (searchDecadeDropdown) {
      searchDecadeDropdown.addEventListener('change', function() {
        const selectedValue = searchDecadeDropdown.value;
        if (!selectedValue) {
          return;
        }
        const match = selectedValue.match(/^(\d{4})s$/);
        if (match) {
          const startYear = parseInt(match[1], 10);
          runExplore(startYear);
        }
      });
    }

    if (exploreGenresEl){
      const genres = ['Marabi','Maskandi','Kwela','Mbaqanga','Country','Pop','Rock','Afro Rock','Afro Pop'];
      exploreGenresEl.innerHTML = '';
      for (const genre of genres) {
        const btn = document.createElement('button');
        btn.textContent = genre;
        btn.addEventListener('click', () => runGenreExplore(genre));
        exploreGenresEl.appendChild(btn);
      }
    }

    if (exploreMoodsEl){
      const moods = ['Happy','Romantic','RoadTrip','Sunset'];
      exploreMoodsEl.innerHTML = '';
      for (const mood of moods) {
        const btn = document.createElement('button');
        btn.textContent = mood;
        btn.addEventListener('click', () => handleExploreSearch(mood));
        exploreMoodsEl.appendChild(btn);
      }
    }

    if (exploreEl && explorePanel){
      exploreEl.setAttribute('aria-expanded', explorePanel.hasAttribute('hidden') ? 'false' : 'true');
      exploreEl.addEventListener('click', () => {
        const hidden = explorePanel.hasAttribute('hidden');
        if (hidden) {
          explorePanel.removeAttribute('hidden');
          exploreEl.setAttribute('aria-expanded', 'true');
        } else {
          closeExplorePanel();
        }
      });
    }

    // Update Load More button visibility and info
    function updateLoadMoreButton(hasMore, currentCount, total) {
      const container = document.getElementById('loadMoreContainer');
      const btn = document.getElementById('loadMoreBtn');
      const info = document.getElementById('loadMoreInfo');

      if (!container || !btn || !info) return;

      if (!currentCount) {
        container.hidden = true;
        return;
      }

      // In explore/genre mode: Show Load More if there are more pages OR API has more data
      // In search mode: Use traditional page-based logic
      let shouldShowButton;
      let displayedSoFar;

      if (currentMode === 'explore' || currentMode === 'landing' || currentMode === 'featured') {
        const totalPages = Math.ceil(currentCount / ALBUMS_PER_PAGE);
        const hasMorePages = (exploreCurrentPage + 1) < totalPages;
        shouldShowButton = hasMorePages || hasMore;
        displayedSoFar = Math.min((exploreCurrentPage + 1) * ALBUMS_PER_PAGE, currentCount);
      } else if (currentMode === 'genre') {
        const totalPages = Math.ceil(currentCount / ALBUMS_PER_PAGE);
        const hasMorePages = (genreCurrentPage + 1) < totalPages;
        shouldShowButton = hasMorePages || hasMore;
        displayedSoFar = Math.min((genreCurrentPage + 1) * ALBUMS_PER_PAGE, currentCount);
      } else {
        const totalPages = Math.ceil(currentCount / ALBUMS_PER_PAGE);
        const hasMorePages = (albumPage + 1) < totalPages;
        shouldShowButton = hasMorePages || hasMore;
        displayedSoFar = Math.min((albumPage + 1) * ALBUMS_PER_PAGE, currentCount);
      }

      if (!shouldShowButton) {
        container.hidden = true;
        return;
      }

      container.hidden = false;
      const currentPageNum = (currentMode === 'explore' || currentMode === 'landing' || currentMode === 'featured')
        ? exploreCurrentPage + 1
        : (currentMode === 'genre' ? genreCurrentPage + 1 : albumPage + 1);

      // Calculate pages based on actually loaded albums, not FileMaker's track count
      const currentTotalPages = Math.ceil(currentCount / ALBUMS_PER_PAGE);
      const moreIndicator = hasMore ? '+' : '';
      info.textContent = `Page ${currentPageNum} of ${currentTotalPages}${moreIndicator} • ${currentCount.toLocaleString()} albums loaded`;
    }

    // Load More button click handler
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', async () => {
        if (currentMode === 'genre') {
          // Genre mode pagination
          if (!currentGenre) return;

          const nextPageStart = (genreCurrentPage + 1) * ALBUMS_PER_PAGE;
          const nextPageEnd = nextPageStart + ALBUMS_PER_PAGE;

          // Keep fetching until we have enough albums for a full page or no more data
          while (albumGroups.length < nextPageEnd && genreHasMore) {
            const beforeCount = albumGroups.length;
            await runGenreExplore(currentGenre, { loadMore: true });
            const afterCount = albumGroups.length;

            // If no new albums were added (all duplicates), stop to prevent infinite loop
            if (afterCount <= beforeCount) {
              console.log('[loadMore] Genre: No new unique albums added, stopping fetch loop');
              break;
            }
          }

          // Advance to next page
          genreCurrentPage++;
          renderAlbumPage();
          updateLoadMoreButton(genreHasMore, albumGroups.length, genreTotal);
        } else {
          // Decade explore mode pagination
          if (!currentExploreDecade) return;

          const nextPageStart = (exploreCurrentPage + 1) * ALBUMS_PER_PAGE;
          const nextPageEnd = nextPageStart + ALBUMS_PER_PAGE;

          // Keep fetching until we have enough albums for a full page or no more data
          while (albumGroups.length < nextPageEnd && exploreHasMore) {
            const beforeCount = albumGroups.length;
            await runExplore(currentExploreDecade, { loadMore: true });
            const afterCount = albumGroups.length;

            // If no new albums were added (all duplicates), stop to prevent infinite loop
            if (afterCount <= beforeCount) {
              console.log('[loadMore] Decade: No new unique albums added, stopping fetch loop');
              break;
            }
          }

          // Advance to next page
          exploreCurrentPage++;
          renderAlbumPage();
          updateLoadMoreButton(exploreHasMore, albumGroups.length, exploreTotal);
        }
      });
    }

    function run(q, options = {}){
      prepareSearchLayout();
      const normalizedFilters = normalizeSearchFilters(options);
      if(!q){
        currentSearchFilters = normalizeSearchFilters();
        showLanding();
        if (isRestoring) isRestoring = false;
        return;
      } // keep everything else untouched; only search when user types
      const restoringThisRun = beginSearchSession(q);
      setAiStatus('', false);
      showBusy('Searching…');
      currentSearchFilters = normalizedFilters;
      doSearch(q, normalizedFilters)
        .then(json => {
          applySearchResults(json, q, { source: 'search' });
        })
        .catch(err => {
          if (err.name === 'AbortError') return;
          errorEl.hidden = false;
          errorEl.textContent = `Search error: ${err.message || err}`;
        })
        .finally(() => {
          finalizeSearch(restoringThisRun);
        });
        }

    function runAiSearch(rawQuery){
      prepareSearchLayout();
      currentSearchFilters = normalizeSearchFilters();
      const query = (rawQuery || '').trim();
      if (!query) {
        if (aiSearchInput) aiSearchInput.focus();
        return;
      }
      if (aiSearchPanel && aiSearchPanel.getAttribute('data-collapsed') === 'true') {
        aiSearchPanel.setAttribute('data-collapsed', 'false');
        if (aiSearchToggle) aiSearchToggle.setAttribute('aria-expanded', 'true');
      }
      if (aiSearchController) {
        try { aiSearchController.abort(); } catch {}
      }
      const restoringThisRun = beginSearchSession(query);
      setAiStatus('Interpreting your request…', true);
      showBusy('Asking AI…');
      const ctrl = new AbortController();
      aiSearchController = ctrl;
      fetch(`/api/ai-search?q=${encodeURIComponent(query)}`, { signal: ctrl.signal })
        .then(async (r) => {
          if (!r.ok) {
            const text = await r.text().catch(() => `HTTP ${r.status}`);
            throw new Error(text || 'AI search failed');
          }
          return r.json();
        })
        .then(json => {
          applySearchResults(json, query, { source: 'ai-search', aiInterpretation: json?.aiInterpretation });
        })
        .catch(err => {
          if (err.name === 'AbortError') return;
          console.error('[ai-search]', err);
          errorEl.hidden = false;
          errorEl.textContent = `AI search error: ${err.message || err}`;
          clearAiInterpretation();
        })
        .finally(() => {
          if (aiSearchController === ctrl) aiSearchController = null;
          setAiStatus('', false);
          finalizeSearch(restoringThisRun);
        });
        }

    if (goEl) {
      goEl.addEventListener('click', () => {
        const q = searchEl.value.trim();
        const artist = searchArtistEl ? searchArtistEl.value.trim() : '';
        const album = searchAlbumEl ? searchAlbumEl.value.trim() : '';
        const track = searchTrackEl ? searchTrackEl.value.trim() : '';
        const genreEl = document.getElementById('searchGenre');
        const genre = genreEl ? genreEl.value.trim() : '';

        console.log('[Search Button] Fields:', { q, artist, album, track, genre });

        // If ONLY genre is selected (no q, artist, album, or track), use genre pagination
        if (!q && !artist && !album && !track && genre) {
          console.log('[Search Button] Genre-only search detected, using runGenreExplore:', genre);
          return runGenreExplore(genre);
        }

        // Store advanced search fields for loadMore functionality
        window.__jukeboxAdvancedSearch = { artist, album, track, genre };
        run(q, { genre });
      });
    }
    if (searchEl) {
      searchEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          goEl.click();
        }
      });
        }
    if (aiSearchButton) {
      aiSearchButton.addEventListener('click', () => {
        const value = aiSearchInput ? aiSearchInput.value.trim() : '';
        runAiSearch(value);
      });
    }
    if (aiSearchInput) {
      aiSearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          runAiSearch(aiSearchInput.value.trim());
        }
      });
    }
    if (aiSearchToggle && aiSearchPanel) {
      aiSearchToggle.addEventListener('click', () => {
        const isCollapsed = aiSearchPanel.getAttribute('data-collapsed') !== 'false';
        const nextState = isCollapsed ? 'false' : 'true';
        aiSearchPanel.setAttribute('data-collapsed', nextState);
        aiSearchToggle.setAttribute('aria-expanded', nextState === 'false' ? 'true' : 'false');
        if (nextState === 'false' && aiSearchInput) {
          setTimeout(() => aiSearchInput.focus(), 0);
        }
      });
    }
    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        const next = !document.body.classList.contains('alt-theme');
        applyTheme(next);
        try {
          localStorage.setItem(THEME_STORAGE_KEY, next ? '1' : '0');
        } catch {}
      });
    }
    console.log('[INIT] Attaching clearEl event listener, button exists:', !!clearEl);
    if (clearEl) {
      clearEl.addEventListener('click', () => {
        console.log('[clearEl] Button clicked!');
        if (searchEl) searchEl.value='';
        if (searchArtistEl) searchArtistEl.value='';
        if (searchAlbumEl) searchAlbumEl.value='';
        if (searchTrackEl) searchTrackEl.value='';
        lastQ = '';
        currentSearchFilters = normalizeSearchFilters();

        // Stop playback and clear now playing
        if (player && !player.paused) {
          player.pause();
        }
        currentSrc = '';
        updateButtonsForStop(true); // Pass true to hide the card
        clearNowPlaying();

        loadFeaturedAlbums({ refresh: true });
      });
    }

    console.log('[INIT] Attaching shuffleBtn event listener, button exists:', !!shuffleBtn);
    if (shuffleBtn) {
      shuffleBtn.addEventListener('click', () => {
        console.log('[shuffleBtn] Button clicked! currentExploreDecade:', currentExploreDecade, 'currentMode:', currentMode);
        if (currentExploreDecade !== null) {
          // Reload the same decade with different random offset (bypass cache)
          runExplore(currentExploreDecade, { refresh: true });
        } else {
          // Load random songs and immediately start shuffle play
          loadRandomSongs().then(() => {
            // Wait a moment for songs to render, then trigger shuffle play
            setTimeout(() => {
              if (shufflePlayBtn && currentMode === 'songs') {
                console.log('[shuffleBtn] Auto-triggering shuffle play');
                shufflePlayBtn.click();
              }
            }, 100);
          }).catch(err => {
            console.error('[shuffleBtn] Failed to load random songs:', err);
          });
        }
      });
    }

    console.log('[INIT] Attaching shufflePlayBtn event listener, button exists:', !!shufflePlayBtn);
    if (shufflePlayBtn) {
      shufflePlayBtn.addEventListener('click', () => {
        if (currentMode !== 'songs') {
          console.log('[shufflePlayBtn] Ignored click outside songs mode');
          return;
        }
        if (randomSongsAutoplay.active) {
          console.log('[shufflePlayBtn] Stopping autoplay');
          stopRandomSongsAutoplay();
          if (player) {
            try { player.pause(); } catch {}
            try { player.currentTime = 0; } catch {}
          }
          updateButtonsForStop();
          updateRandomSongsControlState();
          return;
        }
        console.log('[shufflePlayBtn] Starting autoplay');
        randomSongsAutoplay.active = true;
        randomSongsAutoplay.retries = 0;
        const songIsPlaying = currentRow && !player.paused && albumsEl && albumsEl.contains(currentRow) && currentRow._btn && currentRow._src;
        if (songIsPlaying) {
          randomSongsAutoplay.pendingStart = false;
          updateRandomSongsAutoplayButton();
        } else {
          randomSongsAutoplay.pendingStart = true;
          updateRandomSongsAutoplayButton();
          kickOffRandomSongsAutoplay();
        }
      });
    }

    console.log('[INIT] Attaching randomStopBtn event listener, button exists:', !!randomStopBtn);
    if (randomStopBtn) {
      randomStopBtn.addEventListener('click', () => {
        if (currentMode !== 'songs') return;
        stopRandomSongsAutoplay();
        if (player) {
          try { player.pause(); } catch {}
          try { player.currentTime = 0; } catch {}
        }
        updateButtonsForStop(true); // Pass true to hide the now playing card
        updateRandomSongsControlState();
      });
    }

    console.log('[INIT] Attaching randomSkipBtn event listener, button exists:', !!randomSkipBtn);
    if (randomSkipBtn) {
      randomSkipBtn.addEventListener('click', () => {
        if (currentMode !== 'songs') return;
        const anchor = currentRow || findFirstRandomSongRow();
        if (randomSongsAutoplay.active) {
          advanceRandomSongsAutoplayFrom(anchor || currentRow);
        } else if (anchor && anchor._btn && anchor._src) {
          if (!currentRow) {
            handlePlay(anchor._btn, anchor, anchor._src);
          } else if (!playNextPlayableFrom(anchor)) {
            loadRandomSongs();
          }
        } else {
          loadRandomSongs();
        }
        updateRandomSongsControlState();
      });
    }

    updateRandomSongsControlState();

    if (prevEl) {
      prevEl.addEventListener('click', () => {
        if (albumPage > 0) {
          albumPage--;
          shouldScrollAlbums = true;
          renderAlbumPage();
        }
      });
    }
    if (nextEl) {
      nextEl.addEventListener('click', async () => {
      const maxPage = Math.max(1, Math.ceil((albumGroups.length||0) / ALBUMS_PER_PAGE));
      // If at the last page but FM has more rows, fetch next chunk first
      if (albumPage >= maxPage - 1 && rawItems.length < rawTotalFound) {
        nextEl.disabled = true;
        try { await loadMore(lastQ); } finally { nextEl.disabled = false; }
      }
      const newMax = Math.max(1, Math.ceil((albumGroups.length||0) / ALBUMS_PER_PAGE));
      if (albumPage < newMax - 1) {
        albumPage++;
      }
      shouldScrollAlbums = true;
      renderAlbumPage();
    });
    }

    window.addEventListener('popstate', () => {
      const shareId = getShareIdFromLocation();
      if (shareId) {
        activateSharedPlaylist(shareId, { updateUrl: false });
      } else if (sharedPlaylistActive) {
        clearSharedPlaylistState({ restoreLanding: true });
        loadFeaturedAlbums({ refresh: true });
      }
    });

    // Defer initial load to allow browser to paint UI first
    // Hide loading screen immediately for instant page display
    if (loadingIndicator) loadingIndicator.hidden = true;

    // Factor out initial load logic so it can be triggered by access token validation
    function massInitialLoad() {
      console.log('[MASS] Initial load triggered');
      requestAnimationFrame(() => {
        const initialShareId = getShareIdFromLocation();
        if (initialShareId) {
          activateSharedPlaylist(initialShareId, { updateUrl: false });
        } else if (window.__skipFeaturedLoad) {
          console.log('[MASS] Skipping featured albums — URL album/artist params detected');
        } else {
          // Load featured albums after page is visible (lazy load)
          setTimeout(() => loadFeaturedAlbums(), 0);
        }
      });
    }

    // Wait for access token validation before loading data
    // This prevents 403 errors from API calls made before token is ready
    function handleMassAccessReady(e){
      console.log('[MASS] Access ready event received, token:', e.detail.token ? 'YES' : 'NO');
      // Ensure we only run once
      if (window.__massInitialLoadDone) {
        console.log('[MASS] Initial load already done, skipping');
        return;
      }
      window.__massInitialLoadDone = true;

      massInitialLoad();
    }
    window.addEventListener('mass:access-ready', handleMassAccessReady);
    if (window.massAccessReady) {
      console.log('[MASS] Access flag already set, triggering initial load immediately');
      handleMassAccessReady({ detail: { token: window.massAccessToken || null } });
    }

    // Note: No timeout fallback - we must wait for valid access token
    // The app stays on the access token overlay until user provides a valid token

// Export functions for search override
window.run = run;
window.doSearch = doSearch;
window.handleAddToPlaylist = handleAddToPlaylist;
window.handleAddAlbumToPlaylist = handleAddAlbumToPlaylist;
console.log('[EXPORT] Functions exported:', typeof window.run, typeof window.doSearch);
